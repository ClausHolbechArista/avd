# Copyright (c) 2023 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.
from __future__ import annotations

from functools import cached_property

from ansible_collections.arista.avd.plugins.filter.natural_sort import natural_sort
from ansible_collections.arista.avd.plugins.plugin_utils.avdfacts import AvdFacts
from ansible_collections.arista.avd.plugins.plugin_utils.strip_empties import strip_null_from_data
from ansible_collections.arista.avd.plugins.plugin_utils.utils import get

from ..base.utils import UtilsMixin


class AvdStructuredConfigSflow(AvdFacts, UtilsMixin):
    """
    This class must be rendered after all other eos_designs modules since it relies on
    detecting sflow from the interface structured config generated by the other modules.

    The only exception is of course custom_structured_configuration which always comes last.
    """

    @cached_property
    def sflow(self) -> dict | None:
        """
        Structured config for sFlow.

        Only configure if any interface is enabled for sFlow.

        Covers:
        - sflow_settings
        - source-interfaces based on source_interfaces.sflow
        """
        if not self._enable_sflow:
            return None

        destinations = get(self._hostvars, "sflow_settings.destinations")
        if destinations is None:
            # TODO:
            # AVD5.0.0 raise an error if sflow is enabled on an interface but there are no destinations configured.
            # This cannot be implemented today since it would be breaking for already released support for sflow on interfaces.
            return None

        # At this point we have at least one interface with sFlow enabled
        # and at least one destination.
        sflow = {"run": True}

        # Using a temporary dict for VRFs
        sflow_vrfs = {}

        for destination in natural_sort(destinations, "destination"):
            vrfs = set()
            if (vrf := destination.get("vrf")) not in [None, "default"]:
                vrfs.add(vrf)

            if destination.get("use_mgmt_interface_vrf") is True:
                vrfs.add(self.shared_utils.mgmt_interface_vrf)

            if destination.get("use_inband_mgmt_vrf") is True and self.shared_utils.inband_mgmt_interface is not None:
                # self.shared_utils.inband_mgmt_vrf returns None for the default VRF, but here we need "default" to avoid duplicates.
                vrfs.add(self.shared_utils.inband_mgmt_vrf or "default")

            if not vrfs and destination.get("use_inband_mgmt_vrf") is not True:
                # If no VRFs are defined (and we are not just ignoring missing mgmt config)
                vrfs.add("default")

            for vrf in vrfs:
                if vrf in [None, "default"]:
                    # Add host without VRF field
                    sflow.setdefault("destinations", []).append(
                        {
                            "destination": destination.get("destination"),
                            "port": destination.get("port"),
                        }
                    )
                else:
                    # Add host with VRF field.
                    sflow_vrfs.setdefault(vrf, {}).setdefault("destinations", []).append(
                        {
                            "destination": destination.get("destination"),
                            "port": destination.get("port"),
                        }
                    )

        if source_interfaces_inputs := self._source_interfaces.get("sflow"):
            source_interfaces = self._build_source_interfaces(
                source_interfaces_inputs.get("mgmt_interface", False), source_interfaces_inputs.get("inband_mgmt_interface", False), "sFlow"
            )
            # Unpack source_interfaces into the sflow data model
            for source_interface in source_interfaces:
                if (vrf := source_interface.get("vrf")) in [None, "default"]:
                    # Default VRF source-interface
                    sflow["source_interface"] = source_interface["name"]
                else:
                    # VRF source-interface
                    sflow_vrfs.setdefault(vrf, {})["source_interface"] = source_interface["name"]

        # convert sflow_vrfs dict into list and insert into sflow
        if sflow_vrfs:
            sflow["vrfs"] = [{"name": vrf_name, **vrf} for vrf_name, vrf in sflow_vrfs.items()]

        sflow = strip_null_from_data(sflow)

        return sflow

    @cached_property
    def struct_cfgs(self) -> list[dict] | None:
        """
        Various structured_config keys.

        Covers:
        - fabric_sflow.structured_config inserted under sflow.*
        """
        struct_cfgs = []
        if (struct_cfg := get(self._hostvars, "fabric_sflow.structured_config")) is not None:
            struct_cfgs.append({"sflow": struct_cfg})

        return struct_cfgs or None

    @cached_property
    def _enable_sflow(self) -> bool:
        """
        Enable sFlow if any interface is enabled for sFlow.

        This relies on sFlow being rendered after all other eos_designs modules (except structured config).
        """
        for interface in get(self._hostvars, "ethernet_interfaces", default=[]):
            if get(interface, "sflow.enable") is True:
                return True

        for interface in get(self._hostvars, "port_channel_interfaces", default=[]):
            if get(interface, "sflow.enable") is True:
                return True

        return False
