# Copyright (c) 2023 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: arista/endpointlocation.v1/endpointlocation.proto, arista/endpointlocation.v1/services.gen.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from .... import fmp as ___fmp__
from ... import (
    subscriptions as __subscriptions__,
    time as __time__,
)


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class MacType(betterproto.Enum):
    """
    MacType describes how the MAC address was learned on the port location.
    """

    MAC_TYPE_UNSPECIFIED = 0
    """MAC_TYPE_UNSPECIFIED is the default unspecified MAC type."""

    MAC_TYPE_LEARNED_DYNAMIC = 1
    """
    MAC_TYPE_LEARNED_DYNAMIC indicates a MAC that is dynamically learned in
    hardware.
    """

    MAC_TYPE_LEARNED_SECURE = 2
    """
    MAC_TYPE_LEARNED_SECURE indicates a MAC that is learned in hardware on a
    port-security protect interface.
    """

    MAC_TYPE_CONFIGURED_DYNAMIC = 3
    """MAC_TYPE_CONFIGURED_DYNAMIC indicates a configured dynamic MAC."""

    MAC_TYPE_CONFIGURED_SECURE = 4
    """
    MAC_TYPE_CONFIGURED_SECURE indicates a MAC configured on an interface with
    Port Security: Protect mode enabled
    """

    MAC_TYPE_CONFIGURED_STATIC = 5
    """MAC_TYPE_CONFIGURED_STATIC indicates a statically configured MAC."""

    MAC_TYPE_PEER_DYNAMIC = 6
    """
    MAC_TYPE_PEER_DYNAMIC indicates a dynamically learned MAC discovered via an
    MLAG peer.
    """

    MAC_TYPE_PEER_STATIC = 7
    """
    MAC_TYPE_PEER_STATIC indicates a statically configured MAC discovered via
    an MLAG peer.
    """

    MAC_TYPE_PEER_SECURE = 8
    """
    MAC_TYPE_PEER_SECURE indicates a secure MAC learned from an MLAG peer.
    """

    MAC_TYPE_LEARNED_REMOTE = 9
    """
    MAC_TYPE_LEARNED_REMOTE indicates a MAC learned remotely behind a VxLAN
    VTEP.
    """

    MAC_TYPE_CONFIGURED_REMOTE = 10
    """
    MAC_TYPE_CONFIGURED_REMOTE indicates a MAC configured behind a VxLAN VTEP.
    """

    MAC_TYPE_RECEIVED_REMOTE = 11
    """
    MAC_TYPE_RECEIVED_REMOTE indicates a MAC received from a VxLAN controller.
    """

    MAC_TYPE_PEER_LEARNED_REMOTE = 12
    """
    MAC_TYPE_PEER_LEARNED_REMOTE indicates a remote MAC learned on a peer VTEP.
    """

    MAC_TYPE_PEER_CONFIGURED_REMOTE = 13
    """
    MAC_TYPE_PEER_CONFIGURED_REMOTE indicates an MLAG peer configured remote
    MAC.
    """

    MAC_TYPE_PEER_RECEIVED_REMOTE = 14
    """
    MAC_TYPE_PEER_RECEIVED_REMOTE indicates a remote MAC received from a VxLAN
    controller by the MLAG peer.
    """

    MAC_TYPE_EVPN_DYNAMIC_REMOTE = 15
    """MAC_TYPE_EVPN_DYNAMIC_REMOTE indicates an EVPN dynamic remote MAC."""

    MAC_TYPE_EVPN_CONFIGURED_REMOTE = 16
    """
    MAC_TYPE_EVPN_CONFIGURED_REMOTE indicates an EVPN configured remote MAC.
    """

    MAC_TYPE_PEER_EVPN_REMOTE = 17
    """MAC_TYPE_PEER_EVPN_REMOTE indicates an MLAG peer EVPN remote MAC."""

    MAC_TYPE_CONFIGURED_ROUTER = 18
    """
    MAC_TYPE_CONFIGURED_ROUTER indicates a configured MAC used in routing.
    """

    MAC_TYPE_PEER_ROUTER = 19
    """MAC_TYPE_PEER_ROUTER indicates an MLAG peer specific router MAC."""

    MAC_TYPE_EVPN_INTF_DYNAMIC = 20
    """
    MAC_TYPE_EVPN_INTF_DYNAMIC indicates a MAC advertised by EVPN when a
    dynamic MAC is learned on ESI (Ethernet Segment Identifier).
    """

    MAC_TYPE_EVPN_INTF_STATIC = 21
    """MAC_TYPE_EVPN_INTF_STATIC indicates a MAC configured on EVPN ESI."""

    MAC_TYPE_AUTHENTICATED = 22
    """MAC_TYPE_AUTHENTICATED indicates a MAC authenticated via 802.1X."""

    MAC_TYPE_PEER_AUTHENTICATED = 23
    """
    MAC_TYPE_PEER_AUTHENTICATED indicates a MAC authenticated by 802.1X and
    learned on an MLAG peer.
    """

    MAC_TYPE_PENDING_SECURE = 24
    """MAC_TYPE_PENDING_SECURE indicates a secure MAC in a pending state."""

    MAC_TYPE_SOFTWARE_LEARNED_DYNAMIC = 25
    """
    MAC_TYPE_SOFTWARE_LEARNED_DYNAMIC indicates a MAC learned behind VTEP in
    software in the case of a VxLAN remote MAC.
    """

    MAC_TYPE_OTHER = 99999
    """MAC_TYPE_OTHER is used for capturing future MAC types."""


class Likelihood(betterproto.Enum):
    """Likelihood indicates a level of confidence."""

    LIKELIHOOD_UNSPECIFIED = 0
    """LIKELIHOOD_UNSPECIFIED is the default unspecified likelihood."""

    LIKELIHOOD_VERY_LIKELY = 1
    """LIKELIHOOD_VERY_LIKELY indicates very high confidence."""

    LIKELIHOOD_LIKELY = 2
    """LIKELIHOOD_LIKELY indicates high confidence."""

    LIKELIHOOD_SOMEWHAT_LIKELY = 3
    """LIKELIHOOD_SOMEWHAT_LIKELY indicates medium confidence."""

    LIKELIHOOD_LESS_LIKELY = 4
    """LIKELIHOOD_LESS_LIKELY indicates low confidence."""


class IdentifierType(betterproto.Enum):
    """IdentifierType defines the set of ways for identifying endpoints."""

    IDENTIFIER_TYPE_UNSPECIFIED = 0
    """IDENTIFIER_TYPE_UNSPECIFIED is the default unspecified identifier."""

    IDENTIFIER_TYPE_MAC_ADDR = 1
    """IDENTIFIER_TYPE_MAC_ADDR indicates a MAC address identifier."""

    IDENTIFIER_TYPE_IPV4_ADDR = 2
    """IDENTIFIER_TYPE_IPV4_ADDR indicates an IPv4 address identifier."""

    IDENTIFIER_TYPE_IPV6_ADDR = 3
    """IDENTIFIER_TYPE_IPV6_ADDR indicates an IPv6 address identifier."""

    IDENTIFIER_TYPE_INVENTORY_DEVICE_ID = 4
    """
    IDENTIFIER_TYPE_INVENTORY_DEVICE_ID indicates an inventory device
    identifier.
    """

    IDENTIFIER_TYPE_PRIMARY_MANAGEMENT_IP = 5
    """
    IDENTIFIER_TYPE_PRIMARY_MANAGEMENT_IP indicates a primary management IP
    identifier.
    """

    IDENTIFIER_TYPE_HOSTNAME = 6
    """IDENTIFIER_TYPE_HOSTNAME indicates a hostname identifier."""

    IDENTIFIER_TYPE_USERNAME = 7
    """IDENTIFIER_TYPE_USERNAME indicates a username identifier."""

    IDENTIFIER_TYPE_OTHER = 99999
    """IDENTIFIER_TYPE_OTHER is used for an unknown identifier."""


class IdentifierSource(betterproto.Enum):
    """
    IdentifierSource defines the set of network protocols and other information
    sources where an identifier was found.
    """

    IDENTIFIER_SOURCE_UNSPECIFIED = 0
    """
    IDENTIFIER_SOURCE_UNSPECIFIED is the default unspecified identifier source.
    """

    IDENTIFIER_SOURCE_FDB = 1
    """IDENTIFIER_SOURCE_FDB indicates a forwarding table."""

    IDENTIFIER_SOURCE_ARP = 2
    """IDENTIFIER_SOURCE_ARP indicates ARP (IPv4)."""

    IDENTIFIER_SOURCE_NEIGHBOR = 3
    """IDENTIFIER_SOURCE_NEIGHBOR indicates NDP (IPv6)."""

    IDENTIFIER_SOURCE_DEVICE_INVENTORY = 4
    """
    IDENTIFIER_SOURCE_DEVICE_INVENTORY indicates that an endpoint is in the
    CloudVision inventory.
    """

    IDENTIFIER_SOURCE_LLDP = 5
    """IDENTIFIER_SOURCE_LLDP indicates LLDP."""

    IDENTIFIER_SOURCE_DHCP = 6
    """IDENTIFIER_SOURCE_DHCP indicates DHCP."""

    IDENTIFIER_SOURCE_WIFI = 7
    """
    IDENTIFIER_SOURCE_WIFI indicates a WiFi endpoint that was learned through a
    wireless manager.
    """


class Explanation(betterproto.Enum):
    """
    Explanation defines the set of reasons for why a location has a certain
    likelihood. Some explanations apply to queried endpoints while others apply
    to queried devices in the CloudVision device inventory.
    """

    EXPLANATION_UNSPECIFIED = 0
    """EXPLANATION_UNSPECIFIED is the default unspecified explanation."""

    EXPLANATION_DIRECT_CONNECTION = 1
    """
    EXPLANATION_DIRECT_CONNECTION indicates a direct connection to the queried
    endpoint device discovered via LLDP.
    """

    EXPLANATION_NON_INVENTORY_CONNECTION = 2
    """
    EXPLANATION_NON_INVENTORY_CONNECTION indicates a direct connection to at
    least one non-inventory device (likely discovered via LLDP).
    """

    EXPLANATION_NO_CONNECTION = 3
    """
    EXPLANATION_NO_CONNECTION indicates that a location has no direct
    connection to any known device.
    """

    EXPLANATION_INVENTORY_CONNECTION = 4
    """
    EXPLANATION_INVENTORY_CONNECTION indicates that all of a location's known
    connections are to devices in the inventory.
    """

    EXPLANATION_OWN_PORT_INVENTORY_DEVICE = 5
    """
    EXPLANATION_OWN_PORT_INVENTORY_DEVICE indicates a location on the queried
    inventory device itself.
    """

    EXPLANATION_DIRECT_CONNECTION_INVENTORY_DEVICE = 6
    """
    EXPLANATION_DIRECT_CONNECTION_INVENTORY_DEVICE indicates a direct
    connection to the queried inventory device discovered via LLDP.
    """

    EXPLANATION_NO_CONNECTION_INVENTORY_DEVICE = 7
    """
    EXPLANATION_NO_CONNECTION_INVENTORY_DEVICE indicates that a location has no
    direct connection to any known device (for queried inventory devices).
    """

    EXPLANATION_OTHER_CONNECTION_INVENTORY_DEVICE = 8
    """
    EXPLANATION_OTHER_CONNECTION_INVENTORY_DEVICE indicates that a location
    only has connections to other devices besides the queried inventory device.
    """

    EXPLANATION_VIRTUAL = 9
    """
    EXPLANATION_VIRTUAL indicates that a location contains a virtual interface.
    """

    EXPLANATION_WIRELESS_CONNECTION = 10
    """
    EXPLANATION_WIRELESS_CONNECTION indicates a direct connection from a
    wireless access point in the device inventory to a wireless client.
    """


class DeviceType(betterproto.Enum):
    """
    DeviceType defines a broad set of categories for all queried devices.
    """

    DEVICE_TYPE_UNSPECIFIED = 0
    """DEVICE_TYPE_UNSPECIFIED is the default unspecified device type."""

    DEVICE_TYPE_INVENTORY = 1
    """
    DEVICE_TYPE_INVENTORY indicates a device in the CloudVision inventory.
    """

    DEVICE_TYPE_ENDPOINT = 2
    """
    DEVICE_TYPE_ENDPOINT indicates a non-WiFi endpoint that does not exist in
    the CloudVision inventory.
    """

    DEVICE_TYPE_WIFI_ENDPOINT = 3
    """
    DEVICE_TYPE_WIFI_ENDPOINT indicates a WiFi client/endpoint that does not
    exist in the CloudVision inventory.
    """


class DeviceStatus(betterproto.Enum):
    """DeviceStatus is the network status of a device."""

    DEVICE_STATUS_UNSPECIFIED = 0
    """DEVICE_STATUS_UNSPECIFIED is the default unspecified device status."""

    DEVICE_STATUS_ACTIVE = 1
    """
    DEVICE_STATUS_ACTIVE indicates a device is streaming its telemetry data to
    CloudVision.
    """

    DEVICE_STATUS_INACTIVE = 2
    """
    DEVICE_STATUS_INACTIVE indicates a device is either not streaming its
    telemetry data to CloudVision or has been decommissioned from CloudVision.
    """


@dataclass(eq=False, repr=False)
class IdentifierSourceList(betterproto.Message):
    """IdentifierSourceList is a list of IdentifierSource."""

    values: List["IdentifierSource"] = betterproto.enum_field(1)
    """values is an unordered list of unique IdentifierSource."""


@dataclass(eq=False, repr=False)
class Identifier(betterproto.Message):
    """Identifier holds device identification information."""

    type: "IdentifierType" = betterproto.enum_field(1)
    """type is the identifier type corresponding to value."""

    value: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """
    value is the string representation of the identifier. Its interpretation
    depends on type.
    """

    source_list: "IdentifierSourceList" = betterproto.message_field(3)
    """
    source_list is the set of sources where this identifier was discovered.
    """


@dataclass(eq=False, repr=False)
class IdentifierList(betterproto.Message):
    """IdentifierList is a list of Identifier."""

    values: List["Identifier"] = betterproto.message_field(1)
    """
    values is an unordered list of Identifier where each Identifier has a
    unique type and value combination.
    """


@dataclass(eq=False, repr=False)
class ExplanationList(betterproto.Message):
    """ExplanationList is a list of Explanation."""

    values: List["Explanation"] = betterproto.enum_field(1)
    """
    values is a list of unique Explanation. Currently, this will always contain
    one value, but in the future it may contain more.
    """


@dataclass(eq=False, repr=False)
class Location(betterproto.Message):
    """
    Location is a port (device_id, interface, vlan_id) on which at least one
    identifier has been discovered.
    """

    device_id: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    """device_id identifies the device of the port."""

    device_status: "DeviceStatus" = betterproto.enum_field(2)
    """device_status is the status of the device identified by device_id."""

    interface: Optional[str] = betterproto.message_field(
        3, wraps=betterproto.TYPE_STRING
    )
    """interface is the interface of the port."""

    vlan_id: Optional[int] = betterproto.message_field(4, wraps=betterproto.TYPE_UINT32)
    """vlan_id identifies the VLAN of the port."""

    learned_time: datetime = betterproto.message_field(5)
    """learned_time is when the port learned its identifiers."""

    mac_type: "MacType" = betterproto.enum_field(6)
    """mac_type is how the port learned its MAC address identifier."""

    likelihood: "Likelihood" = betterproto.enum_field(7)
    """
    likelihood is the probability level that the port is directly connected to
    the queried endpoint.
    """

    explanation_list: "ExplanationList" = betterproto.message_field(8)
    """
    explanation_list holds the reasons that the port was assigned likelihood.
    """

    identifier_list: "IdentifierList" = betterproto.message_field(9)
    """identifier_list holds the discovered identifiers of the port."""


@dataclass(eq=False, repr=False)
class LocationList(betterproto.Message):
    """LocationList is a list of Location."""

    values: List["Location"] = betterproto.message_field(1)
    """values is a list of unique Location."""


@dataclass(eq=False, repr=False)
class DeviceInfo(betterproto.Message):
    """
    DeviceInfo holds various attributes of a device (typically an endpoint)
    from Fingerbank.
    """

    device_name: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    """device_name is the name of the device."""

    mobile: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    """mobile indicates whether the device is a mobile."""

    tablet: Optional[bool] = betterproto.message_field(3, wraps=betterproto.TYPE_BOOL)
    """tablet indicates whether the device is a tablet."""

    score: Optional[int] = betterproto.message_field(4, wraps=betterproto.TYPE_UINT32)
    """
    score is a value from 0 to 100 that indicates how confident we are that the
    device has device_name. Fingerbank API documentation of score:
    https://api.fingerbank.org/api_doc/2/combinations.html
    """

    version: Optional[str] = betterproto.message_field(5, wraps=betterproto.TYPE_STRING)
    """version is the version of device_name."""

    mac_vendor: Optional[str] = betterproto.message_field(
        6, wraps=betterproto.TYPE_STRING
    )
    """
    mac_vendor is the enterprise that assigns the MAC address of the device.
    """

    classification: Optional[str] = betterproto.message_field(
        7, wraps=betterproto.TYPE_STRING
    )
    """
    classification is the broadest category to which device_name belongs. This
    is the highest level in hierarchy.
    """

    hierarchy: "___fmp__.RepeatedString" = betterproto.message_field(8)
    """
    hierarchy is a list of categorizations of the device from most broad to
    most specific. The first element is always classification and the last
    element is always device_name. For example, ["VoIP Device", "FooInc VoIP",
    "FooInc PhoneSet IP", "FooInc PhoneSet IP Model123"] In this hierarchy,
    "VoIP Device" is classification and "FooInc PhoneSet IP Model123" is
    device_name.
    """


@dataclass(eq=False, repr=False)
class Device(betterproto.Message):
    """Device holds information for a device matching a search term."""

    identifier_list: "IdentifierList" = betterproto.message_field(1)
    """identifier_list holds the unique identifiers for the device."""

    device_type: "DeviceType" = betterproto.enum_field(2)
    """device_type is the broad category of the device."""

    location_list: "LocationList" = betterproto.message_field(3)
    """
    location_list is the list of possible locations of the device. It is
    ordered from most likely to least likely.
    """

    device_status: "DeviceStatus" = betterproto.enum_field(4)
    """device_status is the network status of the device."""

    device_info: "DeviceInfo" = betterproto.message_field(5)
    """device_info holds various attributes of the device."""


@dataclass(eq=False, repr=False)
class DeviceMap(betterproto.Message):
    """DeviceMap is a collection of Device."""

    values: Dict[str, "Device"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """
    values is a map from most specific identifier to Device. The key could be
    device serial number or MAC address.
    """


@dataclass(eq=False, repr=False)
class EndpointLocationKey(betterproto.Message):
    """EndpointLocationKey holds a search term used to locate an endpoint."""

    search_term: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    """
    search_term is used to match against identifiers on devices. This could be
    a MAC/IP address, hostname, etc.
    """


@dataclass(eq=False, repr=False)
class EndpointLocation(betterproto.Message):
    """EndpointLocation is the entrypoint to searching for endpoints."""

    key: "EndpointLocationKey" = betterproto.message_field(1)
    """key holds a search term used to locate an endpoint."""

    device_map: "DeviceMap" = betterproto.message_field(2)
    """
    device_map holds the devices (and their potential locations) that match the
    search term.
    """


@dataclass(eq=False, repr=False)
class EndpointLocationRequest(betterproto.Message):
    key: "EndpointLocationKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a EndpointLocation instance to retrieve. This value
    must be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class EndpointLocationResponse(betterproto.Message):
    value: "EndpointLocation" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    EndpointLocation instance in this response.
    """


@dataclass(eq=False, repr=False)
class EndpointLocationStreamRequest(betterproto.Message):
    partial_eq_filter: List["EndpointLocation"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. For GetAll, the fields start and end can be used as follows:   *
    end: Returns the state of each EndpointLocation at end.     * Each
    EndpointLocation response is fully-specified (all fields set).   * start:
    Returns the state of each EndpointLocation at start, followed by updates
    until now.     * Each EndpointLocation response at start is fully-
    specified, but updates may be partial.   * start and end: Returns the state
    of each EndpointLocation at start, followed by updates     until end.     *
    Each EndpointLocation response at start is fully-specified, but updates
    until end may       be partial. This field is not allowed in the Subscribe
    RPC.
    """


@dataclass(eq=False, repr=False)
class EndpointLocationStreamResponse(betterproto.Message):
    value: "EndpointLocation" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time holds the timestamp of this EndpointLocation's last modification.
    """

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the EndpointLocation value in this response should
    be considered. Under non-subscribe requests, this value should always be
    INITIAL. In a subscription, once all initial data is streamed and the
    client begins to receive modification updates, you should not see INITIAL
    again.
    """


class EndpointLocationServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        endpoint_location_request: "EndpointLocationRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EndpointLocationResponse":
        return await self._unary_unary(
            "/arista.endpointlocation.v1.EndpointLocationService/GetOne",
            endpoint_location_request,
            EndpointLocationResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        endpoint_location_stream_request: "EndpointLocationStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["EndpointLocationStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.endpointlocation.v1.EndpointLocationService/GetAll",
            endpoint_location_stream_request,
            EndpointLocationStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        endpoint_location_stream_request: "EndpointLocationStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["EndpointLocationStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.endpointlocation.v1.EndpointLocationService/Subscribe",
            endpoint_location_stream_request,
            EndpointLocationStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class EndpointLocationServiceBase(ServiceBase):
    async def get_one(
        self, endpoint_location_request: "EndpointLocationRequest"
    ) -> "EndpointLocationResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, endpoint_location_stream_request: "EndpointLocationStreamRequest"
    ) -> AsyncIterator["EndpointLocationStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield EndpointLocationStreamResponse()

    async def subscribe(
        self, endpoint_location_stream_request: "EndpointLocationStreamRequest"
    ) -> AsyncIterator["EndpointLocationStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield EndpointLocationStreamResponse()

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[EndpointLocationRequest, EndpointLocationResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[EndpointLocationStreamRequest, EndpointLocationStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[EndpointLocationStreamRequest, EndpointLocationStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.endpointlocation.v1.EndpointLocationService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                EndpointLocationRequest,
                EndpointLocationResponse,
            ),
            "/arista.endpointlocation.v1.EndpointLocationService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                EndpointLocationStreamRequest,
                EndpointLocationStreamResponse,
            ),
            "/arista.endpointlocation.v1.EndpointLocationService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                EndpointLocationStreamRequest,
                EndpointLocationStreamResponse,
            ),
        }
