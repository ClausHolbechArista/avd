# Copyright (c) 2023 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: arista/alert.v1/alert.proto, arista/alert.v1/services.gen.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from .... import fmp as ___fmp__
from ... import (
    subscriptions as __subscriptions__,
    time as __time__,
)


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class ConfigErrorType(betterproto.Enum):
    """ConfigErrorType describes the set of possible config error types"""

    CONFIG_ERROR_TYPE_UNSPECIFIED = 0
    """CONFIG_ERROR_TYPE_UNSPECIFIED is the unspecified enum value"""

    CONFIG_ERROR_TYPE_INVALID_FORMAT = 2
    """
    CONFIG_ERROR_TYPE_INVALID_FORMAT is caused by invalid format for value (eg:
    url)
    """

    CONFIG_ERROR_TYPE_INVALID_SYNTAX = 3
    """
    CONFIG_ERROR_TYPE_INVALID_SYNTAX is caused by invalid syntax for value (eg:
    regex)
    """

    CONFIG_ERROR_TYPE_TEMPLATE_INVALID = 4
    """
    CONFIG_ERROR_TYPE_TEMPLATE_INVALID is caused by failure to parse a template
    """

    CONFIG_ERROR_TYPE_ILLEGAL_VALUE = 5
    """
    CONFIG_ERROR_TYPE_ILLEGAL_VALUE is caused by a value outside of its bounds
    """

    CONFIG_ERROR_TYPE_MISSING_REQUIRED = 6
    """
    CONFIG_ERROR_TYPE_MISSING_REQUIRED is caused by a missing required
    attribute
    """

    CONFIG_ERROR_TYPE_INVALID_TYPE = 7
    """
    CONFIG_ERROR_TYPE_INVALID_TYPE is caused by the wrong type found in backing
    store
    """


class EndpointErrorType(betterproto.Enum):
    """EndpointErrorType describe the set of possible endpoint types"""

    ENDPOINT_ERROR_TYPE_UNSPECIFIED = 0
    """ENDPOINT_ERROR_TYPE_UNSPECIFIED is the unspecified enum value"""

    ENDPOINT_ERROR_TYPE_HTTP_POST_ERROR = 1
    """
    ENDPOINT_ERROR_TYPE_HTTP_POST_ERROR an error in sending HTTP request or
    reading a HTTP response
    """

    ENDPOINT_ERROR_TYPE_JSON_MARSHAL_ERROR = 2
    """
    ENDPOINT_ERROR_TYPE_JSON_MARSHAL_ERROR is caused by errors while encoding
    json
    """

    ENDPOINT_ERROR_TYPE_INVALID_CONFIG_ERROR = 3
    """
    ENDPOINT_ERROR_TYPE_INVALID_CONFIG_ERROR is an error caused by invalid
    config (missing, bad format, etc)
    """

    ENDPOINT_ERROR_TYPE_TEMPLATE_ERROR = 4
    """
    ENDPOINT_ERROR_TYPE_TEMPLATE_ERROR is caused by errors while executing
    templates
    """

    ENDPOINT_ERROR_TYPE_BAD_RESPONSE_ERROR = 5
    """
    ENDPOINT_ERROR_TYPE_BAD_RESPONSE_ERROR is caused by receiving a negative
    response from an endpoint indicating that the alert was not sent
    """

    ENDPOINT_ERROR_TYPE_SMTP_ERROR = 6
    """ENDPOINT_ERROR_TYPE_SMTP_ERROR is caused by errors with SMTP"""

    ENDPOINT_ERROR_TYPE_CONNECTION_ERROR = 7
    """
    ENDPOINT_ERROR_TYPE_CONNECTION_ERROR is caused by errors with a connection
    """

    ENDPOINT_ERROR_TYPE_TIMEOUT_ERROR = 8
    """
    ENDPOINT_ERROR_TYPE_TIMEOUT_ERROR is caused by errors with a connection
    """

    ENDPOINT_ERROR_TYPE_RATE_LIMIT_ERROR = 9
    """
    ENDPOINT_ERROR_TYPE_RATE_LIMIT_ERROR is caused by an Alerter rate limit
    being exceeded
    """

    ENDPOINT_ERROR_TYPE_ALERT_CAP_ERROR = 10
    """
    ENDPOINT_ERROR_TYPE_ALERT_CAP_ERROR is caused by the number of alerts sent
    to a sender exceeding the built-in limit
    """

    ENDPOINT_ERROR_TYPE_O_AUTH_ERROR = 11
    """
    ENDPOINT_ERROR_TYPE_O_AUTH_ERROR is caused when we failed authenticating
    using the OAuth apis
    """


class CueSyslogMessageFormat(betterproto.Enum):
    """CueSyslogMessageFormat is the message format for cue syslog messages"""

    CUE_SYSLOG_MESSAGE_FORMAT_UNSPECIFIED = 0
    """CUE_SYSLOG_MESSAGE_FORMAT_UNSPECIFIED is the unspecified enum value"""

    CUE_SYSLOG_MESSAGE_FORMAT_PLAIN = 1
    """
    CUE_SYSLOG_MESSAGE_FORMAT_PLAIN format uses the text format for
    constructing the syslog message
    """

    CUE_SYSLOG_MESSAGE_FORMAT_IDMEF = 2
    """
    CUE_SYSLOG_MESSAGE_FORMAT_IDMEF uses IDMEF message format as described
    here: https://datatracker.ietf.org/doc/html/rfc4765
    """


class SnmpSecurityLevel(betterproto.Enum):
    """SNMPSecurityLevel indicates what level of security should be used"""

    SNMP_SECURITY_LEVEL_UNSPECIFIED = 0
    """SNMP_SECURITY_LEVEL_UNSPECIFIED is the unspecified enum value"""

    SNMP_SECURITY_LEVEL_NO_AUTH_NO_PRIV = 1
    """SNMP_SECURITY_LEVEL_NO_AUTH_NO_PRIV use no security"""

    SNMP_SECURITY_LEVEL_AUTH_NO_PRIV = 2
    """SNMP_SECURITY_LEVEL_AUTH_NO_PRIV use authentication without privacy"""

    SNMP_SECURITY_LEVEL_AUTH_PRIV = 3
    """SNMP_SECURITY_LEVEL_AUTH_PRIV use both authentication and privacy"""


class SnmpAuthProtocol(betterproto.Enum):
    """SNMPAuthProtocol represents the authentication protocol to be used"""

    SNMP_AUTH_PROTOCOL_UNSPECIFIED = 0
    """SNMP_AUTH_PROTOCOL_UNSPECIFIED is the unspecified enum value"""

    SNMP_AUTH_PROTOCOL_MD5 = 1
    """SNMP_AUTH_PROTOCOL_MD5 use the md5 protocol"""

    SNMP_AUTH_PROTOCOL_SHA = 2
    """SNMP_AUTH_PROTOCOL_SHA use the sha protocol"""

    SNMP_AUTH_PROTOCOL_SHA_224 = 3
    """SNMP_AUTH_PROTOCOL_SHA_224 use the sha224 protocol"""

    SNMP_AUTH_PROTOCOL_SHA_256 = 4
    """SNMP_AUTH_PROTOCOL_SHA_256 use the sha256 protocol"""

    SNMP_AUTH_PROTOCOL_SHA_384 = 5
    """SNMP_AUTH_PROTOCOL_SHA_384 use the sha384 protocol"""

    SNMP_AUTH_PROTOCOL_SHA_512 = 6
    """SNMP_AUTH_PROTOCOL_SHA_512 use the sha512 protocol"""


class SnmpPrivProtocol(betterproto.Enum):
    """SNMPPrivProtocol represents the privacy protocol to be used"""

    SNMP_PRIV_PROTOCOL_UNSPECIFIED = 0
    """SNMP_PRIV_PROTOCOL_UNSPECIFIED is the unspecified enum value"""

    SNMP_PRIV_PROTOCOL_DES = 1
    """SNMP_PRIV_PROTOCOL_DES use the des protocol"""

    SNMP_PRIV_PROTOCOL_AES = 2
    """SNMP_PRIV_PROTOCOL_AES use the aes protocol"""

    SNMP_PRIV_PROTOCOL_AES_192 = 3
    """SNMP_PRIV_PROTOCOL_AES_192 use the aes192 protocol"""

    SNMP_PRIV_PROTOCOL_AES_256 = 4
    """SNMP_PRIV_PROTOCOL_AES_256 use the aes256 protocol"""

    SNMP_PRIV_PROTOCOL_AES_192C = 5
    """SNMP_PRIV_PROTOCOL_AES_192C use the aes192c protocol"""

    SNMP_PRIV_PROTOCOL_AES_256C = 6
    """SNMP_PRIV_PROTOCOL_AES_256C use the aes256c protocol"""


class CueSnmpAuthProtocol(betterproto.Enum):
    """
    CueSNMPAuthProtocol represents the authentication protocol to be used
    """

    CUE_SNMP_AUTH_PROTOCOL_UNSPECIFIED = 0
    """CUE_SNMP_AUTH_PROTOCOL_UNSPECIFIED is the unspecified enum value"""

    CUE_SNMP_AUTH_PROTOCOL_MD5 = 1
    """CUE_SNMP_AUTH_PROTOCOL_MD5 use the md5 protocol"""

    CUE_SNMP_AUTH_PROTOCOL_SHA = 2
    """CUE_SNMP_AUTH_PROTOCOL_SHA use the sha protocol"""


class CueSnmpPrivProtocol(betterproto.Enum):
    """CueSNMPPrivProtocol represents the privacy protocol to be used"""

    CUE_SNMP_PRIV_PROTOCOL_UNSPECIFIED = 0
    """CUE_SNMP_PRIV_PROTOCOL_UNSPECIFIED is the unspecified enum value"""

    CUE_SNMP_PRIV_PROTOCOL_DES = 1
    """CUE_SNMP_PRIV_PROTOCOL_DES use the des protocol"""

    CUE_SNMP_PRIV_PROTOCOL_AES = 2
    """CUE_SNMP_PRIV_PROTOCOL_AES use the aes protocol"""


class TemplateType(betterproto.Enum):
    """TemplateType describes the types of Templates that are usable"""

    TEMPLATE_TYPE_UNSPECIFIED = 0
    """TEMPLATE_TYPE_UNSPECIFIED is the unspecified enum value"""

    TEMPLATE_TYPE_EMAIL_HTML = 1
    """
    TEMPLATE_TYPE_EMAIL_HTML is the key of the html template for sent emails
    """

    TEMPLATE_TYPE_EMAIL_TEXT = 2
    """
    TEMPLATE_TYPE_EMAIL_TEXT is the key of the text template for sent emails
    """

    TEMPLATE_TYPE_SLACK_MESSAGE = 3
    """
    TEMPLATE_TYPE_SLACK_MESSAGE is the key of the message template for sent
    slack messages
    """

    TEMPLATE_TYPE_PUSHOVER_MESSAGE = 4
    """
    TEMPLATE_TYPE_PUSHOVER_MESSAGE is the key of the message template for sent
    pushover messages
    """

    TEMPLATE_TYPE_PAGERDUTY_SUMMARY = 5
    """
    TEMPLATE_TYPE_PAGERDUTY_SUMMARY is the key of the summary template for sent
    pagerduty messages
    """

    TEMPLATE_TYPE_VICTOROPS_DISPLAY_NAME = 6
    """
    TEMPLATE_TYPE_VICTOROPS_DISPLAY_NAME is the key of the display name
    template for sent victorops messages
    """

    TEMPLATE_TYPE_VICTOROPS_STATE_MESSAGE = 7
    """
    TEMPLATE_TYPE_VICTOROPS_STATE_MESSAGE is the key of the state message
    template for sent victorops messages
    """

    TEMPLATE_TYPE_GOOGLE_CHAT_MESSAGE = 8
    """
    TEMPLATE_TYPE_GOOGLE_CHAT_MESSAGE is the key of the message template for
    sent Google chat messages
    """

    TEMPLATE_TYPE_MICROSOFT_TEAMS_MESSAGE = 9
    """
    TEMPLATE_TYPE_MICROSOFT_TEAMS_MESSAGE is the key of the message template
    for sent Microsoft teams messages
    """

    TEMPLATE_TYPE_EMAIL_SUBJECT = 10
    """
    TEMPLATE_TYPE_EMAIL_SUBJECT is the key of the subject line template of a
    sent email
    """

    TEMPLATE_TYPE_SYSLOG_MESSAGE = 11
    """
    TEMPLATE_TYPE_SYSLOG_MESSAGE is the key of the message template for a
    syslog message part
    """

    TEMPLATE_TYPE_OPSGENIE_MESSAGE = 12
    """
    TEMPLATE_TYPE_OPSGENIE_MESSAGE is the key of the message template for a
    opsgenie alert
    """

    TEMPLATE_TYPE_ZOOM_MESSAGE = 13
    """
    TEMPLATE_TYPE_ZOOM_MESSAGE is the key of the message template for sent Zoom
    messages
    """


@dataclass(eq=False, repr=False)
class AlertConfig(betterproto.Message):
    """AlertConfig is the configuration for sending alerts"""

    settings: "Settings" = betterproto.message_field(1)
    """
    settings is the global default settings for various endpoints used in
    broadcast groups. Can be overwritten in individual endpoint settings
    """

    rules: "Rules" = betterproto.message_field(2)
    """rules define how we route alerts to broadcast groups"""

    broadcast_groups: "BroadcastGroups" = betterproto.message_field(3)
    """broadcast_groups are groups of endpoints that alerts are sent to"""


@dataclass(eq=False, repr=False)
class Alert(betterproto.Message):
    """Alert is the current status of the alert system"""

    configuration_errors: "ConfigErrors" = betterproto.message_field(1)
    """
    configuration_errors contain any configuration errors reported by the
    backend
    """

    endpoint_errors: "EndpointErrors" = betterproto.message_field(2)
    """endpoint_errors contain any failed attempts to send alerts"""

    last_modified_at: datetime = betterproto.message_field(3)
    """
    last_modified_at is the time at which the configuration was last modified
    """

    last_modified_by: Optional[str] = betterproto.message_field(
        4, wraps=betterproto.TYPE_STRING
    )
    """last_modified_by is the user who last modified the configuration"""


@dataclass(eq=False, repr=False)
class ConfigErrors(betterproto.Message):
    """ConfigErrors is a list of configuration-related errors"""

    values: List["ConfigError"] = betterproto.message_field(1)
    """values is a list of errors"""


@dataclass(eq=False, repr=False)
class ConfigError(betterproto.Message):
    """
    ConfigError is an error caused by an invalid config being rejected by the
    backend
    """

    path: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    """
    path is the 'path' to the invalid config element, eg:
    path.userPathName.email_configs[1].to = the 'to' field of the second email
    config of the 'userPathName' broadcast_group
    """

    error_type: "ConfigErrorType" = betterproto.enum_field(2)
    """
    error_type is the type of error, this allows custom handling of different
    error types
    """

    error: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)
    """error is a user-friendly error message"""


@dataclass(eq=False, repr=False)
class EndpointErrors(betterproto.Message):
    """EndpointErrors is a set of errors related to sending of alerts"""

    values: List["EndpointError"] = betterproto.message_field(1)
    """values is the list of errors"""


@dataclass(eq=False, repr=False)
class EndpointError(betterproto.Message):
    """
    EndpointError is an error caused by a failure to send alert(s) for any
    reason
    """

    endpoint_type: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    """
    endpoint_type indicates the type of endpoint which failed, or unknown if
    not endpoint-specific (eg: slack, opsgenie)
    """

    broadcast_group_name: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """
    broadcast_group_name is the name of the broadcast group which was being
    used, empty string if not group specific
    """

    config_index: Optional[int] = betterproto.message_field(
        3, wraps=betterproto.TYPE_INT32
    )
    """
    config_index is the index of the config on the broadcast group or -1 if not
    applicable eg: if there are two email config in one broadcast group, then
    the indices for each are 0 and 1 note that these are done per type, so only
    counting email/slack/...
    """

    error_type: "EndpointErrorType" = betterproto.enum_field(4)
    """
    error_type is the type of error, this allows custom handling of different
    error types
    """

    error: Optional[str] = betterproto.message_field(5, wraps=betterproto.TYPE_STRING)
    """error is a user-friendly error message"""


@dataclass(eq=False, repr=False)
class Settings(betterproto.Message):
    """
    Settings portion of config, a list of default global settings used by
    broadcast groups
    """

    email: "EmailSettings" = betterproto.message_field(1)
    """email is the global default settings for email"""

    http: "HttpSettings" = betterproto.message_field(2)
    """http is the global default settings for http"""

    slack: "SlackSettings" = betterproto.message_field(3)
    """slack is the global default settings for slack"""

    victorops: "VictoropsSettings" = betterproto.message_field(4)
    """victorops is the global default settings for victorops"""

    pagerduty: "PagerdutySettings" = betterproto.message_field(5)
    """pagerduty is the global default settings for pagerduty"""

    opsgenie: "OpsgenieSettings" = betterproto.message_field(6)
    """opsgenie is the global default settings for opsgenie"""

    gchat: "GoogleChatSettings" = betterproto.message_field(7)
    """gchat is the global default settings for google chat"""

    msteams: "MsTeamsSettings" = betterproto.message_field(8)
    """msteams is the global default settings for ms teams"""

    inhibition: "InhibitionSettings" = betterproto.message_field(9)
    """
    inhibition defines the inhibition rules for alerts, allowing events of
    certain types to be suppressed while another event type is active
    """

    base_url: Optional[str] = betterproto.message_field(
        10, wraps=betterproto.TYPE_STRING
    )
    """
    base_url is the root address of your CloudVision app. Used to generate
    links in notifications.
    """

    timezone: Optional[str] = betterproto.message_field(
        11, wraps=betterproto.TYPE_STRING
    )
    """
    timezone is used for formatting event times in notifications. E.g. 'UTC',
    'US/Pacific'
    """

    syslog: "SyslogSettings" = betterproto.message_field(12)
    """syslog is the global default settings for syslog"""

    snmp: "SnmpSettings" = betterproto.message_field(13)
    """snmp is the global default settings for snmp"""

    sendgrid: "SendgridSettings" = betterproto.message_field(14)
    """sendgrid is the global default settings for sendgrid"""

    cue_syslog: "CueSyslogSettings" = betterproto.message_field(15)
    """cue_syslog is the global default settings for cue syslog"""

    cue_snmp: "CueSnmpSettings" = betterproto.message_field(16)
    """cue_snmp is the global default settings for cue snmp"""

    cue_sendgrid: "CueSendgridSettings" = betterproto.message_field(17)
    """cue_sendgrid is the global default settings for cue sendgrid"""

    hide_tags: Optional[bool] = betterproto.message_field(
        18, wraps=betterproto.TYPE_BOOL
    )
    """
    hide_tags is used to by the alerting system to omit tags and other
    "superfluous" values from the notifications that are sent out by the system
    """

    zoom: "ZoomSettings" = betterproto.message_field(19)
    """zoom is the global default settings for zoom"""


@dataclass(eq=False, repr=False)
class EmailSettings(betterproto.Message):
    """EmailSettings contain the settings for the sending of emails"""

    from_: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    """from is the email address to send from"""

    smarthost: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """smarthost is the hostname and port of the SMTP server"""

    auth_username: Optional[str] = betterproto.message_field(
        3, wraps=betterproto.TYPE_STRING
    )
    """
    auth_username the username to use when sending emails required for all auth
    methods
    """

    auth_password: Optional[str] = betterproto.message_field(
        4, wraps=betterproto.TYPE_STRING
    )
    """auth_password the password to use when sending emails"""

    require_tls: Optional[bool] = betterproto.message_field(
        5, wraps=betterproto.TYPE_BOOL
    )
    """require_tls always use TLS connections when sending emails"""

    single_alert_per_email: Optional[bool] = betterproto.message_field(
        6, wraps=betterproto.TYPE_BOOL
    )
    """
    single_alert_per_email configures the Alerter such that each alert
    generates a separate email notification, the email will only have a single
    notification, the format will also be different
    """

    azure_o_auth: "AzureOAuth" = betterproto.message_field(7)
    """
    azure_o_auth used for auth when using an Azure smtp server uses
    auth_username
    """


@dataclass(eq=False, repr=False)
class AzureOAuth(betterproto.Message):
    """
    AzureOAuth contains the settings for the sending of emails on Azure smtp
    server
    """

    client_id: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    """client_id of the Azure environment"""

    tenant_id: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """tenant_id of the Azure environment"""

    client_secret: Optional[str] = betterproto.message_field(
        3, wraps=betterproto.TYPE_STRING
    )
    """client_secret is a user generated secret key used for auth"""

    auth_uri: Optional[str] = betterproto.message_field(
        4, wraps=betterproto.TYPE_STRING
    )
    """auth_uri is the URI used for OAuth"""


@dataclass(eq=False, repr=False)
class HttpSettings(betterproto.Message):
    """
    HttpSettings are the settings to be used when sending various message over
    a http connection
    """

    username: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    """username is the username to use when connecting to the http proxy"""

    password: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """password is the password to use when connecting to the http proxy"""

    proxy_url: Optional[str] = betterproto.message_field(
        3, wraps=betterproto.TYPE_STRING
    )
    """proxy_url is the url for the http proxy"""

    custom_headers: "HttpHeaders" = betterproto.message_field(4)
    """
    custom_headers is custom http headers to be used along with the default
    headers
    """


@dataclass(eq=False, repr=False)
class HttpHeaders(betterproto.Message):
    """HttpHeaders is a set of http headers"""

    values: Dict[str, "HeaderValues"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """values is a map of http header names to values"""


@dataclass(eq=False, repr=False)
class HeaderValues(betterproto.Message):
    """HeaderValues is a set of values for this header"""

    values: List[str] = betterproto.string_field(1)
    """values is the header values"""


@dataclass(eq=False, repr=False)
class SlackSettings(betterproto.Message):
    """SlackSettings contain the settings for sending alerts to slack"""

    url: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    """url is the url of the slack webhook to use"""


@dataclass(eq=False, repr=False)
class VictoropsSettings(betterproto.Message):
    """
    VictoropsSettings contain the settings for sending alerts to victorops
    """

    key: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    """key is the API key to use when talking to the VictorOps API"""

    url: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """
    url is the victorops url to use (without integration or routing key
    default: https://alert.victorops.com/integrations/generic/20131114/alert/
    """


@dataclass(eq=False, repr=False)
class PagerdutySettings(betterproto.Message):
    """
    PagerdutySettings contain the settings for sending alerts to pagerduty
    """

    url: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    """url is the url to use when sending alerts to pagerduty"""


@dataclass(eq=False, repr=False)
class OpsgenieSettings(betterproto.Message):
    """OpsgenieSettings contain the settings for sending alerts to opsgenie"""

    key: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    """key is the API key to use when talking to the OpsGenie API"""

    url: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """url is the url to use when sending alerts to opsgenie"""


@dataclass(eq=False, repr=False)
class GoogleChatSettings(betterproto.Message):
    """
    GoogleChatSettings contain the settings for sending alerts to google chat
    """

    url: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    """url is the url of the webhook to send alerts to"""


@dataclass(eq=False, repr=False)
class MsTeamsSettings(betterproto.Message):
    """MsTeamsSettings contain the settings for sending alerts to MS Teams"""

    url: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    """url is the url of the webhook to send alerts to"""


@dataclass(eq=False, repr=False)
class SyslogSettings(betterproto.Message):
    """SyslogSettings contain the settings for sending alerts with syslog"""

    network: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    """
    network is the network protocol to use, default is "udp", options also
    include: tcp,tcp4,tcp6,udp4,udp6
    """

    address: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """address is the network address to send syslog messages to"""

    facility: Optional[int] = betterproto.message_field(3, wraps=betterproto.TYPE_INT32)
    """
    facility is the syslog facility 0-23 inc. This is the syslog facility as
    defined in RFC-3164
    """

    priorities: "Priorities" = betterproto.message_field(4)
    """
    priorities describes how CVP severity maps to syslog priority priority is a
    number between 0-7 inc. as defined in RFC-3164
    """

    tag: Optional[str] = betterproto.message_field(5, wraps=betterproto.TYPE_STRING)
    """
    tag is the syslog TAG as described in RFC-3164, it is the prefix to all
    syslog messages
    """

    per_device: Optional[bool] = betterproto.message_field(
        6, wraps=betterproto.TYPE_BOOL
    )
    """
    per_device allows message to optionally be sent per device, if an event
    concerns two devices the behaviour is changed based on this option:   true:
    two messages are sent, one for each device   false: a single message is
    sent
    """

    use_tls: Optional[bool] = betterproto.message_field(7, wraps=betterproto.TYPE_BOOL)
    """
    use_tls determines if the connection to the server should be secured with
    TLS
    """


@dataclass(eq=False, repr=False)
class Priorities(betterproto.Message):
    """Priorities is a mapping of CV event severities to syslog severities"""

    critical: Optional[int] = betterproto.message_field(1, wraps=betterproto.TYPE_INT32)
    """critical priority, default = 2 (Critical)"""

    error: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_INT32)
    """error priority, default = 3 (Error)"""

    warn: Optional[int] = betterproto.message_field(3, wraps=betterproto.TYPE_INT32)
    """warn priority, default = 4 (Warning)"""

    info: Optional[int] = betterproto.message_field(4, wraps=betterproto.TYPE_INT32)
    """info priority, default = 6 (Informational)"""


@dataclass(eq=False, repr=False)
class CueData(betterproto.Message):
    """CueData contains additional cue-specific data"""

    values: Dict[str, str] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    """
    values can contain some additional data which is required by the cue
    specific provider
    """


@dataclass(eq=False, repr=False)
class CueSyslogSettings(betterproto.Message):
    """
    CueSyslogSettings contain the settings for sending alerts with syslog for
    cue
    """

    network: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    """
    network is the network protocol to use, default is "udp", options also
    include: tcp,tcp4,tcp6,udp4,udp6
    """

    address: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """address is the ip address to send syslog messages to"""

    port: Optional[int] = betterproto.message_field(3, wraps=betterproto.TYPE_INT32)
    """port is server's port to connect to"""

    message_format: "CueSyslogMessageFormat" = betterproto.enum_field(4)
    """message_format defines the message format to use"""

    append_bom_header: Optional[bool] = betterproto.message_field(
        5, wraps=betterproto.TYPE_BOOL
    )
    """
    append_bom_header if true a BOM( Byte Order Mark ) will be appended to the
    outgoing message BOM will tell the server that is receiving the messages,
    that the format is UTF8.
    """

    data: "CueData" = betterproto.message_field(6)
    """
    data is additional data that maybe required for constructing the message or
    sending it
    """


@dataclass(eq=False, repr=False)
class SnmpSettings(betterproto.Message):
    """SNMPSettings contain the settings for sending alerts with SNMP"""

    target: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    """target is an ipv4 address to send messages to"""

    port: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_INT32)
    """port is the network port to target"""

    transport: Optional[str] = betterproto.message_field(
        3, wraps=betterproto.TYPE_STRING
    )
    """
    transport is the transport protocol to use ("udp" or "tcp"); if unset "udp"
    will be used
    """

    version: Optional[int] = betterproto.message_field(4, wraps=betterproto.TYPE_INT32)
    """
    version is the SNMP version, v1, v2c and v3 are supported and can be set
    with 1, 2 and 3 respectively
    """

    auth: "SnmpAuth" = betterproto.message_field(5)
    """auth is optional authentication settings"""


@dataclass(eq=False, repr=False)
class SnmpAuth(betterproto.Message):
    """SNMPAuth contain authentication information for SNMP"""

    community: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    """
    community is the community string used for authentication in SNMPv1 and v2c
    required if version < 3
    """

    username: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """username the username for SNMPv3 auth"""

    security_level: "SnmpSecurityLevel" = betterproto.enum_field(3)
    """security_level the security level for SNMPv3"""

    authentication_protocol: "SnmpAuthProtocol" = betterproto.enum_field(4)
    """
    authentication_protocol is the protocol to use for authentication in SNMPv3
    required for AUTH_NO_PRIV/AUTH_PRIV security levels
    """

    authentication_passphrase: Optional[str] = betterproto.message_field(
        5, wraps=betterproto.TYPE_STRING
    )
    """
    authentication_passphrase is the passphrase to use for authentication in
    SNMPv3 required for AUTH_NO_PRIV/AUTH_PRIV security levels
    """

    privacy_protocol: "SnmpPrivProtocol" = betterproto.enum_field(6)
    """
    privacy_protocol is the protocol to use for privacy in SNMPv3 required for
    AUTH_PRIV security level
    """

    privacy_passphrase: Optional[str] = betterproto.message_field(
        7, wraps=betterproto.TYPE_STRING
    )
    """
    privacy_passphrase is the passphrase to use for privacy in SNMPv3 required
    for AUTH_PRIV security level
    """


@dataclass(eq=False, repr=False)
class CueSnmpAuth(betterproto.Message):
    """CueSNMPAuth is the authentication"""

    community: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    """
    community is the community string used for authentication in SNMPv1 and v2c
    required if version < 3
    """

    username: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """username the username for SNMPv3 auth"""

    security_level: "SnmpSecurityLevel" = betterproto.enum_field(3)
    """security_level the security level for SNMPv3"""

    authentication_protocol: "CueSnmpAuthProtocol" = betterproto.enum_field(4)
    """
    authentication_protocol is the protocol to use for authentication in SNMPv3
    required for AUTH_NO_PRIV/AUTH_PRIV security levels
    """

    authentication_passphrase: Optional[str] = betterproto.message_field(
        5, wraps=betterproto.TYPE_STRING
    )
    """
    authentication_passphrase is the passphrase to use for authentication in
    SNMPv3 required for AUTH_NO_PRIV/AUTH_PRIV security levels
    """

    privacy_protocol: "CueSnmpPrivProtocol" = betterproto.enum_field(6)
    """
    privacy_protocol is the protocol to use for privacy in SNMPv3 required for
    AUTH_PRIV security level
    """

    privacy_passphrase: Optional[str] = betterproto.message_field(
        7, wraps=betterproto.TYPE_STRING
    )
    """
    privacy_passphrase is the passphrase to use for privacy in SNMPv3 required
    for AUTH_PRIV security level
    """


@dataclass(eq=False, repr=False)
class CueSnmpSettings(betterproto.Message):
    """
    CueSNMPSettings contain the settings for sending cue alerts with SNMP
    """

    target: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    """target is an ipv4 address to send messages to"""

    port: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_INT32)
    """port is the network port to target"""

    transport: Optional[str] = betterproto.message_field(
        3, wraps=betterproto.TYPE_STRING
    )
    """
    transport is the transport protocol to use ("udp" or "tcp"); if unset "udp"
    will be used
    """

    version: Optional[int] = betterproto.message_field(4, wraps=betterproto.TYPE_INT32)
    """
    version is the SNMP version, v2c and v3 are supported and can be set with 2
    and 3 respectively
    """

    auth: "CueSnmpAuth" = betterproto.message_field(5)
    """auth is the optional authentication settings"""

    data: "CueData" = betterproto.message_field(6)
    """
    data is additional data that maybe required for constructing the message or
    sending it
    """


@dataclass(eq=False, repr=False)
class SendgridSettings(betterproto.Message):
    """
    SendgridSettings contain the settings for sending emails via sendgrid
    """

    api_key: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    """api_key is the api key to use"""

    from_: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """from is the email address to send from"""


@dataclass(eq=False, repr=False)
class CueSendgridSettings(betterproto.Message):
    """
    CueSendgridSettings contain the settings for sending cue alerts to sendgrid
    """

    api_key: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    """api_key is the key used to connect to the sendgrid APIs"""

    from_: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """from is the sender's address in the email sent"""


@dataclass(eq=False, repr=False)
class ZoomSettings(betterproto.Message):
    """ZoomSettings contain the settings for sending alerts to zoom"""

    url: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    """url is the zoom incoming webhook URL to send messages to"""

    verification_token: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """verification_token is the verification token to authenticate with"""


@dataclass(eq=False, repr=False)
class InhibitionSettings(betterproto.Message):
    """
    InhibitionSettings allows certain event types to be suppressed while other
    event types are active
    """

    values: Dict[str, "EventList"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """
    values is a map where the keys are event type which when active will
    suppress any events with event types in the related EventList
    """


@dataclass(eq=False, repr=False)
class EventList(betterproto.Message):
    """EventList is a list of event types"""

    event_types: "___fmp__.RepeatedString" = betterproto.message_field(1)
    """event_types contain the event types"""


@dataclass(eq=False, repr=False)
class Rules(betterproto.Message):
    """
    Rules is a list of rules which dictates which events generate alerts for
    which broadcast groups
    """

    values: List["Rule"] = betterproto.message_field(1)
    """values contains the rules"""


@dataclass(eq=False, repr=False)
class Rule(betterproto.Message):
    """Rule is a rule to send to a certain broadcast group"""

    sends_to: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    """
    sends_to is the name of the broadcast group top send matching alerts to
    """

    match_criteria: "Matches" = betterproto.message_field(2)
    """
    match_criteria is the criteria that an alert must match to be sent to the
    broadcast group
    """

    continue_checks: Optional[bool] = betterproto.message_field(
        3, wraps=betterproto.TYPE_BOOL
    )
    """
    continue_checks if true, causes alerts matching this rule's criteria to
    continue checking against other rules, allowing for additional matches. If
    false, alerts matching this rule will not proceed with checking
    """

    comment: Optional[str] = betterproto.message_field(4, wraps=betterproto.TYPE_STRING)
    """comment is a comment to include that will be displayed in the alert"""


@dataclass(eq=False, repr=False)
class Matches(betterproto.Message):
    """
    Matches is a set of restrictions that must be satisfied for a rule to be
    matched Empty fields are ignored for matching purposes. Condition contents
    are OR'd and then AND'd with the other criteria
    """

    severities: "___fmp__.RepeatedString" = betterproto.message_field(1)
    """
    severities is a list of severities to filter on, if an event does not have
    one of these severities, it will not match Valid values are INFO, WARNING,
    ERROR and CRITICAL
    """

    devices: "___fmp__.RepeatedString" = betterproto.message_field(2)
    """
    devices is a list of device IDs to filter on, if an event does not belong
    to one of these devices, it will not match
    """

    event_types: "___fmp__.RepeatedString" = betterproto.message_field(3)
    """
    event_types is a list of event types to filter on, if an event does not
    have one of these event types, it will not match
    """

    device_tags: Optional[str] = betterproto.message_field(
        4, wraps=betterproto.TYPE_STRING
    )
    """
    device_tags is a string tag query that is used to match on the event's
    device tags
    """

    intf_tags: Optional[str] = betterproto.message_field(
        5, wraps=betterproto.TYPE_STRING
    )
    """
    intf_tags is a string tag query that is used to match on the event's
    interface tags
    """

    rule_ids: "___fmp__.RepeatedString" = betterproto.message_field(6)
    """
    rule_ids is a list of rule IDs to filter on, if an event does not have one
    of these rule IDs, it will not match
    """


@dataclass(eq=False, repr=False)
class BroadcastGroups(betterproto.Message):
    """BroadcastGroups is a collection of named broadcast groups"""

    values: Dict[str, "BroadcastGroup"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """
    values is a map of user defined ids to broadcast groups. No restrictions to
    naming applies
    """


@dataclass(eq=False, repr=False)
class BroadcastGroup(betterproto.Message):
    """
    BroadcastGroup is a series of endpoints that alerts are sent to if routed
    there by a rule No restriction on the number of types of endpoints that can
    be defined
    """

    email: "EmailEndpoints" = betterproto.message_field(1)
    """
    email is a set of email endpoints to send alerts to as part of this group
    """

    webhook: "WebhookEndpoints" = betterproto.message_field(2)
    """
    webhook is a set of webhook endpoints to send alerts to as part of this
    group
    """

    slack: "SlackEndpoints" = betterproto.message_field(3)
    """
    slack is a set of slack endpoints to send alerts to as part of this group
    """

    opsgenie: "OpsgenieEndpoints" = betterproto.message_field(4)
    """
    opsgenie is a set of opsgenie endpoints to send alerts to as part of this
    group
    """

    pushover: "PushoverEndpoints" = betterproto.message_field(5)
    """
    pushover is a set of pushover endpoints to send alerts to as part of this
    group
    """

    pagerduty: "PagerdutyEndpoints" = betterproto.message_field(6)
    """
    pagerduty is a set of pagerduty endpoints to send alerts to as part of this
    group
    """

    victorops: "VictorOpsEndpoints" = betterproto.message_field(7)
    """
    victorops is a set of victorops endpoints to send alerts to as part of this
    group
    """

    gchat: "GoogleChatEndpoints" = betterproto.message_field(8)
    """
    gchat is a set of google chat endpoints to send alerts to as part of this
    group
    """

    msteams: "MsTeamsEndpoints" = betterproto.message_field(9)
    """
    msteams is a set of MS teams endpoints to send alerts to as part of this
    group
    """

    sendgrid: "SendgridEndpoints" = betterproto.message_field(10)
    """
    sendgrid is a set of sendgrid endpoints to send alerts to as part of this
    group
    """

    syslog: "SyslogEndpoints" = betterproto.message_field(11)
    """
    syslog is a set of syslog endpoints to send alerts to as part of this group
    """

    snmp: "SnmpEndpoints" = betterproto.message_field(12)
    """
    snmp is a set of snmp endpoints to send alerts to as part of this group
    """

    cue_syslog: "CueSyslogEndpoints" = betterproto.message_field(13)
    """
    cue_syslog is a set of cue syslog endpoints to send alerts to as part of
    this group
    """

    cue_snmp: "CueSnmpEndpoints" = betterproto.message_field(14)
    """
    cue_snmp is a set of cue snmp endpoints to send alerts to as part of this
    group
    """

    cue_sendgrid: "CueSendgridEndpoints" = betterproto.message_field(15)
    """
    cue_sendgrid is a set of cue sendgrid endpoints to send alerts to as part
    of this group
    """

    zoom: "ZoomEndpoints" = betterproto.message_field(16)
    """
    zoom is a set of zoom endpoints to send alerts to as part of this group
    """


@dataclass(eq=False, repr=False)
class EmailEndpoints(betterproto.Message):
    """EmailEndpoints is a set of email endpoints"""

    values: List["EmailEndpoint"] = betterproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class WebhookEndpoints(betterproto.Message):
    """WebhookEndpoints is a set of webhook endpoints"""

    values: List["WebhookEndpoint"] = betterproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class SlackEndpoints(betterproto.Message):
    """SlackEndpoints is a set of slack endpoints"""

    values: List["SlackEndpoint"] = betterproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class OpsgenieEndpoints(betterproto.Message):
    """OpsgenieEndpoints is a set of opsgenie endpoints"""

    values: List["OpsgenieEndpoint"] = betterproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class PushoverEndpoints(betterproto.Message):
    """PushoverEndpoints is a set of pushover endpoints"""

    values: List["PushoverEndpoint"] = betterproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class PagerdutyEndpoints(betterproto.Message):
    """PagerdutyEndpoints is a set of pagerduty endpoints"""

    values: List["PagerdutyEndpoint"] = betterproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class VictorOpsEndpoints(betterproto.Message):
    """VictorOpsEndpoints is a set of victorOps endpoints"""

    values: List["VictorOpsEndpoint"] = betterproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class GoogleChatEndpoints(betterproto.Message):
    """GoogleChatEndpoints is a set of googleChat endpoints"""

    values: List["GoogleChatEndpoint"] = betterproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class MsTeamsEndpoints(betterproto.Message):
    """MsTeamsEndpoints is a set of ms teams endpoints"""

    values: List["MsTeamsEndpoint"] = betterproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class SendgridEndpoints(betterproto.Message):
    """SendgridEndpoints is a set of sendgrid endpoints"""

    values: List["SendgridEndpoint"] = betterproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class CueSendgridEndpoints(betterproto.Message):
    """CueSendgridEndpoints is a set of cue sendgrid endpoints"""

    values: List["CueSendgridEndpoint"] = betterproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class SyslogEndpoints(betterproto.Message):
    """SyslogEndpoints is a set of syslog endpoints"""

    values: List["SyslogEndpoint"] = betterproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class CueSyslogEndpoints(betterproto.Message):
    """CueSyslogEndpoints is a set of cue syslog endpoints"""

    values: List["CueSyslogEndpoint"] = betterproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class SnmpEndpoints(betterproto.Message):
    """SNMPEndpoints is a set of SNMP endpoints"""

    values: List["SnmpEndpoint"] = betterproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class CueSnmpEndpoints(betterproto.Message):
    """CueSnmpEndpoints is a set of cue SNMP endpoints"""

    values: List["CueSnmpEndpoint"] = betterproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class ZoomEndpoints(betterproto.Message):
    """ZoomEndpoints is a set of zoom endpoints"""

    values: List["ZoomEndpoint"] = betterproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class EmailEndpoint(betterproto.Message):
    """
    EmailEndpoint contains the required information for an alert to be sent to
    an email endpoint
    """

    send_resolved: Optional[bool] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are
    triggered
    """

    to: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """to address to send email to"""


@dataclass(eq=False, repr=False)
class WebhookEndpoint(betterproto.Message):
    """
    WebhookEndpoint contains the required information for an alert to be sent
    to a webhook endpoint
    """

    send_resolved: Optional[bool] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are
    triggered
    """

    url: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """url is the url"""

    http_override: "HttpSettings" = betterproto.message_field(3)
    """http_override is the override of the global http settings"""

    simple_output: Optional[bool] = betterproto.message_field(
        4, wraps=betterproto.TYPE_BOOL
    )
    """
    simple_output is a boolean flag to control the JSON structure of the
    webhook body. When false the output mimics the old alertmanager format.
    When true the output is a simple array of json objects which each represent
    an event.
    """

    single_alert: Optional[bool] = betterproto.message_field(
        5, wraps=betterproto.TYPE_BOOL
    )
    """
    single_alert is a boolean flag that will cause an individual webhook
    message to be sent per alert when true.
    """


@dataclass(eq=False, repr=False)
class SlackEndpoint(betterproto.Message):
    """
    SlackEndpoint contains the required information for an alert to be sent to
    a slack endpoint
    """

    send_resolved: Optional[bool] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are
    triggered
    """

    http_override: "HttpSettings" = betterproto.message_field(2)
    """http_override is the override of the global http settings"""

    settings_override: "SlackSettings" = betterproto.message_field(3)
    """
    settings_override is the override for the slack global endpoint settings
    """


@dataclass(eq=False, repr=False)
class OpsgenieEndpoint(betterproto.Message):
    """
    OpsgenieEndpoint contains the required information for an alert to be sent
    to an opsgenie endpoint
    """

    send_resolved: Optional[bool] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are
    triggered
    """

    http_override: "HttpSettings" = betterproto.message_field(2)
    """http_override is the override of the global http settings"""

    settings_override: "OpsgenieSettings" = betterproto.message_field(3)
    """
    settings_override is the override for the opsgenie global endpoint settings
    """


@dataclass(eq=False, repr=False)
class PushoverEndpoint(betterproto.Message):
    """
    PushoverEndpoint contains the required information for an alert to be sent
    to a pushover endpoint
    """

    send_resolved: Optional[bool] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are
    triggered
    """

    token: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """
    token is the user's registered application's API token, see
    https://pushover.net/apps
    """

    user_key: Optional[str] = betterproto.message_field(
        3, wraps=betterproto.TYPE_STRING
    )
    """user_key is the user's user key"""

    http_override: "HttpSettings" = betterproto.message_field(4)
    """http_override is the override of the global http settings"""


@dataclass(eq=False, repr=False)
class PagerdutyEndpoint(betterproto.Message):
    """
    PagerdutyEndpoint contains the required information for an alert to be sent
    to a pagerduty endpoint
    """

    send_resolved: Optional[bool] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are
    triggered
    """

    routing_key: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """routing_key is the routing key for sending pagerduty alerts"""

    http_override: "HttpSettings" = betterproto.message_field(3)
    """http_override is the override of the global http settings"""

    settings_override: "PagerdutySettings" = betterproto.message_field(4)
    """
    settings_override is the override for the pagerduty global endpoint
    settings
    """


@dataclass(eq=False, repr=False)
class VictorOpsEndpoint(betterproto.Message):
    """
    VictorOpsEndpoint contains the required information for an alert to be sent
    to a victorOps endpoint
    """

    send_resolved: Optional[bool] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are
    triggered
    """

    routing_key: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """routing_key is the PagerDuty integration key"""

    http_override: "HttpSettings" = betterproto.message_field(3)
    """http_override is the override of the global http settings"""

    settings_override: "VictoropsSettings" = betterproto.message_field(4)
    """
    settings_override is the override for the victorops global endpoint
    settings
    """


@dataclass(eq=False, repr=False)
class GoogleChatEndpoint(betterproto.Message):
    """
    GoogleChatEndpoint contains the required information for an alert to be
    sent to a google chat endpoint
    """

    send_resolved: Optional[bool] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are
    triggered
    """

    http_override: "HttpSettings" = betterproto.message_field(2)
    """http_override is the override of the global http settings"""

    settings_override: "GoogleChatSettings" = betterproto.message_field(3)
    """
    settings_override is the override for the google chat global endpoint
    settings
    """


@dataclass(eq=False, repr=False)
class MsTeamsEndpoint(betterproto.Message):
    """
    MsTeamsEndpoint contains the required information for an alert to be sent
    to an ms teams endpoint
    """

    send_resolved: Optional[bool] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are
    triggered
    """

    http_override: "HttpSettings" = betterproto.message_field(2)
    """http_override is the override of the global http settings"""

    settings_override: "MsTeamsSettings" = betterproto.message_field(3)
    """
    settings_override is the override for the microsoft teams global endpoint
    settings
    """


@dataclass(eq=False, repr=False)
class SendgridEndpoint(betterproto.Message):
    """
    SendgridEndpoint contains the required information for an alert to be sent
    to a sendgrid endpoint
    """

    send_resolved: Optional[bool] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are
    triggered
    """

    to: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """to address to send email to"""

    http_override: "HttpSettings" = betterproto.message_field(3)
    """http_override is the override of the global http settings"""


@dataclass(eq=False, repr=False)
class CueSendgridEndpoint(betterproto.Message):
    """
    CueSendgridEndpoint contains the required information for an alert to be
    sent to a cue sendgrid endpoint
    """

    send_resolved: Optional[bool] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are
    triggered
    """

    to: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """to address to send email to"""

    http_override: "HttpSettings" = betterproto.message_field(3)
    """
    http_override is the override of the global http settings This overrides
    the value used in Settings message in the global alert config
    """


@dataclass(eq=False, repr=False)
class SyslogEndpoint(betterproto.Message):
    """
    SyslogEndpoint contains the required information for an alert to be sent to
    a syslog endpoint
    """

    send_resolved: Optional[bool] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are
    triggered
    """

    settings_override: "SyslogSettings" = betterproto.message_field(2)
    """
    settings_override is the override for the microsoft teams global endpoint
    settings
    """


@dataclass(eq=False, repr=False)
class CueSyslogEndpoint(betterproto.Message):
    """
    CueSyslogEndpoint contains the required information for an alert to be sent
    to a cue syslog endpoint
    """

    send_resolved: Optional[bool] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are
    triggered
    """

    settings_override: "CueSyslogSettings" = betterproto.message_field(2)
    """
    settings_override is the override for the cue syslog global endpoint
    settings
    """


@dataclass(eq=False, repr=False)
class SnmpEndpoint(betterproto.Message):
    """
    SNMPEndpoint contains the required information for an alert to be sent to
    an SNMP endpoint
    """

    send_resolved: Optional[bool] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are
    triggered
    """

    settings_override: "SnmpSettings" = betterproto.message_field(2)
    """
    settings_override is the override for the microsoft teams global endpoint
    settings
    """


@dataclass(eq=False, repr=False)
class CueSnmpEndpoint(betterproto.Message):
    """
    CueSNMPEndpoint contains the required information for an alert to be sent
    to a cue SNMP endpoint
    """

    send_resolved: Optional[bool] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are
    triggered
    """

    settings_override: "CueSnmpSettings" = betterproto.message_field(2)
    """
    settings_override is the override for the cue snmp global endpoint settings
    """


@dataclass(eq=False, repr=False)
class ZoomEndpoint(betterproto.Message):
    """
    ZoomEndpoint contains the required information for an alert to be sent to a
    zoom endpoint
    """

    send_resolved: Optional[bool] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are
    triggered
    """

    http_override: "HttpSettings" = betterproto.message_field(2)
    """http_override is the override of the global http settings"""

    settings_override: "ZoomSettings" = betterproto.message_field(3)
    """
    settings_override is the override for the zoom global endpoint settings
    """


@dataclass(eq=False, repr=False)
class TemplateKey(betterproto.Message):
    """TemplateKey is used to identify templates for event notifications"""

    template_type: "TemplateType" = betterproto.enum_field(1)
    """template_type is the enum value to match with the template"""


@dataclass(eq=False, repr=False)
class TemplateConfig(betterproto.Message):
    """TemplateConfig represents a template configuration"""

    key: "TemplateKey" = betterproto.message_field(1)
    """key identifies which template the configuration is for"""

    template: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """
    template is the string template value to be used Templates need to be
    compatible with their respective parsers Message templates are read and
    parsed by https://golang.org/pkg/text/template/ Html templates are read and
    parsed by https://golang.org/pkg/html/template/ Templates must output valid
    JSON for certain templates Templates must not fail for any valid input
    """


@dataclass(eq=False, repr=False)
class DefaultTemplate(betterproto.Message):
    """
    DefaultTemplate is the system default template which is used when no user
    template has been set
    """

    key: "TemplateKey" = betterproto.message_field(1)
    """key identifies which template the configuration is for"""

    template: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """
    template is the string template value to be used Templates need to be
    compatible with their respective parsers Message templates are read and
    parsed by https://golang.org/pkg/text/template/ Html templates are read and
    parsed by https://golang.org/pkg/html/template/ Templates must output valid
    JSON for certain templates Templates must not fail for any valid input
    """


@dataclass(eq=False, repr=False)
class AlertRequest(betterproto.Message):
    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class AlertResponse(betterproto.Message):
    value: "Alert" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the Alert
    instance in this response.
    """


@dataclass(eq=False, repr=False)
class AlertStreamRequest(betterproto.Message):
    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. For GetAll, the fields start and end can be used as follows:   *
    end: Returns the state of each Alert at end.     * Each Alert response is
    fully-specified (all fields set).   * start: Returns the state of each
    Alert at start, followed by updates until now.     * Each Alert response at
    start is fully-specified, but updates may be partial.   * start and end:
    Returns the state of each Alert at start, followed by updates     until
    end.     * Each Alert response at start is fully-specified, but updates
    until end may       be partial. This field is not allowed in the Subscribe
    RPC.
    """


@dataclass(eq=False, repr=False)
class AlertStreamResponse(betterproto.Message):
    value: "Alert" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """Time holds the timestamp of this Alert's last modification."""

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the Alert value in this response should be
    considered. Under non-subscribe requests, this value should always be
    INITIAL. In a subscription, once all initial data is streamed and the
    client begins to receive modification updates, you should not see INITIAL
    again.
    """


@dataclass(eq=False, repr=False)
class AlertConfigRequest(betterproto.Message):
    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class AlertConfigResponse(betterproto.Message):
    value: "AlertConfig" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    AlertConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class AlertConfigStreamRequest(betterproto.Message):
    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. For GetAll, the fields start and end can be used as follows:   *
    end: Returns the state of each AlertConfig at end.     * Each AlertConfig
    response is fully-specified (all fields set).   * start: Returns the state
    of each AlertConfig at start, followed by updates until now.     * Each
    AlertConfig response at start is fully-specified, but updates may be
    partial.   * start and end: Returns the state of each AlertConfig at start,
    followed by updates     until end.     * Each AlertConfig response at start
    is fully-specified, but updates until end may       be partial. This field
    is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class AlertConfigStreamResponse(betterproto.Message):
    value: "AlertConfig" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """Time holds the timestamp of this AlertConfig's last modification."""

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the AlertConfig value in this response should be
    considered. Under non-subscribe requests, this value should always be
    INITIAL. In a subscription, once all initial data is streamed and the
    client begins to receive modification updates, you should not see INITIAL
    again.
    """


@dataclass(eq=False, repr=False)
class AlertConfigSetRequest(betterproto.Message):
    value: "AlertConfig" = betterproto.message_field(1)
    """
    AlertConfig carries the value to set into the datastore. See the
    documentation on the AlertConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class AlertConfigSetResponse(betterproto.Message):
    value: "AlertConfig" = betterproto.message_field(1)
    """
    Value carries all the values given in the AlertConfigSetRequest as well as
    any server-generated values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    creation. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class TemplateConfigRequest(betterproto.Message):
    key: "TemplateKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a TemplateConfig instance to retrieve. This value
    must be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class TemplateConfigResponse(betterproto.Message):
    value: "TemplateConfig" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    TemplateConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class TemplateConfigStreamRequest(betterproto.Message):
    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. For GetAll, the fields start and end can be used as follows:   *
    end: Returns the state of each TemplateConfig at end.     * Each
    TemplateConfig response is fully-specified (all fields set).   * start:
    Returns the state of each TemplateConfig at start, followed by updates
    until now.     * Each TemplateConfig response at start is fully-specified,
    but updates may be partial.   * start and end: Returns the state of each
    TemplateConfig at start, followed by updates     until end.     * Each
    TemplateConfig response at start is fully-specified, but updates until end
    may       be partial. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class TemplateConfigStreamResponse(betterproto.Message):
    value: "TemplateConfig" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """Time holds the timestamp of this TemplateConfig's last modification."""

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the TemplateConfig value in this response should be
    considered. Under non-subscribe requests, this value should always be
    INITIAL. In a subscription, once all initial data is streamed and the
    client begins to receive modification updates, you should not see INITIAL
    again.
    """


@dataclass(eq=False, repr=False)
class TemplateConfigSetRequest(betterproto.Message):
    value: "TemplateConfig" = betterproto.message_field(1)
    """
    TemplateConfig carries the value to set into the datastore. See the
    documentation on the TemplateConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class TemplateConfigSetResponse(betterproto.Message):
    value: "TemplateConfig" = betterproto.message_field(1)
    """
    Value carries all the values given in the TemplateConfigSetRequest as well
    as any server-generated values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    creation. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class TemplateConfigSetSomeRequest(betterproto.Message):
    values: List["TemplateConfig"] = betterproto.message_field(1)
    """
    value contains a list of TemplateConfig values to write. It is possible to
    provide more values than can fit within either:     - the maxiumum send
    size of the client     - the maximum receive size of the server If this
    error occurs you must reduce the number of values sent. See gRPC "maximum
    message size" documentation for more information.
    """


@dataclass(eq=False, repr=False)
class TemplateConfigSetSomeResponse(betterproto.Message):
    key: "TemplateKey" = betterproto.message_field(1)
    error: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class TemplateConfigDeleteRequest(betterproto.Message):
    key: "TemplateKey" = betterproto.message_field(1)
    """
    Key indicates which TemplateConfig instance to remove. This field must
    always be set.
    """


@dataclass(eq=False, repr=False)
class TemplateConfigDeleteResponse(betterproto.Message):
    key: "TemplateKey" = betterproto.message_field(1)
    """Key echoes back the key of the deleted TemplateConfig instance."""

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    deletion. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class TemplateConfigDeleteAllRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class TemplateConfigDeleteAllResponse(betterproto.Message):
    type: "___fmp__.DeleteError" = betterproto.enum_field(1)
    """This describes the class of delete error."""

    error: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "TemplateKey" = betterproto.message_field(3)
    """
    This is the key of the TemplateConfig instance that failed to be deleted.
    """

    time: datetime = betterproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


class AlertServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        alert_request: "AlertRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AlertResponse":
        return await self._unary_unary(
            "/arista.alert.v1.AlertService/GetOne",
            alert_request,
            AlertResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe(
        self,
        alert_stream_request: "AlertStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["AlertStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.AlertService/Subscribe",
            alert_stream_request,
            AlertStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class AlertConfigServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        alert_config_request: "AlertConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AlertConfigResponse":
        return await self._unary_unary(
            "/arista.alert.v1.AlertConfigService/GetOne",
            alert_config_request,
            AlertConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe(
        self,
        alert_config_stream_request: "AlertConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["AlertConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.AlertConfigService/Subscribe",
            alert_config_stream_request,
            AlertConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        alert_config_set_request: "AlertConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AlertConfigSetResponse":
        return await self._unary_unary(
            "/arista.alert.v1.AlertConfigService/Set",
            alert_config_set_request,
            AlertConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class TemplateConfigServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        template_config_request: "TemplateConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "TemplateConfigResponse":
        return await self._unary_unary(
            "/arista.alert.v1.TemplateConfigService/GetOne",
            template_config_request,
            TemplateConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        template_config_stream_request: "TemplateConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TemplateConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.TemplateConfigService/GetAll",
            template_config_stream_request,
            TemplateConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        template_config_stream_request: "TemplateConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TemplateConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.TemplateConfigService/Subscribe",
            template_config_stream_request,
            TemplateConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        template_config_set_request: "TemplateConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "TemplateConfigSetResponse":
        return await self._unary_unary(
            "/arista.alert.v1.TemplateConfigService/Set",
            template_config_set_request,
            TemplateConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_some(
        self,
        template_config_set_some_request: "TemplateConfigSetSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TemplateConfigSetSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.TemplateConfigService/SetSome",
            template_config_set_some_request,
            TemplateConfigSetSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete(
        self,
        template_config_delete_request: "TemplateConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "TemplateConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.alert.v1.TemplateConfigService/Delete",
            template_config_delete_request,
            TemplateConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_all(
        self,
        template_config_delete_all_request: "TemplateConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TemplateConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.TemplateConfigService/DeleteAll",
            template_config_delete_all_request,
            TemplateConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class AlertServiceBase(ServiceBase):
    async def get_one(self, alert_request: "AlertRequest") -> "AlertResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, alert_stream_request: "AlertStreamRequest"
    ) -> AsyncIterator["AlertStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield AlertStreamResponse()

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[AlertRequest, AlertResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_subscribe(
        self, stream: "grpclib.server.Stream[AlertStreamRequest, AlertStreamResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.alert.v1.AlertService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                AlertRequest,
                AlertResponse,
            ),
            "/arista.alert.v1.AlertService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                AlertStreamRequest,
                AlertStreamResponse,
            ),
        }


class AlertConfigServiceBase(ServiceBase):
    async def get_one(
        self, alert_config_request: "AlertConfigRequest"
    ) -> "AlertConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, alert_config_stream_request: "AlertConfigStreamRequest"
    ) -> AsyncIterator["AlertConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield AlertConfigStreamResponse()

    async def set(
        self, alert_config_set_request: "AlertConfigSetRequest"
    ) -> "AlertConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[AlertConfigRequest, AlertConfigResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[AlertConfigStreamRequest, AlertConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[AlertConfigSetRequest, AlertConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.alert.v1.AlertConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                AlertConfigRequest,
                AlertConfigResponse,
            ),
            "/arista.alert.v1.AlertConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                AlertConfigStreamRequest,
                AlertConfigStreamResponse,
            ),
            "/arista.alert.v1.AlertConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                AlertConfigSetRequest,
                AlertConfigSetResponse,
            ),
        }


class TemplateConfigServiceBase(ServiceBase):
    async def get_one(
        self, template_config_request: "TemplateConfigRequest"
    ) -> "TemplateConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, template_config_stream_request: "TemplateConfigStreamRequest"
    ) -> AsyncIterator["TemplateConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield TemplateConfigStreamResponse()

    async def subscribe(
        self, template_config_stream_request: "TemplateConfigStreamRequest"
    ) -> AsyncIterator["TemplateConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield TemplateConfigStreamResponse()

    async def set(
        self, template_config_set_request: "TemplateConfigSetRequest"
    ) -> "TemplateConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_some(
        self, template_config_set_some_request: "TemplateConfigSetSomeRequest"
    ) -> AsyncIterator["TemplateConfigSetSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield TemplateConfigSetSomeResponse()

    async def delete(
        self, template_config_delete_request: "TemplateConfigDeleteRequest"
    ) -> "TemplateConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self, template_config_delete_all_request: "TemplateConfigDeleteAllRequest"
    ) -> AsyncIterator["TemplateConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield TemplateConfigDeleteAllResponse()

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[TemplateConfigRequest, TemplateConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[TemplateConfigStreamRequest, TemplateConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[TemplateConfigStreamRequest, TemplateConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[TemplateConfigSetRequest, TemplateConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_set_some(
        self,
        stream: "grpclib.server.Stream[TemplateConfigSetSomeRequest, TemplateConfigSetSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.set_some,
            stream,
            request,
        )

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[TemplateConfigDeleteRequest, TemplateConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[TemplateConfigDeleteAllRequest, TemplateConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.alert.v1.TemplateConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                TemplateConfigRequest,
                TemplateConfigResponse,
            ),
            "/arista.alert.v1.TemplateConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                TemplateConfigStreamRequest,
                TemplateConfigStreamResponse,
            ),
            "/arista.alert.v1.TemplateConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                TemplateConfigStreamRequest,
                TemplateConfigStreamResponse,
            ),
            "/arista.alert.v1.TemplateConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                TemplateConfigSetRequest,
                TemplateConfigSetResponse,
            ),
            "/arista.alert.v1.TemplateConfigService/SetSome": grpclib.const.Handler(
                self.__rpc_set_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                TemplateConfigSetSomeRequest,
                TemplateConfigSetSomeResponse,
            ),
            "/arista.alert.v1.TemplateConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                TemplateConfigDeleteRequest,
                TemplateConfigDeleteResponse,
            ),
            "/arista.alert.v1.TemplateConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                TemplateConfigDeleteAllRequest,
                TemplateConfigDeleteAllResponse,
            ),
        }
