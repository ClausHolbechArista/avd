# Copyright (c) 2023 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: arista/syslog.v1/services.gen.proto, arista/syslog.v1/syslog.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from .... import fmp as ___fmp__
from ... import (
    subscriptions as __subscriptions__,
    time as __time__,
)


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class TransportProtocol(betterproto.Enum):
    """
    TransportProtocol defines the set of transport protocols to be used for
    export.
    """

    TRANSPORT_PROTOCOL_UNSPECIFIED = 0
    TRANSPORT_PROTOCOL_UDP = 1
    """TRANSPORT_PROTOCOL_UDP indicates the User Datagram Protocol (UDP)."""


class Format(betterproto.Enum):
    """
    Format defines the set of formats to be used for export to syslog servers.
    """

    FORMAT_UNSPECIFIED = 0
    FORMAT_RFC3164 = 1
    """
    FORMAT_RFC3164 indicates the BSD syslog protocol as defined by RFC 3164.
    """

    FORMAT_RFC5424 = 2
    """
    FORMAT_RFC5424 indicates the IETF syslog protocol as defined by RFC 5424.
    """

    FORMAT_CUSTOM = 3
    """FORMAT_CUSTOM indicates a native custom format with a UTC timestamp."""


class ExportResult(betterproto.Enum):
    """
    ExportResult defines the set of possible results of an export operation.
    """

    EXPORT_RESULT_UNSPECIFIED = 0
    EXPORT_RESULT_SUCCESS = 1
    """EXPORT_RESULT_SUCCESS indicates a successful export operation."""

    EXPORT_RESULT_FAILURE = 2
    """EXPORT_RESULT_FAILURE indicates an unsuccessful export operation."""


@dataclass(eq=False, repr=False)
class ExportKey(betterproto.Message):
    """
    ExportKey uniquely identifies a syslog server to which to export logs.
    """

    hostname_or_ip: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    """hostname_or_ip is the IP address or hostname of the syslog server."""

    port_num: "___fmp__.Port" = betterproto.message_field(2)
    """port_num is the destination port number of the syslog server."""

    protocol: "TransportProtocol" = betterproto.enum_field(3)
    """protocol defines the transport protocol for the syslog export."""


@dataclass(eq=False, repr=False)
class ExportSuccess(betterproto.Message):
    """
    ExportSuccess provides the details of the last successful export operation.
    """

    timestamp: datetime = betterproto.message_field(1)
    """
    timestamp provides the timestamp of last successful export opeartion.
    """

    log_timestamp: datetime = betterproto.message_field(2)
    """
    log_timestamp provides the timestamp of the last successful audit log.
    """


@dataclass(eq=False, repr=False)
class ExportError(betterproto.Message):
    """ExportError provides the details of the most recent export error."""

    timestamp: datetime = betterproto.message_field(1)
    """timestamp provides the timestamp of the export error."""

    error: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """error indicates the export error."""

    detail: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)
    """detail indicates the audit log that was not exported."""

    log_timestamp: datetime = betterproto.message_field(4)
    """
    log_timestamp provides the timestamp of the last audit log that was not
    exported due to error.
    """


@dataclass(eq=False, repr=False)
class ExportStats(betterproto.Message):
    """
    ExportStats provide statistics of export operations to a syslog sever.
    """

    num_success: Optional[int] = betterproto.message_field(
        1, wraps=betterproto.TYPE_UINT64
    )
    """num_success indicates the count of successful exports."""

    num_errors: Optional[int] = betterproto.message_field(
        2, wraps=betterproto.TYPE_UINT64
    )
    """num_errors indicates the count of export errors."""

    last_result: "ExportResult" = betterproto.enum_field(3)
    """last_result provides the status of the last export operation."""


@dataclass(eq=False, repr=False)
class ExportConfig(betterproto.Message):
    """ExportConfig is used to configure a syslog server."""

    key: "ExportKey" = betterproto.message_field(1)
    """key uniquely identifies a syslog server."""


@dataclass(eq=False, repr=False)
class ExportFormatConfig(betterproto.Message):
    """
    ExportFormatConfig is used to confgure a global format for exporting logs
    to all the configured syslog servers.
    """

    format: "Format" = betterproto.enum_field(1)
    """format defines the syslog format to be used for export."""


@dataclass(eq=False, repr=False)
class Export(betterproto.Message):
    """Export provides the export status for a syslog server."""

    key: "ExportKey" = betterproto.message_field(1)
    """key uniquely identifies a syslog server"""

    stats: "ExportStats" = betterproto.message_field(2)
    """stats contains the statistics for all export operations."""

    last_error: "ExportError" = betterproto.message_field(3)
    """last_error provides the details of the last export error."""

    last_success: "ExportSuccess" = betterproto.message_field(4)
    """last_success provides details of last successful export."""


@dataclass(eq=False, repr=False)
class ExportRequest(betterproto.Message):
    key: "ExportKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a Export instance to retrieve. This value must be
    populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class ExportResponse(betterproto.Message):
    value: "Export" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the Export
    instance in this response.
    """


@dataclass(eq=False, repr=False)
class ExportStreamRequest(betterproto.Message):
    partial_eq_filter: List["Export"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class ExportStreamResponse(betterproto.Message):
    value: "Export" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """Time holds the timestamp of this Export's last modification."""

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the Export value in this response should be
    considered. Under non-subscribe requests, this value should always be
    INITIAL. In a subscription, once all initial data is streamed and the
    client begins to receive modification updates, you should not see INITIAL
    again.
    """


@dataclass(eq=False, repr=False)
class ExportConfigRequest(betterproto.Message):
    key: "ExportKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a ExportConfig instance to retrieve. This value
    must be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class ExportConfigResponse(betterproto.Message):
    value: "ExportConfig" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    ExportConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class ExportConfigStreamRequest(betterproto.Message):
    partial_eq_filter: List["ExportConfig"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class ExportConfigStreamResponse(betterproto.Message):
    value: "ExportConfig" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """Time holds the timestamp of this ExportConfig's last modification."""

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the ExportConfig value in this response should be
    considered. Under non-subscribe requests, this value should always be
    INITIAL. In a subscription, once all initial data is streamed and the
    client begins to receive modification updates, you should not see INITIAL
    again.
    """


@dataclass(eq=False, repr=False)
class ExportConfigSetRequest(betterproto.Message):
    value: "ExportConfig" = betterproto.message_field(1)
    """
    ExportConfig carries the value to set into the datastore. See the
    documentation on the ExportConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class ExportConfigSetResponse(betterproto.Message):
    value: "ExportConfig" = betterproto.message_field(1)
    """
    Value carries all the values given in the ExportConfigSetRequest as well as
    any server-generated values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    creation. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class ExportConfigDeleteRequest(betterproto.Message):
    key: "ExportKey" = betterproto.message_field(1)
    """
    Key indicates which ExportConfig instance to remove. This field must always
    be set.
    """


@dataclass(eq=False, repr=False)
class ExportConfigDeleteResponse(betterproto.Message):
    key: "ExportKey" = betterproto.message_field(1)
    """Key echoes back the key of the deleted ExportConfig instance."""

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    deletion. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class ExportConfigDeleteAllRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ExportConfigDeleteAllResponse(betterproto.Message):
    type: "___fmp__.DeleteError" = betterproto.enum_field(1)
    """This describes the class of delete error."""

    error: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "ExportKey" = betterproto.message_field(3)
    """
    This is the key of the ExportConfig instance that failed to be deleted.
    """

    time: datetime = betterproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class ExportFormatConfigRequest(betterproto.Message):
    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class ExportFormatConfigResponse(betterproto.Message):
    value: "ExportFormatConfig" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    ExportFormatConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class ExportFormatConfigStreamRequest(betterproto.Message):
    partial_eq_filter: List["ExportFormatConfig"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class ExportFormatConfigStreamResponse(betterproto.Message):
    value: "ExportFormatConfig" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time holds the timestamp of this ExportFormatConfig's last modification.
    """

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the ExportFormatConfig value in this response
    should be considered. Under non-subscribe requests, this value should
    always be INITIAL. In a subscription, once all initial data is streamed and
    the client begins to receive modification updates, you should not see
    INITIAL again.
    """


@dataclass(eq=False, repr=False)
class ExportFormatConfigSetRequest(betterproto.Message):
    value: "ExportFormatConfig" = betterproto.message_field(1)
    """
    ExportFormatConfig carries the value to set into the datastore. See the
    documentation on the ExportFormatConfig struct for which fields are
    required.
    """


@dataclass(eq=False, repr=False)
class ExportFormatConfigSetResponse(betterproto.Message):
    value: "ExportFormatConfig" = betterproto.message_field(1)
    """
    Value carries all the values given in the ExportFormatConfigSetRequest as
    well as any server-generated values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    creation. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==CreatedAt will include this instance.
    """


class ExportServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        export_request: "ExportRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ExportResponse":
        return await self._unary_unary(
            "/arista.syslog.v1.ExportService/GetOne",
            export_request,
            ExportResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        export_stream_request: "ExportStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ExportStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.syslog.v1.ExportService/GetAll",
            export_stream_request,
            ExportStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        export_stream_request: "ExportStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ExportStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.syslog.v1.ExportService/Subscribe",
            export_stream_request,
            ExportStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class ExportConfigServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        export_config_request: "ExportConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ExportConfigResponse":
        return await self._unary_unary(
            "/arista.syslog.v1.ExportConfigService/GetOne",
            export_config_request,
            ExportConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        export_config_stream_request: "ExportConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ExportConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.syslog.v1.ExportConfigService/GetAll",
            export_config_stream_request,
            ExportConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        export_config_stream_request: "ExportConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ExportConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.syslog.v1.ExportConfigService/Subscribe",
            export_config_stream_request,
            ExportConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        export_config_set_request: "ExportConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ExportConfigSetResponse":
        return await self._unary_unary(
            "/arista.syslog.v1.ExportConfigService/Set",
            export_config_set_request,
            ExportConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete(
        self,
        export_config_delete_request: "ExportConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ExportConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.syslog.v1.ExportConfigService/Delete",
            export_config_delete_request,
            ExportConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_all(
        self,
        export_config_delete_all_request: "ExportConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ExportConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.syslog.v1.ExportConfigService/DeleteAll",
            export_config_delete_all_request,
            ExportConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class ExportFormatConfigServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        export_format_config_request: "ExportFormatConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ExportFormatConfigResponse":
        return await self._unary_unary(
            "/arista.syslog.v1.ExportFormatConfigService/GetOne",
            export_format_config_request,
            ExportFormatConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe(
        self,
        export_format_config_stream_request: "ExportFormatConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ExportFormatConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.syslog.v1.ExportFormatConfigService/Subscribe",
            export_format_config_stream_request,
            ExportFormatConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        export_format_config_set_request: "ExportFormatConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ExportFormatConfigSetResponse":
        return await self._unary_unary(
            "/arista.syslog.v1.ExportFormatConfigService/Set",
            export_format_config_set_request,
            ExportFormatConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class ExportServiceBase(ServiceBase):
    async def get_one(self, export_request: "ExportRequest") -> "ExportResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, export_stream_request: "ExportStreamRequest"
    ) -> AsyncIterator["ExportStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ExportStreamResponse()

    async def subscribe(
        self, export_stream_request: "ExportStreamRequest"
    ) -> AsyncIterator["ExportStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ExportStreamResponse()

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[ExportRequest, ExportResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self, stream: "grpclib.server.Stream[ExportStreamRequest, ExportStreamResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self, stream: "grpclib.server.Stream[ExportStreamRequest, ExportStreamResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.syslog.v1.ExportService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExportRequest,
                ExportResponse,
            ),
            "/arista.syslog.v1.ExportService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                ExportStreamRequest,
                ExportStreamResponse,
            ),
            "/arista.syslog.v1.ExportService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                ExportStreamRequest,
                ExportStreamResponse,
            ),
        }


class ExportConfigServiceBase(ServiceBase):
    async def get_one(
        self, export_config_request: "ExportConfigRequest"
    ) -> "ExportConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, export_config_stream_request: "ExportConfigStreamRequest"
    ) -> AsyncIterator["ExportConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ExportConfigStreamResponse()

    async def subscribe(
        self, export_config_stream_request: "ExportConfigStreamRequest"
    ) -> AsyncIterator["ExportConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ExportConfigStreamResponse()

    async def set(
        self, export_config_set_request: "ExportConfigSetRequest"
    ) -> "ExportConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, export_config_delete_request: "ExportConfigDeleteRequest"
    ) -> "ExportConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self, export_config_delete_all_request: "ExportConfigDeleteAllRequest"
    ) -> AsyncIterator["ExportConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ExportConfigDeleteAllResponse()

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[ExportConfigRequest, ExportConfigResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[ExportConfigStreamRequest, ExportConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[ExportConfigStreamRequest, ExportConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[ExportConfigSetRequest, ExportConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[ExportConfigDeleteRequest, ExportConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[ExportConfigDeleteAllRequest, ExportConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.syslog.v1.ExportConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExportConfigRequest,
                ExportConfigResponse,
            ),
            "/arista.syslog.v1.ExportConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                ExportConfigStreamRequest,
                ExportConfigStreamResponse,
            ),
            "/arista.syslog.v1.ExportConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                ExportConfigStreamRequest,
                ExportConfigStreamResponse,
            ),
            "/arista.syslog.v1.ExportConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExportConfigSetRequest,
                ExportConfigSetResponse,
            ),
            "/arista.syslog.v1.ExportConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExportConfigDeleteRequest,
                ExportConfigDeleteResponse,
            ),
            "/arista.syslog.v1.ExportConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                ExportConfigDeleteAllRequest,
                ExportConfigDeleteAllResponse,
            ),
        }


class ExportFormatConfigServiceBase(ServiceBase):
    async def get_one(
        self, export_format_config_request: "ExportFormatConfigRequest"
    ) -> "ExportFormatConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, export_format_config_stream_request: "ExportFormatConfigStreamRequest"
    ) -> AsyncIterator["ExportFormatConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ExportFormatConfigStreamResponse()

    async def set(
        self, export_format_config_set_request: "ExportFormatConfigSetRequest"
    ) -> "ExportFormatConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[ExportFormatConfigRequest, ExportFormatConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[ExportFormatConfigStreamRequest, ExportFormatConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[ExportFormatConfigSetRequest, ExportFormatConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.syslog.v1.ExportFormatConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExportFormatConfigRequest,
                ExportFormatConfigResponse,
            ),
            "/arista.syslog.v1.ExportFormatConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                ExportFormatConfigStreamRequest,
                ExportFormatConfigStreamResponse,
            ),
            "/arista.syslog.v1.ExportFormatConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExportFormatConfigSetRequest,
                ExportFormatConfigSetResponse,
            ),
        }
