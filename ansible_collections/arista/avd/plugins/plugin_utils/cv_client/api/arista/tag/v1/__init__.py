# Copyright (c) 2023 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: arista/tag.v1/services.gen.proto, arista/tag.v1/tag.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from .... import fmp as ___fmp__
from ... import (
    subscriptions as __subscriptions__,
    time as __time__,
)


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class CreatorType(betterproto.Enum):
    """CreatorType specifies an entity that creates something."""

    CREATOR_TYPE_UNSPECIFIED = 0
    CREATOR_TYPE_SYSTEM = 1
    """CREATOR_TYPE_SYSTEM is the type for something created by the system."""

    CREATOR_TYPE_USER = 2
    """CREATOR_TYPE_USER is the type for something created by a user."""


@dataclass(eq=False, repr=False)
class TagKey(betterproto.Message):
    """TagKey uniquely identifies a tag for a network element."""

    label: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    """Label is the label of the tag."""

    value: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """Value is the value of the tag."""


@dataclass(eq=False, repr=False)
class InterfaceTagConfig(betterproto.Message):
    """
    InterfaceTagConfig is a label-value pair that may or may not be assigned to
    an interface.
    """

    key: "TagKey" = betterproto.message_field(1)
    """Key uniquely identifies the interface tag."""


@dataclass(eq=False, repr=False)
class InterfaceTag(betterproto.Message):
    """
    InterfaceTag is a label-value pair that may or may not be assigned to an
    interface.
    """

    key: "TagKey" = betterproto.message_field(1)
    """Key uniquely identifies the interface tag."""

    creator_type: "CreatorType" = betterproto.enum_field(2)
    """CreatorType is the creator type of the tag."""


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentKey(betterproto.Message):
    """
    InterfaceTagAssignmentKey uniquely identifies an interface tag assignment.
    """

    label: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    """Label is the label of the tag."""

    value: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """Value is the value of the tag."""

    device_id: Optional[str] = betterproto.message_field(
        3, wraps=betterproto.TYPE_STRING
    )
    """DeviceId is the ID of the interface's device."""

    interface_id: Optional[str] = betterproto.message_field(
        4, wraps=betterproto.TYPE_STRING
    )
    """InterfaceId is the ID of the interface."""


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfig(betterproto.Message):
    """
    InterfaceTagAssignmentConfig is the assignment of an interface tag to a
    specific interface.
    """

    key: "InterfaceTagAssignmentKey" = betterproto.message_field(1)
    """Key uniquely identifies the interface tag assignment."""


@dataclass(eq=False, repr=False)
class DeviceTagConfig(betterproto.Message):
    """
    DeviceTagConfig is a label-value pair that may or may not be assigned to a
    device.
    """

    key: "TagKey" = betterproto.message_field(1)
    """Key uniquely identifies the device tag."""


@dataclass(eq=False, repr=False)
class DeviceTag(betterproto.Message):
    """
    DeviceTag is a label-value pair that may or may not be assigned to a
    device.
    """

    key: "TagKey" = betterproto.message_field(1)
    """Key uniquely identifies the device tag."""

    creator_type: "CreatorType" = betterproto.enum_field(2)
    """CreatorType is the creator type of the tag."""


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentKey(betterproto.Message):
    """DeviceTagAssignmentKey uniquely identifies a device tag assignment."""

    label: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    """Label is the label of the tag."""

    value: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """Value is the value of the tag."""

    device_id: Optional[str] = betterproto.message_field(
        3, wraps=betterproto.TYPE_STRING
    )
    """DeviceId is the ID of the device."""


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfig(betterproto.Message):
    """
    DeviceTagAssignmentConfig is the assignment of a device tag to a specific
    device.
    """

    key: "DeviceTagAssignmentKey" = betterproto.message_field(1)
    """Key uniquely identifies the device tag assignment."""


@dataclass(eq=False, repr=False)
class DeviceTagRequest(betterproto.Message):
    key: "TagKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a DeviceTag instance to retrieve. This value must
    be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceTagResponse(betterproto.Message):
    value: "DeviceTag" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the DeviceTag
    instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceTagStreamRequest(betterproto.Message):
    partial_eq_filter: List["DeviceTag"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class DeviceTagStreamResponse(betterproto.Message):
    value: "DeviceTag" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """Time holds the timestamp of this DeviceTag's last modification."""

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the DeviceTag value in this response should be
    considered. Under non-subscribe requests, this value should always be
    INITIAL. In a subscription, once all initial data is streamed and the
    client begins to receive modification updates, you should not see INITIAL
    again.
    """


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfigRequest(betterproto.Message):
    key: "DeviceTagAssignmentKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a DeviceTagAssignmentConfig instance to retrieve.
    This value must be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfigResponse(betterproto.Message):
    value: "DeviceTagAssignmentConfig" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    DeviceTagAssignmentConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfigStreamRequest(betterproto.Message):
    partial_eq_filter: List["DeviceTagAssignmentConfig"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfigStreamResponse(betterproto.Message):
    value: "DeviceTagAssignmentConfig" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time holds the timestamp of this DeviceTagAssignmentConfig's last
    modification.
    """

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the DeviceTagAssignmentConfig value in this
    response should be considered. Under non-subscribe requests, this value
    should always be INITIAL. In a subscription, once all initial data is
    streamed and the client begins to receive modification updates, you should
    not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfigSetRequest(betterproto.Message):
    value: "DeviceTagAssignmentConfig" = betterproto.message_field(1)
    """
    DeviceTagAssignmentConfig carries the value to set into the datastore. See
    the documentation on the DeviceTagAssignmentConfig struct for which fields
    are required.
    """


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfigSetResponse(betterproto.Message):
    value: "DeviceTagAssignmentConfig" = betterproto.message_field(1)
    """
    Value carries all the values given in the
    DeviceTagAssignmentConfigSetRequest as well as any server-generated values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    creation. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfigDeleteRequest(betterproto.Message):
    key: "DeviceTagAssignmentKey" = betterproto.message_field(1)
    """
    Key indicates which DeviceTagAssignmentConfig instance to remove. This
    field must always be set.
    """


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfigDeleteResponse(betterproto.Message):
    key: "DeviceTagAssignmentKey" = betterproto.message_field(1)
    """
    Key echoes back the key of the deleted DeviceTagAssignmentConfig instance.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    deletion. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfigDeleteAllRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfigDeleteAllResponse(betterproto.Message):
    type: "___fmp__.DeleteError" = betterproto.enum_field(1)
    """This describes the class of delete error."""

    error: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "DeviceTagAssignmentKey" = betterproto.message_field(3)
    """
    This is the key of the DeviceTagAssignmentConfig instance that failed to be
    deleted.
    """

    time: datetime = betterproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class DeviceTagConfigRequest(betterproto.Message):
    key: "TagKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a DeviceTagConfig instance to retrieve. This value
    must be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceTagConfigResponse(betterproto.Message):
    value: "DeviceTagConfig" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    DeviceTagConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceTagConfigStreamRequest(betterproto.Message):
    partial_eq_filter: List["DeviceTagConfig"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class DeviceTagConfigStreamResponse(betterproto.Message):
    value: "DeviceTagConfig" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time holds the timestamp of this DeviceTagConfig's last modification.
    """

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the DeviceTagConfig value in this response should
    be considered. Under non-subscribe requests, this value should always be
    INITIAL. In a subscription, once all initial data is streamed and the
    client begins to receive modification updates, you should not see INITIAL
    again.
    """


@dataclass(eq=False, repr=False)
class DeviceTagConfigSetRequest(betterproto.Message):
    value: "DeviceTagConfig" = betterproto.message_field(1)
    """
    DeviceTagConfig carries the value to set into the datastore. See the
    documentation on the DeviceTagConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class DeviceTagConfigSetResponse(betterproto.Message):
    value: "DeviceTagConfig" = betterproto.message_field(1)
    """
    Value carries all the values given in the DeviceTagConfigSetRequest as well
    as any server-generated values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    creation. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class DeviceTagConfigDeleteRequest(betterproto.Message):
    key: "TagKey" = betterproto.message_field(1)
    """
    Key indicates which DeviceTagConfig instance to remove. This field must
    always be set.
    """


@dataclass(eq=False, repr=False)
class DeviceTagConfigDeleteResponse(betterproto.Message):
    key: "TagKey" = betterproto.message_field(1)
    """Key echoes back the key of the deleted DeviceTagConfig instance."""

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    deletion. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class DeviceTagConfigDeleteAllRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DeviceTagConfigDeleteAllResponse(betterproto.Message):
    type: "___fmp__.DeleteError" = betterproto.enum_field(1)
    """This describes the class of delete error."""

    error: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "TagKey" = betterproto.message_field(3)
    """
    This is the key of the DeviceTagConfig instance that failed to be deleted.
    """

    time: datetime = betterproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class InterfaceTagRequest(betterproto.Message):
    key: "TagKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a InterfaceTag instance to retrieve. This value
    must be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagResponse(betterproto.Message):
    value: "InterfaceTag" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    InterfaceTag instance in this response.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagStreamRequest(betterproto.Message):
    partial_eq_filter: List["InterfaceTag"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagStreamResponse(betterproto.Message):
    value: "InterfaceTag" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """Time holds the timestamp of this InterfaceTag's last modification."""

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the InterfaceTag value in this response should be
    considered. Under non-subscribe requests, this value should always be
    INITIAL. In a subscription, once all initial data is streamed and the
    client begins to receive modification updates, you should not see INITIAL
    again.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfigRequest(betterproto.Message):
    key: "InterfaceTagAssignmentKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a InterfaceTagAssignmentConfig instance to
    retrieve. This value must be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfigResponse(betterproto.Message):
    value: "InterfaceTagAssignmentConfig" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    InterfaceTagAssignmentConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfigStreamRequest(betterproto.Message):
    partial_eq_filter: List["InterfaceTagAssignmentConfig"] = betterproto.message_field(
        1
    )
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfigStreamResponse(betterproto.Message):
    value: "InterfaceTagAssignmentConfig" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time holds the timestamp of this InterfaceTagAssignmentConfig's last
    modification.
    """

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the InterfaceTagAssignmentConfig value in this
    response should be considered. Under non-subscribe requests, this value
    should always be INITIAL. In a subscription, once all initial data is
    streamed and the client begins to receive modification updates, you should
    not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfigSetRequest(betterproto.Message):
    value: "InterfaceTagAssignmentConfig" = betterproto.message_field(1)
    """
    InterfaceTagAssignmentConfig carries the value to set into the datastore.
    See the documentation on the InterfaceTagAssignmentConfig struct for which
    fields are required.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfigSetResponse(betterproto.Message):
    value: "InterfaceTagAssignmentConfig" = betterproto.message_field(1)
    """
    Value carries all the values given in the
    InterfaceTagAssignmentConfigSetRequest as well as any server-generated
    values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    creation. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfigDeleteRequest(betterproto.Message):
    key: "InterfaceTagAssignmentKey" = betterproto.message_field(1)
    """
    Key indicates which InterfaceTagAssignmentConfig instance to remove. This
    field must always be set.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfigDeleteResponse(betterproto.Message):
    key: "InterfaceTagAssignmentKey" = betterproto.message_field(1)
    """
    Key echoes back the key of the deleted InterfaceTagAssignmentConfig
    instance.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    deletion. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfigDeleteAllRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfigDeleteAllResponse(betterproto.Message):
    type: "___fmp__.DeleteError" = betterproto.enum_field(1)
    """This describes the class of delete error."""

    error: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "InterfaceTagAssignmentKey" = betterproto.message_field(3)
    """
    This is the key of the InterfaceTagAssignmentConfig instance that failed to
    be deleted.
    """

    time: datetime = betterproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class InterfaceTagConfigRequest(betterproto.Message):
    key: "TagKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a InterfaceTagConfig instance to retrieve. This
    value must be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagConfigResponse(betterproto.Message):
    value: "InterfaceTagConfig" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    InterfaceTagConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagConfigStreamRequest(betterproto.Message):
    partial_eq_filter: List["InterfaceTagConfig"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagConfigStreamResponse(betterproto.Message):
    value: "InterfaceTagConfig" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time holds the timestamp of this InterfaceTagConfig's last modification.
    """

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the InterfaceTagConfig value in this response
    should be considered. Under non-subscribe requests, this value should
    always be INITIAL. In a subscription, once all initial data is streamed and
    the client begins to receive modification updates, you should not see
    INITIAL again.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagConfigSetRequest(betterproto.Message):
    value: "InterfaceTagConfig" = betterproto.message_field(1)
    """
    InterfaceTagConfig carries the value to set into the datastore. See the
    documentation on the InterfaceTagConfig struct for which fields are
    required.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagConfigSetResponse(betterproto.Message):
    value: "InterfaceTagConfig" = betterproto.message_field(1)
    """
    Value carries all the values given in the InterfaceTagConfigSetRequest as
    well as any server-generated values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    creation. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagConfigDeleteRequest(betterproto.Message):
    key: "TagKey" = betterproto.message_field(1)
    """
    Key indicates which InterfaceTagConfig instance to remove. This field must
    always be set.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagConfigDeleteResponse(betterproto.Message):
    key: "TagKey" = betterproto.message_field(1)
    """Key echoes back the key of the deleted InterfaceTagConfig instance."""

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    deletion. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagConfigDeleteAllRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class InterfaceTagConfigDeleteAllResponse(betterproto.Message):
    type: "___fmp__.DeleteError" = betterproto.enum_field(1)
    """This describes the class of delete error."""

    error: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "TagKey" = betterproto.message_field(3)
    """
    This is the key of the InterfaceTagConfig instance that failed to be
    deleted.
    """

    time: datetime = betterproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


class DeviceTagServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        device_tag_request: "DeviceTagRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceTagResponse":
        return await self._unary_unary(
            "/arista.tag.v1.DeviceTagService/GetOne",
            device_tag_request,
            DeviceTagResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        device_tag_stream_request: "DeviceTagStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceTagStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.DeviceTagService/GetAll",
            device_tag_stream_request,
            DeviceTagStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        device_tag_stream_request: "DeviceTagStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceTagStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.DeviceTagService/Subscribe",
            device_tag_stream_request,
            DeviceTagStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DeviceTagAssignmentConfigServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        device_tag_assignment_config_request: "DeviceTagAssignmentConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceTagAssignmentConfigResponse":
        return await self._unary_unary(
            "/arista.tag.v1.DeviceTagAssignmentConfigService/GetOne",
            device_tag_assignment_config_request,
            DeviceTagAssignmentConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        device_tag_assignment_config_stream_request: "DeviceTagAssignmentConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceTagAssignmentConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.DeviceTagAssignmentConfigService/GetAll",
            device_tag_assignment_config_stream_request,
            DeviceTagAssignmentConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        device_tag_assignment_config_stream_request: "DeviceTagAssignmentConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceTagAssignmentConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.DeviceTagAssignmentConfigService/Subscribe",
            device_tag_assignment_config_stream_request,
            DeviceTagAssignmentConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        device_tag_assignment_config_set_request: "DeviceTagAssignmentConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceTagAssignmentConfigSetResponse":
        return await self._unary_unary(
            "/arista.tag.v1.DeviceTagAssignmentConfigService/Set",
            device_tag_assignment_config_set_request,
            DeviceTagAssignmentConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete(
        self,
        device_tag_assignment_config_delete_request: "DeviceTagAssignmentConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceTagAssignmentConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.tag.v1.DeviceTagAssignmentConfigService/Delete",
            device_tag_assignment_config_delete_request,
            DeviceTagAssignmentConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_all(
        self,
        device_tag_assignment_config_delete_all_request: "DeviceTagAssignmentConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceTagAssignmentConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.DeviceTagAssignmentConfigService/DeleteAll",
            device_tag_assignment_config_delete_all_request,
            DeviceTagAssignmentConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DeviceTagConfigServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        device_tag_config_request: "DeviceTagConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceTagConfigResponse":
        return await self._unary_unary(
            "/arista.tag.v1.DeviceTagConfigService/GetOne",
            device_tag_config_request,
            DeviceTagConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        device_tag_config_stream_request: "DeviceTagConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceTagConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.DeviceTagConfigService/GetAll",
            device_tag_config_stream_request,
            DeviceTagConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        device_tag_config_stream_request: "DeviceTagConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceTagConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.DeviceTagConfigService/Subscribe",
            device_tag_config_stream_request,
            DeviceTagConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        device_tag_config_set_request: "DeviceTagConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceTagConfigSetResponse":
        return await self._unary_unary(
            "/arista.tag.v1.DeviceTagConfigService/Set",
            device_tag_config_set_request,
            DeviceTagConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete(
        self,
        device_tag_config_delete_request: "DeviceTagConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceTagConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.tag.v1.DeviceTagConfigService/Delete",
            device_tag_config_delete_request,
            DeviceTagConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_all(
        self,
        device_tag_config_delete_all_request: "DeviceTagConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceTagConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.DeviceTagConfigService/DeleteAll",
            device_tag_config_delete_all_request,
            DeviceTagConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class InterfaceTagServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        interface_tag_request: "InterfaceTagRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InterfaceTagResponse":
        return await self._unary_unary(
            "/arista.tag.v1.InterfaceTagService/GetOne",
            interface_tag_request,
            InterfaceTagResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        interface_tag_stream_request: "InterfaceTagStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceTagStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.InterfaceTagService/GetAll",
            interface_tag_stream_request,
            InterfaceTagStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        interface_tag_stream_request: "InterfaceTagStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceTagStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.InterfaceTagService/Subscribe",
            interface_tag_stream_request,
            InterfaceTagStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class InterfaceTagAssignmentConfigServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        interface_tag_assignment_config_request: "InterfaceTagAssignmentConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InterfaceTagAssignmentConfigResponse":
        return await self._unary_unary(
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/GetOne",
            interface_tag_assignment_config_request,
            InterfaceTagAssignmentConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        interface_tag_assignment_config_stream_request: "InterfaceTagAssignmentConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceTagAssignmentConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/GetAll",
            interface_tag_assignment_config_stream_request,
            InterfaceTagAssignmentConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        interface_tag_assignment_config_stream_request: "InterfaceTagAssignmentConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceTagAssignmentConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/Subscribe",
            interface_tag_assignment_config_stream_request,
            InterfaceTagAssignmentConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        interface_tag_assignment_config_set_request: "InterfaceTagAssignmentConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InterfaceTagAssignmentConfigSetResponse":
        return await self._unary_unary(
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/Set",
            interface_tag_assignment_config_set_request,
            InterfaceTagAssignmentConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete(
        self,
        interface_tag_assignment_config_delete_request: "InterfaceTagAssignmentConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InterfaceTagAssignmentConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/Delete",
            interface_tag_assignment_config_delete_request,
            InterfaceTagAssignmentConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_all(
        self,
        interface_tag_assignment_config_delete_all_request: "InterfaceTagAssignmentConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceTagAssignmentConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/DeleteAll",
            interface_tag_assignment_config_delete_all_request,
            InterfaceTagAssignmentConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class InterfaceTagConfigServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        interface_tag_config_request: "InterfaceTagConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InterfaceTagConfigResponse":
        return await self._unary_unary(
            "/arista.tag.v1.InterfaceTagConfigService/GetOne",
            interface_tag_config_request,
            InterfaceTagConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        interface_tag_config_stream_request: "InterfaceTagConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceTagConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.InterfaceTagConfigService/GetAll",
            interface_tag_config_stream_request,
            InterfaceTagConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        interface_tag_config_stream_request: "InterfaceTagConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceTagConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.InterfaceTagConfigService/Subscribe",
            interface_tag_config_stream_request,
            InterfaceTagConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        interface_tag_config_set_request: "InterfaceTagConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InterfaceTagConfigSetResponse":
        return await self._unary_unary(
            "/arista.tag.v1.InterfaceTagConfigService/Set",
            interface_tag_config_set_request,
            InterfaceTagConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete(
        self,
        interface_tag_config_delete_request: "InterfaceTagConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InterfaceTagConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.tag.v1.InterfaceTagConfigService/Delete",
            interface_tag_config_delete_request,
            InterfaceTagConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_all(
        self,
        interface_tag_config_delete_all_request: "InterfaceTagConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceTagConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.InterfaceTagConfigService/DeleteAll",
            interface_tag_config_delete_all_request,
            InterfaceTagConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DeviceTagServiceBase(ServiceBase):
    async def get_one(
        self, device_tag_request: "DeviceTagRequest"
    ) -> "DeviceTagResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, device_tag_stream_request: "DeviceTagStreamRequest"
    ) -> AsyncIterator["DeviceTagStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeviceTagStreamResponse()

    async def subscribe(
        self, device_tag_stream_request: "DeviceTagStreamRequest"
    ) -> AsyncIterator["DeviceTagStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeviceTagStreamResponse()

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[DeviceTagRequest, DeviceTagResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DeviceTagStreamRequest, DeviceTagStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DeviceTagStreamRequest, DeviceTagStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.tag.v1.DeviceTagService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceTagRequest,
                DeviceTagResponse,
            ),
            "/arista.tag.v1.DeviceTagService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceTagStreamRequest,
                DeviceTagStreamResponse,
            ),
            "/arista.tag.v1.DeviceTagService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceTagStreamRequest,
                DeviceTagStreamResponse,
            ),
        }


class DeviceTagAssignmentConfigServiceBase(ServiceBase):
    async def get_one(
        self, device_tag_assignment_config_request: "DeviceTagAssignmentConfigRequest"
    ) -> "DeviceTagAssignmentConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self,
        device_tag_assignment_config_stream_request: "DeviceTagAssignmentConfigStreamRequest",
    ) -> AsyncIterator["DeviceTagAssignmentConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeviceTagAssignmentConfigStreamResponse()

    async def subscribe(
        self,
        device_tag_assignment_config_stream_request: "DeviceTagAssignmentConfigStreamRequest",
    ) -> AsyncIterator["DeviceTagAssignmentConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeviceTagAssignmentConfigStreamResponse()

    async def set(
        self,
        device_tag_assignment_config_set_request: "DeviceTagAssignmentConfigSetRequest",
    ) -> "DeviceTagAssignmentConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self,
        device_tag_assignment_config_delete_request: "DeviceTagAssignmentConfigDeleteRequest",
    ) -> "DeviceTagAssignmentConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self,
        device_tag_assignment_config_delete_all_request: "DeviceTagAssignmentConfigDeleteAllRequest",
    ) -> AsyncIterator["DeviceTagAssignmentConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeviceTagAssignmentConfigDeleteAllResponse()

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[DeviceTagAssignmentConfigRequest, DeviceTagAssignmentConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DeviceTagAssignmentConfigStreamRequest, DeviceTagAssignmentConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DeviceTagAssignmentConfigStreamRequest, DeviceTagAssignmentConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[DeviceTagAssignmentConfigSetRequest, DeviceTagAssignmentConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[DeviceTagAssignmentConfigDeleteRequest, DeviceTagAssignmentConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[DeviceTagAssignmentConfigDeleteAllRequest, DeviceTagAssignmentConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.tag.v1.DeviceTagAssignmentConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceTagAssignmentConfigRequest,
                DeviceTagAssignmentConfigResponse,
            ),
            "/arista.tag.v1.DeviceTagAssignmentConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceTagAssignmentConfigStreamRequest,
                DeviceTagAssignmentConfigStreamResponse,
            ),
            "/arista.tag.v1.DeviceTagAssignmentConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceTagAssignmentConfigStreamRequest,
                DeviceTagAssignmentConfigStreamResponse,
            ),
            "/arista.tag.v1.DeviceTagAssignmentConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceTagAssignmentConfigSetRequest,
                DeviceTagAssignmentConfigSetResponse,
            ),
            "/arista.tag.v1.DeviceTagAssignmentConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceTagAssignmentConfigDeleteRequest,
                DeviceTagAssignmentConfigDeleteResponse,
            ),
            "/arista.tag.v1.DeviceTagAssignmentConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceTagAssignmentConfigDeleteAllRequest,
                DeviceTagAssignmentConfigDeleteAllResponse,
            ),
        }


class DeviceTagConfigServiceBase(ServiceBase):
    async def get_one(
        self, device_tag_config_request: "DeviceTagConfigRequest"
    ) -> "DeviceTagConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, device_tag_config_stream_request: "DeviceTagConfigStreamRequest"
    ) -> AsyncIterator["DeviceTagConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeviceTagConfigStreamResponse()

    async def subscribe(
        self, device_tag_config_stream_request: "DeviceTagConfigStreamRequest"
    ) -> AsyncIterator["DeviceTagConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeviceTagConfigStreamResponse()

    async def set(
        self, device_tag_config_set_request: "DeviceTagConfigSetRequest"
    ) -> "DeviceTagConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, device_tag_config_delete_request: "DeviceTagConfigDeleteRequest"
    ) -> "DeviceTagConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self, device_tag_config_delete_all_request: "DeviceTagConfigDeleteAllRequest"
    ) -> AsyncIterator["DeviceTagConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeviceTagConfigDeleteAllResponse()

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[DeviceTagConfigRequest, DeviceTagConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DeviceTagConfigStreamRequest, DeviceTagConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DeviceTagConfigStreamRequest, DeviceTagConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[DeviceTagConfigSetRequest, DeviceTagConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[DeviceTagConfigDeleteRequest, DeviceTagConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[DeviceTagConfigDeleteAllRequest, DeviceTagConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.tag.v1.DeviceTagConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceTagConfigRequest,
                DeviceTagConfigResponse,
            ),
            "/arista.tag.v1.DeviceTagConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceTagConfigStreamRequest,
                DeviceTagConfigStreamResponse,
            ),
            "/arista.tag.v1.DeviceTagConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceTagConfigStreamRequest,
                DeviceTagConfigStreamResponse,
            ),
            "/arista.tag.v1.DeviceTagConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceTagConfigSetRequest,
                DeviceTagConfigSetResponse,
            ),
            "/arista.tag.v1.DeviceTagConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceTagConfigDeleteRequest,
                DeviceTagConfigDeleteResponse,
            ),
            "/arista.tag.v1.DeviceTagConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceTagConfigDeleteAllRequest,
                DeviceTagConfigDeleteAllResponse,
            ),
        }


class InterfaceTagServiceBase(ServiceBase):
    async def get_one(
        self, interface_tag_request: "InterfaceTagRequest"
    ) -> "InterfaceTagResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, interface_tag_stream_request: "InterfaceTagStreamRequest"
    ) -> AsyncIterator["InterfaceTagStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield InterfaceTagStreamResponse()

    async def subscribe(
        self, interface_tag_stream_request: "InterfaceTagStreamRequest"
    ) -> AsyncIterator["InterfaceTagStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield InterfaceTagStreamResponse()

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[InterfaceTagRequest, InterfaceTagResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[InterfaceTagStreamRequest, InterfaceTagStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[InterfaceTagStreamRequest, InterfaceTagStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.tag.v1.InterfaceTagService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceTagRequest,
                InterfaceTagResponse,
            ),
            "/arista.tag.v1.InterfaceTagService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceTagStreamRequest,
                InterfaceTagStreamResponse,
            ),
            "/arista.tag.v1.InterfaceTagService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceTagStreamRequest,
                InterfaceTagStreamResponse,
            ),
        }


class InterfaceTagAssignmentConfigServiceBase(ServiceBase):
    async def get_one(
        self,
        interface_tag_assignment_config_request: "InterfaceTagAssignmentConfigRequest",
    ) -> "InterfaceTagAssignmentConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self,
        interface_tag_assignment_config_stream_request: "InterfaceTagAssignmentConfigStreamRequest",
    ) -> AsyncIterator["InterfaceTagAssignmentConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield InterfaceTagAssignmentConfigStreamResponse()

    async def subscribe(
        self,
        interface_tag_assignment_config_stream_request: "InterfaceTagAssignmentConfigStreamRequest",
    ) -> AsyncIterator["InterfaceTagAssignmentConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield InterfaceTagAssignmentConfigStreamResponse()

    async def set(
        self,
        interface_tag_assignment_config_set_request: "InterfaceTagAssignmentConfigSetRequest",
    ) -> "InterfaceTagAssignmentConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self,
        interface_tag_assignment_config_delete_request: "InterfaceTagAssignmentConfigDeleteRequest",
    ) -> "InterfaceTagAssignmentConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self,
        interface_tag_assignment_config_delete_all_request: "InterfaceTagAssignmentConfigDeleteAllRequest",
    ) -> AsyncIterator["InterfaceTagAssignmentConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield InterfaceTagAssignmentConfigDeleteAllResponse()

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[InterfaceTagAssignmentConfigRequest, InterfaceTagAssignmentConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[InterfaceTagAssignmentConfigStreamRequest, InterfaceTagAssignmentConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[InterfaceTagAssignmentConfigStreamRequest, InterfaceTagAssignmentConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[InterfaceTagAssignmentConfigSetRequest, InterfaceTagAssignmentConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[InterfaceTagAssignmentConfigDeleteRequest, InterfaceTagAssignmentConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[InterfaceTagAssignmentConfigDeleteAllRequest, InterfaceTagAssignmentConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceTagAssignmentConfigRequest,
                InterfaceTagAssignmentConfigResponse,
            ),
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceTagAssignmentConfigStreamRequest,
                InterfaceTagAssignmentConfigStreamResponse,
            ),
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceTagAssignmentConfigStreamRequest,
                InterfaceTagAssignmentConfigStreamResponse,
            ),
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceTagAssignmentConfigSetRequest,
                InterfaceTagAssignmentConfigSetResponse,
            ),
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceTagAssignmentConfigDeleteRequest,
                InterfaceTagAssignmentConfigDeleteResponse,
            ),
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceTagAssignmentConfigDeleteAllRequest,
                InterfaceTagAssignmentConfigDeleteAllResponse,
            ),
        }


class InterfaceTagConfigServiceBase(ServiceBase):
    async def get_one(
        self, interface_tag_config_request: "InterfaceTagConfigRequest"
    ) -> "InterfaceTagConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, interface_tag_config_stream_request: "InterfaceTagConfigStreamRequest"
    ) -> AsyncIterator["InterfaceTagConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield InterfaceTagConfigStreamResponse()

    async def subscribe(
        self, interface_tag_config_stream_request: "InterfaceTagConfigStreamRequest"
    ) -> AsyncIterator["InterfaceTagConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield InterfaceTagConfigStreamResponse()

    async def set(
        self, interface_tag_config_set_request: "InterfaceTagConfigSetRequest"
    ) -> "InterfaceTagConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, interface_tag_config_delete_request: "InterfaceTagConfigDeleteRequest"
    ) -> "InterfaceTagConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self,
        interface_tag_config_delete_all_request: "InterfaceTagConfigDeleteAllRequest",
    ) -> AsyncIterator["InterfaceTagConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield InterfaceTagConfigDeleteAllResponse()

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[InterfaceTagConfigRequest, InterfaceTagConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[InterfaceTagConfigStreamRequest, InterfaceTagConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[InterfaceTagConfigStreamRequest, InterfaceTagConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[InterfaceTagConfigSetRequest, InterfaceTagConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[InterfaceTagConfigDeleteRequest, InterfaceTagConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[InterfaceTagConfigDeleteAllRequest, InterfaceTagConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.tag.v1.InterfaceTagConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceTagConfigRequest,
                InterfaceTagConfigResponse,
            ),
            "/arista.tag.v1.InterfaceTagConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceTagConfigStreamRequest,
                InterfaceTagConfigStreamResponse,
            ),
            "/arista.tag.v1.InterfaceTagConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceTagConfigStreamRequest,
                InterfaceTagConfigStreamResponse,
            ),
            "/arista.tag.v1.InterfaceTagConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceTagConfigSetRequest,
                InterfaceTagConfigSetResponse,
            ),
            "/arista.tag.v1.InterfaceTagConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceTagConfigDeleteRequest,
                InterfaceTagConfigDeleteResponse,
            ),
            "/arista.tag.v1.InterfaceTagConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceTagConfigDeleteAllRequest,
                InterfaceTagConfigDeleteAllResponse,
            ),
        }
