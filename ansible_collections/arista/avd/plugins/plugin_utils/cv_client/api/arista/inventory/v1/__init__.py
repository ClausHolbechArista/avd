# Copyright (c) 2023 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: arista/inventory.v1/inventory.proto, arista/inventory.v1/services.gen.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from .... import fmp as ___fmp__
from ... import (
    subscriptions as __subscriptions__,
    time as __time__,
)


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class StreamingStatus(betterproto.Enum):
    """
    StreamingStatus defines the status of telemetry streaming for a device.
    """

    STREAMING_STATUS_UNSPECIFIED = 0
    STREAMING_STATUS_INACTIVE = 1
    """
    STREAMING_STATUS_INACTIVE indicates the device is not streaming telemetry.
    """

    STREAMING_STATUS_ACTIVE = 2
    """STREAMING_STATUS_ACTIVE indicates the device is streaming telemetry."""


class OnboardingStatus(betterproto.Enum):
    """
    OnboardingStatus defines the set of possible states in the onboarding
    process for a device.
    """

    ONBOARDING_STATUS_UNSPECIFIED = 0
    ONBOARDING_STATUS_IN_PROGRESS = 1
    """ONBOARDING_STATUS_IN_PROGRESS indicates onboarding is in progress."""

    ONBOARDING_STATUS_FAILURE = 2
    """ONBOARDING_STATUS_FAILURE indicates onboarding failed."""

    ONBOARDING_STATUS_SUCCESS = 3
    """ONBOARDING_STATUS_SUCCESS indicates onboarding succeeded."""


class DecommissioningStatus(betterproto.Enum):
    """
    DecommissioningStatus defines the set of possible states in the
    decommissioning process for a device.
    """

    DECOMMISSIONING_STATUS_UNSPECIFIED = 0
    DECOMMISSIONING_STATUS_IN_PROGRESS = 1
    """
    DECOMMISSIONING_STATUS_IN_PROGRESS indicates decommissioning is in
    progress.
    """

    DECOMMISSIONING_STATUS_FAILURE = 2
    """DECOMMISSIONING_STATUS_FAILURE indicates decommissioning failed."""

    DECOMMISSIONING_STATUS_SUCCESS = 3
    """DECOMMISSIONING_STATUS_SUCCESS indicates decommissioning succeeded."""


class ProvisioningStatus(betterproto.Enum):
    """
    ProvisioningStatus defines the set of possible states in the provisioning
    process for a device.
    """

    PROVISIONING_STATUS_UNSPECIFIED = 0
    PROVISIONING_STATUS_IN_PROGRESS = 1
    """
    PROVISIONING_STATUS_IN_PROGRESS indicates provisioning is in progress.
    """

    PROVISIONING_STATUS_FAILURE = 2
    """PROVISIONING_STATUS_FAILURE indicates provisioning failed."""

    PROVISIONING_STATUS_SUCCESS = 3
    """PROVISIONING_STATUS_SUCCESS indicates provisioning succeeded."""


@dataclass(eq=False, repr=False)
class ExtendedAttributes(betterproto.Message):
    """
    ExtendedAttributes wraps any additional, potentially non-standard, features
    or attributes the device reports.
    """

    feature_enabled: Dict[str, bool] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_BOOL
    )
    """
    feature_enabled is a map of feature name to enabled status. If a feature is
    missing from this map it can be assumed off.
    """


@dataclass(eq=False, repr=False)
class DeviceKey(betterproto.Message):
    """DeviceKey uniquely identifies a single device."""

    device_id: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    """device_id is the unique identifier of the device."""


@dataclass(eq=False, repr=False)
class DeviceConfiguration(betterproto.Message):
    """
    DeviceConfiguration holds the device-specific configuration for a third-
    party device, as defined in https://github.com/aristanetworks/cloudvision-
    go.
    """

    options: Dict[str, str] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    """
    options is a map from device option to value. E.g., for an SNMP device,
    this could be the following: "address":   "my_snmp_hostname", "community":
    "public"
    """


@dataclass(eq=False, repr=False)
class UuidKey(betterproto.Message):
    """
    UUIDKey is a key that holds a UUID for an onboarding or decommissioning
    request.
    """

    request_id: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    """request_id should be a UUID for the request."""


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfig(betterproto.Message):
    """
    DeviceOnboardingConfig describes a device onboarding request. "Onboarding"
    refers to the process of initiating device streaming to CloudVision and
    adding the streaming device to CloudVision's inventory. The request flow
    works as follows: 1. Set on DeviceOnboardingConfig sends an onboarding
    request with a UUID    that the user is responsible for generating. 2. Once
    the server receives the request, it validates and records it. 3. Then, the
    server processes it, initiating the onboarding procedure and    tracking
    the status of the onboarding attempt. 4. The user may do a GetOne or
    Subscribe on DeviceOnboarding using the same    UUID to see the status of
    the request.
    """

    key: "UuidKey" = betterproto.message_field(1)
    """key identifies the request to onboard the device at hostname_or_ip."""

    hostname_or_ip: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """
    hostname_or_ip is a hostname or an IP at which the device can be reached.
    """

    device_type: Optional[str] = betterproto.message_field(
        3, wraps=betterproto.TYPE_STRING
    )
    """
    device_type describes the method by which to retrieve information for the
    device. The value should be "eos" for eos devices. For third-party devices,
    supported values are: "openconfig", "snmp", "cvp", "mwm", and "vCenter".
    """

    device_config: "DeviceConfiguration" = betterproto.message_field(4)
    """device_config is the configuration for a third-party device."""


@dataclass(eq=False, repr=False)
class DeviceOnboarding(betterproto.Message):
    """DeviceOnboarding describes the status of an onboarding process."""

    key: "UuidKey" = betterproto.message_field(1)
    """
    key identifies the request for which to retrieve an onboarding status.
    """

    device_id: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """device_id is the unique device ID that is discovered via onboarding."""

    status: "OnboardingStatus" = betterproto.enum_field(3)
    """status describes the onboarding status of the device."""

    error: Optional[str] = betterproto.message_field(4, wraps=betterproto.TYPE_STRING)
    """
    error is the error that caused status to become ONBOARDING_STATUS_FAILURE.
    """

    status_message: Optional[str] = betterproto.message_field(
        5, wraps=betterproto.TYPE_STRING
    )
    """
    status_message contains information on the status of the onboarding
    attempt, if any. This is generally an unstructured log message that is for
    display purposes only (its structure and contents may change).
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfig(betterproto.Message):
    """
    DeviceDecommissioningConfig describes a device decommissioning request.
    "Decommissioning" refers to the process of stopping device streaming to
    CloudVision and removing it from CloudVision's inventory. The request flow
    works as follows: 1. Set on DeviceDecommissioningConfig sends a
    decommissioning request with    a UUID that the user is responsible for
    generating. 2. Once the server receives the request, it validates and
    records it. 3. Then, the server processes it, initiating the
    decommissioning procedure    and tracking the status of the decommissioning
    attempt. 4. The user may do a GetOne or Subscribe on DeviceDecommissioning
    using the    same UUID to see the status of the request.
    """

    key: "UuidKey" = betterproto.message_field(1)
    """key identifies the request to decommission the device."""

    device_id: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """
    device_id is the unique device ID that was discovered via onboarding.
    """

    force: Optional[bool] = betterproto.message_field(3, wraps=betterproto.TYPE_BOOL)
    """
    force is a flag that indicates if the decommission is to be forced.
    Normally, if there are pending or in-progress tasks associated with the
    device the decommission would fail. In case of a forced decommission, such
    blocking tasks would be ignored and decommissioning will be continued.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioning(betterproto.Message):
    """DeviceOnboarding describes the status of a decommissioning process."""

    key: "UuidKey" = betterproto.message_field(1)
    """
    key identifies the request for which to retrieve a decommissioning status.
    """

    status: "DecommissioningStatus" = betterproto.enum_field(2)
    """status describes the decommissioning status of the device."""

    error: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)
    """
    error is the error that caused status to become
    DECOMMISSIONING_STATUS_FAILURE.
    """

    status_message: Optional[str] = betterproto.message_field(
        4, wraps=betterproto.TYPE_STRING
    )
    """
    status_message contains information on the status of the decommissioning
    attempt, if any. This is generally an unstructured log message that is for
    display purposes only (its structure and contents may change).
    """


@dataclass(eq=False, repr=False)
class Device(betterproto.Message):
    """Device describes an onboarded device."""

    key: "DeviceKey" = betterproto.message_field(1)
    """key uniquely identifies the device."""

    software_version: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """
    software_version gives the currently running device software version.
    """

    model_name: Optional[str] = betterproto.message_field(
        3, wraps=betterproto.TYPE_STRING
    )
    """model_name describes the hardware model of this device."""

    hardware_revision: Optional[str] = betterproto.message_field(
        4, wraps=betterproto.TYPE_STRING
    )
    """hardware_revision describes any revisional data to the model name."""

    fqdn: Optional[str] = betterproto.message_field(10, wraps=betterproto.TYPE_STRING)
    """fqdn gives the device's fully qualified domain name."""

    hostname: Optional[str] = betterproto.message_field(
        11, wraps=betterproto.TYPE_STRING
    )
    """hostname is the hostname as reported on the device."""

    domain_name: Optional[str] = betterproto.message_field(
        12, wraps=betterproto.TYPE_STRING
    )
    """
    domain_name provides the domain name on which the device is registered.
    """

    system_mac_address: Optional[str] = betterproto.message_field(
        13, wraps=betterproto.TYPE_STRING
    )
    """system_mac_address provides the MAC address of the management port."""

    boot_time: datetime = betterproto.message_field(20)
    """boot_time indicates when the device was last booted."""

    streaming_status: "StreamingStatus" = betterproto.enum_field(30)
    """
    streaming_status is the status of telemetry streaming for this device.
    """

    extended_attributes: "ExtendedAttributes" = betterproto.message_field(31)
    """
    extended_attributes wraps any additional, potentially non-standard,
    features or attributes that the device reports.
    """


@dataclass(eq=False, repr=False)
class ProvisionedDevice(betterproto.Message):
    """
    ProvisionedDevice describes the provisioning status of an onboarded device
    if the onboarded device is configured for provisioning.
    """

    key: "DeviceKey" = betterproto.message_field(1)
    """key uniquely identifies the device."""

    status: "ProvisioningStatus" = betterproto.enum_field(2)
    """status describes the onboarded device's provisioning status."""

    error: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)
    """
    error is the error that caused status to become
    PROVISIONING_STATUS_FAILURE.
    """

    ztp_mode: Optional[bool] = betterproto.message_field(4, wraps=betterproto.TYPE_BOOL)
    """ztp_mode indicates whether the device is in ZTP mode."""

    ip_address: "___fmp__.IpAddress" = betterproto.message_field(5)
    """
    ip_address is the current (post-provisioning) IP address of the device.
    """

    provisioning_group_name: Optional[str] = betterproto.message_field(
        6, wraps=betterproto.TYPE_STRING
    )
    """
    provisioning_group_name is the name of the group (also known as a
    container) to which the device belongs. Any provisioning operation
    performed on this group will also be performed on this device. If the
    device is not yet provisioned, this will not be set. Once it is
    provisioned, this will be set to "undefined_container" which indicates that
    the device does not yet belong to a group. At this point, a user may set it
    to an existing group.
    """


@dataclass(eq=False, repr=False)
class DeviceRequest(betterproto.Message):
    key: "DeviceKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a Device instance to retrieve. This value must be
    populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceResponse(betterproto.Message):
    value: "Device" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the Device
    instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceStreamRequest(betterproto.Message):
    partial_eq_filter: List["Device"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class DeviceStreamResponse(betterproto.Message):
    value: "Device" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """Time holds the timestamp of this Device's last modification."""

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the Device value in this response should be
    considered. Under non-subscribe requests, this value should always be
    INITIAL. In a subscription, once all initial data is streamed and the
    client begins to receive modification updates, you should not see INITIAL
    again.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningRequest(betterproto.Message):
    key: "UuidKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a DeviceDecommissioning instance to retrieve. This
    value must be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningResponse(betterproto.Message):
    value: "DeviceDecommissioning" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    DeviceDecommissioning instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningStreamRequest(betterproto.Message):
    partial_eq_filter: List["DeviceDecommissioning"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningStreamResponse(betterproto.Message):
    value: "DeviceDecommissioning" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time holds the timestamp of this DeviceDecommissioning's last modification.
    """

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the DeviceDecommissioning value in this response
    should be considered. Under non-subscribe requests, this value should
    always be INITIAL. In a subscription, once all initial data is streamed and
    the client begins to receive modification updates, you should not see
    INITIAL again.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigRequest(betterproto.Message):
    key: "UuidKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a DeviceDecommissioningConfig instance to retrieve.
    This value must be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigResponse(betterproto.Message):
    value: "DeviceDecommissioningConfig" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    DeviceDecommissioningConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigStreamRequest(betterproto.Message):
    partial_eq_filter: List["DeviceDecommissioningConfig"] = betterproto.message_field(
        1
    )
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigStreamResponse(betterproto.Message):
    value: "DeviceDecommissioningConfig" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time holds the timestamp of this DeviceDecommissioningConfig's last
    modification.
    """

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the DeviceDecommissioningConfig value in this
    response should be considered. Under non-subscribe requests, this value
    should always be INITIAL. In a subscription, once all initial data is
    streamed and the client begins to receive modification updates, you should
    not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigSetRequest(betterproto.Message):
    value: "DeviceDecommissioningConfig" = betterproto.message_field(1)
    """
    DeviceDecommissioningConfig carries the value to set into the datastore.
    See the documentation on the DeviceDecommissioningConfig struct for which
    fields are required.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigSetResponse(betterproto.Message):
    value: "DeviceDecommissioningConfig" = betterproto.message_field(1)
    """
    Value carries all the values given in the
    DeviceDecommissioningConfigSetRequest as well as any server-generated
    values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    creation. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigDeleteRequest(betterproto.Message):
    key: "UuidKey" = betterproto.message_field(1)
    """
    Key indicates which DeviceDecommissioningConfig instance to remove. This
    field must always be set.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigDeleteResponse(betterproto.Message):
    key: "UuidKey" = betterproto.message_field(1)
    """
    Key echoes back the key of the deleted DeviceDecommissioningConfig
    instance.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    deletion. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigDeleteAllRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigDeleteAllResponse(betterproto.Message):
    type: "___fmp__.DeleteError" = betterproto.enum_field(1)
    """This describes the class of delete error."""

    error: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "UuidKey" = betterproto.message_field(3)
    """
    This is the key of the DeviceDecommissioningConfig instance that failed to
    be deleted.
    """

    time: datetime = betterproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class DeviceOnboardingRequest(betterproto.Message):
    key: "UuidKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a DeviceOnboarding instance to retrieve. This value
    must be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingResponse(betterproto.Message):
    value: "DeviceOnboarding" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    DeviceOnboarding instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingStreamRequest(betterproto.Message):
    partial_eq_filter: List["DeviceOnboarding"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingStreamResponse(betterproto.Message):
    value: "DeviceOnboarding" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time holds the timestamp of this DeviceOnboarding's last modification.
    """

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the DeviceOnboarding value in this response should
    be considered. Under non-subscribe requests, this value should always be
    INITIAL. In a subscription, once all initial data is streamed and the
    client begins to receive modification updates, you should not see INITIAL
    again.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigRequest(betterproto.Message):
    key: "UuidKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a DeviceOnboardingConfig instance to retrieve. This
    value must be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigResponse(betterproto.Message):
    value: "DeviceOnboardingConfig" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    DeviceOnboardingConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigStreamRequest(betterproto.Message):
    partial_eq_filter: List["DeviceOnboardingConfig"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigStreamResponse(betterproto.Message):
    value: "DeviceOnboardingConfig" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time holds the timestamp of this DeviceOnboardingConfig's last
    modification.
    """

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the DeviceOnboardingConfig value in this response
    should be considered. Under non-subscribe requests, this value should
    always be INITIAL. In a subscription, once all initial data is streamed and
    the client begins to receive modification updates, you should not see
    INITIAL again.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigSetRequest(betterproto.Message):
    value: "DeviceOnboardingConfig" = betterproto.message_field(1)
    """
    DeviceOnboardingConfig carries the value to set into the datastore. See the
    documentation on the DeviceOnboardingConfig struct for which fields are
    required.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigSetResponse(betterproto.Message):
    value: "DeviceOnboardingConfig" = betterproto.message_field(1)
    """
    Value carries all the values given in the DeviceOnboardingConfigSetRequest
    as well as any server-generated values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    creation. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigDeleteRequest(betterproto.Message):
    key: "UuidKey" = betterproto.message_field(1)
    """
    Key indicates which DeviceOnboardingConfig instance to remove. This field
    must always be set.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigDeleteResponse(betterproto.Message):
    key: "UuidKey" = betterproto.message_field(1)
    """
    Key echoes back the key of the deleted DeviceOnboardingConfig instance.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    deletion. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigDeleteAllRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigDeleteAllResponse(betterproto.Message):
    type: "___fmp__.DeleteError" = betterproto.enum_field(1)
    """This describes the class of delete error."""

    error: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "UuidKey" = betterproto.message_field(3)
    """
    This is the key of the DeviceOnboardingConfig instance that failed to be
    deleted.
    """

    time: datetime = betterproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class ProvisionedDeviceRequest(betterproto.Message):
    key: "DeviceKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a ProvisionedDevice instance to retrieve. This
    value must be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class ProvisionedDeviceResponse(betterproto.Message):
    value: "ProvisionedDevice" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    ProvisionedDevice instance in this response.
    """


@dataclass(eq=False, repr=False)
class ProvisionedDeviceStreamRequest(betterproto.Message):
    partial_eq_filter: List["ProvisionedDevice"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class ProvisionedDeviceStreamResponse(betterproto.Message):
    value: "ProvisionedDevice" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time holds the timestamp of this ProvisionedDevice's last modification.
    """

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the ProvisionedDevice value in this response should
    be considered. Under non-subscribe requests, this value should always be
    INITIAL. In a subscription, once all initial data is streamed and the
    client begins to receive modification updates, you should not see INITIAL
    again.
    """


class DeviceServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        device_request: "DeviceRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceService/GetOne",
            device_request,
            DeviceResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        device_stream_request: "DeviceStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceService/GetAll",
            device_stream_request,
            DeviceStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        device_stream_request: "DeviceStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceService/Subscribe",
            device_stream_request,
            DeviceStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DeviceDecommissioningServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        device_decommissioning_request: "DeviceDecommissioningRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceDecommissioningResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceDecommissioningService/GetOne",
            device_decommissioning_request,
            DeviceDecommissioningResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        device_decommissioning_stream_request: "DeviceDecommissioningStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceDecommissioningStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceDecommissioningService/GetAll",
            device_decommissioning_stream_request,
            DeviceDecommissioningStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        device_decommissioning_stream_request: "DeviceDecommissioningStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceDecommissioningStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceDecommissioningService/Subscribe",
            device_decommissioning_stream_request,
            DeviceDecommissioningStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DeviceDecommissioningConfigServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        device_decommissioning_config_request: "DeviceDecommissioningConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceDecommissioningConfigResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceDecommissioningConfigService/GetOne",
            device_decommissioning_config_request,
            DeviceDecommissioningConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        device_decommissioning_config_stream_request: "DeviceDecommissioningConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceDecommissioningConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceDecommissioningConfigService/GetAll",
            device_decommissioning_config_stream_request,
            DeviceDecommissioningConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        device_decommissioning_config_stream_request: "DeviceDecommissioningConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceDecommissioningConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceDecommissioningConfigService/Subscribe",
            device_decommissioning_config_stream_request,
            DeviceDecommissioningConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        device_decommissioning_config_set_request: "DeviceDecommissioningConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceDecommissioningConfigSetResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceDecommissioningConfigService/Set",
            device_decommissioning_config_set_request,
            DeviceDecommissioningConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete(
        self,
        device_decommissioning_config_delete_request: "DeviceDecommissioningConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceDecommissioningConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceDecommissioningConfigService/Delete",
            device_decommissioning_config_delete_request,
            DeviceDecommissioningConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_all(
        self,
        device_decommissioning_config_delete_all_request: "DeviceDecommissioningConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceDecommissioningConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceDecommissioningConfigService/DeleteAll",
            device_decommissioning_config_delete_all_request,
            DeviceDecommissioningConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DeviceOnboardingServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        device_onboarding_request: "DeviceOnboardingRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceOnboardingResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceOnboardingService/GetOne",
            device_onboarding_request,
            DeviceOnboardingResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        device_onboarding_stream_request: "DeviceOnboardingStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceOnboardingStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceOnboardingService/GetAll",
            device_onboarding_stream_request,
            DeviceOnboardingStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        device_onboarding_stream_request: "DeviceOnboardingStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceOnboardingStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceOnboardingService/Subscribe",
            device_onboarding_stream_request,
            DeviceOnboardingStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DeviceOnboardingConfigServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        device_onboarding_config_request: "DeviceOnboardingConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceOnboardingConfigResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceOnboardingConfigService/GetOne",
            device_onboarding_config_request,
            DeviceOnboardingConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        device_onboarding_config_stream_request: "DeviceOnboardingConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceOnboardingConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceOnboardingConfigService/GetAll",
            device_onboarding_config_stream_request,
            DeviceOnboardingConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        device_onboarding_config_stream_request: "DeviceOnboardingConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceOnboardingConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceOnboardingConfigService/Subscribe",
            device_onboarding_config_stream_request,
            DeviceOnboardingConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        device_onboarding_config_set_request: "DeviceOnboardingConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceOnboardingConfigSetResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceOnboardingConfigService/Set",
            device_onboarding_config_set_request,
            DeviceOnboardingConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete(
        self,
        device_onboarding_config_delete_request: "DeviceOnboardingConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceOnboardingConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceOnboardingConfigService/Delete",
            device_onboarding_config_delete_request,
            DeviceOnboardingConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_all(
        self,
        device_onboarding_config_delete_all_request: "DeviceOnboardingConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceOnboardingConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceOnboardingConfigService/DeleteAll",
            device_onboarding_config_delete_all_request,
            DeviceOnboardingConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class ProvisionedDeviceServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        provisioned_device_request: "ProvisionedDeviceRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ProvisionedDeviceResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.ProvisionedDeviceService/GetOne",
            provisioned_device_request,
            ProvisionedDeviceResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        provisioned_device_stream_request: "ProvisionedDeviceStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ProvisionedDeviceStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.ProvisionedDeviceService/GetAll",
            provisioned_device_stream_request,
            ProvisionedDeviceStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        provisioned_device_stream_request: "ProvisionedDeviceStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ProvisionedDeviceStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.ProvisionedDeviceService/Subscribe",
            provisioned_device_stream_request,
            ProvisionedDeviceStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DeviceServiceBase(ServiceBase):
    async def get_one(self, device_request: "DeviceRequest") -> "DeviceResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, device_stream_request: "DeviceStreamRequest"
    ) -> AsyncIterator["DeviceStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeviceStreamResponse()

    async def subscribe(
        self, device_stream_request: "DeviceStreamRequest"
    ) -> AsyncIterator["DeviceStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeviceStreamResponse()

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[DeviceRequest, DeviceResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self, stream: "grpclib.server.Stream[DeviceStreamRequest, DeviceStreamResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self, stream: "grpclib.server.Stream[DeviceStreamRequest, DeviceStreamResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.inventory.v1.DeviceService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceRequest,
                DeviceResponse,
            ),
            "/arista.inventory.v1.DeviceService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceStreamRequest,
                DeviceStreamResponse,
            ),
            "/arista.inventory.v1.DeviceService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceStreamRequest,
                DeviceStreamResponse,
            ),
        }


class DeviceDecommissioningServiceBase(ServiceBase):
    async def get_one(
        self, device_decommissioning_request: "DeviceDecommissioningRequest"
    ) -> "DeviceDecommissioningResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self,
        device_decommissioning_stream_request: "DeviceDecommissioningStreamRequest",
    ) -> AsyncIterator["DeviceDecommissioningStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeviceDecommissioningStreamResponse()

    async def subscribe(
        self,
        device_decommissioning_stream_request: "DeviceDecommissioningStreamRequest",
    ) -> AsyncIterator["DeviceDecommissioningStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeviceDecommissioningStreamResponse()

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningRequest, DeviceDecommissioningResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningStreamRequest, DeviceDecommissioningStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningStreamRequest, DeviceDecommissioningStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.inventory.v1.DeviceDecommissioningService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceDecommissioningRequest,
                DeviceDecommissioningResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceDecommissioningStreamRequest,
                DeviceDecommissioningStreamResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceDecommissioningStreamRequest,
                DeviceDecommissioningStreamResponse,
            ),
        }


class DeviceDecommissioningConfigServiceBase(ServiceBase):
    async def get_one(
        self,
        device_decommissioning_config_request: "DeviceDecommissioningConfigRequest",
    ) -> "DeviceDecommissioningConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self,
        device_decommissioning_config_stream_request: "DeviceDecommissioningConfigStreamRequest",
    ) -> AsyncIterator["DeviceDecommissioningConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeviceDecommissioningConfigStreamResponse()

    async def subscribe(
        self,
        device_decommissioning_config_stream_request: "DeviceDecommissioningConfigStreamRequest",
    ) -> AsyncIterator["DeviceDecommissioningConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeviceDecommissioningConfigStreamResponse()

    async def set(
        self,
        device_decommissioning_config_set_request: "DeviceDecommissioningConfigSetRequest",
    ) -> "DeviceDecommissioningConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self,
        device_decommissioning_config_delete_request: "DeviceDecommissioningConfigDeleteRequest",
    ) -> "DeviceDecommissioningConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self,
        device_decommissioning_config_delete_all_request: "DeviceDecommissioningConfigDeleteAllRequest",
    ) -> AsyncIterator["DeviceDecommissioningConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeviceDecommissioningConfigDeleteAllResponse()

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningConfigRequest, DeviceDecommissioningConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningConfigStreamRequest, DeviceDecommissioningConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningConfigStreamRequest, DeviceDecommissioningConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningConfigSetRequest, DeviceDecommissioningConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningConfigDeleteRequest, DeviceDecommissioningConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningConfigDeleteAllRequest, DeviceDecommissioningConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.inventory.v1.DeviceDecommissioningConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceDecommissioningConfigRequest,
                DeviceDecommissioningConfigResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceDecommissioningConfigStreamRequest,
                DeviceDecommissioningConfigStreamResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceDecommissioningConfigStreamRequest,
                DeviceDecommissioningConfigStreamResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceDecommissioningConfigSetRequest,
                DeviceDecommissioningConfigSetResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceDecommissioningConfigDeleteRequest,
                DeviceDecommissioningConfigDeleteResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceDecommissioningConfigDeleteAllRequest,
                DeviceDecommissioningConfigDeleteAllResponse,
            ),
        }


class DeviceOnboardingServiceBase(ServiceBase):
    async def get_one(
        self, device_onboarding_request: "DeviceOnboardingRequest"
    ) -> "DeviceOnboardingResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, device_onboarding_stream_request: "DeviceOnboardingStreamRequest"
    ) -> AsyncIterator["DeviceOnboardingStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeviceOnboardingStreamResponse()

    async def subscribe(
        self, device_onboarding_stream_request: "DeviceOnboardingStreamRequest"
    ) -> AsyncIterator["DeviceOnboardingStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeviceOnboardingStreamResponse()

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingRequest, DeviceOnboardingResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingStreamRequest, DeviceOnboardingStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingStreamRequest, DeviceOnboardingStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.inventory.v1.DeviceOnboardingService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceOnboardingRequest,
                DeviceOnboardingResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceOnboardingStreamRequest,
                DeviceOnboardingStreamResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceOnboardingStreamRequest,
                DeviceOnboardingStreamResponse,
            ),
        }


class DeviceOnboardingConfigServiceBase(ServiceBase):
    async def get_one(
        self, device_onboarding_config_request: "DeviceOnboardingConfigRequest"
    ) -> "DeviceOnboardingConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self,
        device_onboarding_config_stream_request: "DeviceOnboardingConfigStreamRequest",
    ) -> AsyncIterator["DeviceOnboardingConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeviceOnboardingConfigStreamResponse()

    async def subscribe(
        self,
        device_onboarding_config_stream_request: "DeviceOnboardingConfigStreamRequest",
    ) -> AsyncIterator["DeviceOnboardingConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeviceOnboardingConfigStreamResponse()

    async def set(
        self, device_onboarding_config_set_request: "DeviceOnboardingConfigSetRequest"
    ) -> "DeviceOnboardingConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self,
        device_onboarding_config_delete_request: "DeviceOnboardingConfigDeleteRequest",
    ) -> "DeviceOnboardingConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self,
        device_onboarding_config_delete_all_request: "DeviceOnboardingConfigDeleteAllRequest",
    ) -> AsyncIterator["DeviceOnboardingConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeviceOnboardingConfigDeleteAllResponse()

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingConfigRequest, DeviceOnboardingConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingConfigStreamRequest, DeviceOnboardingConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingConfigStreamRequest, DeviceOnboardingConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingConfigSetRequest, DeviceOnboardingConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingConfigDeleteRequest, DeviceOnboardingConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingConfigDeleteAllRequest, DeviceOnboardingConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.inventory.v1.DeviceOnboardingConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceOnboardingConfigRequest,
                DeviceOnboardingConfigResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceOnboardingConfigStreamRequest,
                DeviceOnboardingConfigStreamResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceOnboardingConfigStreamRequest,
                DeviceOnboardingConfigStreamResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceOnboardingConfigSetRequest,
                DeviceOnboardingConfigSetResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceOnboardingConfigDeleteRequest,
                DeviceOnboardingConfigDeleteResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceOnboardingConfigDeleteAllRequest,
                DeviceOnboardingConfigDeleteAllResponse,
            ),
        }


class ProvisionedDeviceServiceBase(ServiceBase):
    async def get_one(
        self, provisioned_device_request: "ProvisionedDeviceRequest"
    ) -> "ProvisionedDeviceResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, provisioned_device_stream_request: "ProvisionedDeviceStreamRequest"
    ) -> AsyncIterator["ProvisionedDeviceStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ProvisionedDeviceStreamResponse()

    async def subscribe(
        self, provisioned_device_stream_request: "ProvisionedDeviceStreamRequest"
    ) -> AsyncIterator["ProvisionedDeviceStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ProvisionedDeviceStreamResponse()

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[ProvisionedDeviceRequest, ProvisionedDeviceResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[ProvisionedDeviceStreamRequest, ProvisionedDeviceStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[ProvisionedDeviceStreamRequest, ProvisionedDeviceStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.inventory.v1.ProvisionedDeviceService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                ProvisionedDeviceRequest,
                ProvisionedDeviceResponse,
            ),
            "/arista.inventory.v1.ProvisionedDeviceService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                ProvisionedDeviceStreamRequest,
                ProvisionedDeviceStreamResponse,
            ),
            "/arista.inventory.v1.ProvisionedDeviceService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                ProvisionedDeviceStreamRequest,
                ProvisionedDeviceStreamResponse,
            ),
        }
