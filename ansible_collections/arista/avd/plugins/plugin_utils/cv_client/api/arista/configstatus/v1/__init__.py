# Copyright (c) 2023 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: arista/configstatus.v1/configstatus.proto, arista/configstatus.v1/services.gen.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ... import (
    subscriptions as __subscriptions__,
    time as __time__,
)


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class ErrorCode(betterproto.Enum):
    """
    ErrorCode indicates warnings and errors produced during computing config
    """

    ERROR_CODE_UNSPECIFIED = 0
    ERROR_CODE_DEVICE_WARNING = 1
    """DEVICE_WARNING indicates device warning"""

    ERROR_CODE_DEVICE_ERROR = 2
    """DEVICE_ERROR indicates device error"""

    ERROR_CODE_UNREACHABLE_DEVICE = 3
    """UNREACHABLE_DEVICE indicates the device cannot be reached"""

    ERROR_CODE_CONFIG_FILTER_ERROR = 4
    """
    CONFIG_FILTER_ERROR indicates error from partial config management filters
    """

    ERROR_CODE_INTERNAL = 5
    """INTERNAL indicates internal errors"""


class DiffOp(betterproto.Enum):
    """
    DiffOp is the operation to a line from one side of diff to get to another
    """

    DIFF_OP_UNSPECIFIED = 0
    DIFF_OP_NOP = 1
    """NOP indicates no change. A and B are identical at this line"""

    DIFF_OP_IGNORE = 2
    """
    IGNORE indicates a line that's ignored in either A or B. One of a_line_num
    or b_line_num will be -1
    """

    DIFF_OP_ADD = 3
    """ADD is an addition of a line from A"""

    DIFF_OP_DELETE = 4
    """DELETE is deletion of a line from B"""

    DIFF_OP_CHANGE = 5
    """CHANGE is a modification to a line in A"""


class ConfigFilterCode(betterproto.Enum):
    """ConfigFilterCode indicates if a config line matches PCM filter(s)"""

    CONFIG_FILTER_CODE_UNSPECIFIED = 0
    """
    UNSPECIFIED indicates config line did not match any partial config
    management (PCM) filter
    """

    CONFIG_FILTER_CODE_MANAGED_LINE = 1
    """
    MANAGED_LINE indicates config line matches managed PCM filter hence is
    managed
    """

    CONFIG_FILTER_CODE_UNMANAGED_LINE = 2
    """
    UNMANAGED_LINE indicates config line matches unmanaged PCM filter hence is
    not managed
    """


class ConfigSyncCode(betterproto.Enum):
    """ConfigSyncCode indicates config synchronization status"""

    CONFIG_SYNC_CODE_UNSPECIFIED = 0
    CONFIG_SYNC_CODE_IN_SYNC = 1
    """IN_SYNC indicates designed config and running config are identical"""

    CONFIG_SYNC_CODE_OUT_OF_SYNC = 2
    """
    OUT_OF_SYNC indicates designed config and running config are not identical
    """


class ConfigSourceType(betterproto.Enum):
    """
    ConfigSourceType indicates the type of source for the proposed/designed
    configuration for the device
    """

    CONFIG_SOURCE_TYPE_UNSPECIFIED = 0
    CONFIG_SOURCE_TYPE_NETWORK_PROVISIONING_CONFIGLET = 1
    """
    CONFIG_SOURCE_TYPE_NETWORK_PROVISIONING_CONFIGLET - configlet created from
    the network provisioning workflow.
    """

    CONFIG_SOURCE_TYPE_STUDIO = 2
    """CONFIG_SOURCE_TYPE_STUDIO - config generated from a regular studio"""

    CONFIG_SOURCE_TYPE_STUDIO_STATIC = 3
    """
    SCONFIG_SOURCE_TYPE_STUDIO_STATIC - static config from studios framework
    """


class ConfigType(betterproto.Enum):
    CONFIG_TYPE_UNSPECIFIED = 0
    CONFIG_TYPE_RUNNING_CONFIG = 1
    CONFIG_TYPE_DESIGNED_CONFIG = 2


@dataclass(eq=False, repr=False)
class ConfigError(betterproto.Message):
    """
    ConfigError represents errors reported by CVP when handling device
    configuration
    """

    error_code: "ErrorCode" = betterproto.enum_field(1)
    error_msg: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    line_num: Optional[int] = betterproto.message_field(3, wraps=betterproto.TYPE_INT32)
    """Line_num represents line number, if any"""

    configlet_name: Optional[str] = betterproto.message_field(
        4, wraps=betterproto.TYPE_STRING
    )
    """
    Configlet_name represents the originating configlet name. Configlet_name
    and line_num point to the line where config warning or config error
    originate.
    """


@dataclass(eq=False, repr=False)
class ConfigErrors(betterproto.Message):
    values: List["ConfigError"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class DiffEntry(betterproto.Message):
    """DiffEntry represents one entry in a Diff"""

    op: "DiffOp" = betterproto.enum_field(1)
    a_line_num: Optional[int] = betterproto.message_field(
        2, wraps=betterproto.TYPE_INT32
    )
    """line number in A this diff applies to"""

    b_line_num: Optional[int] = betterproto.message_field(
        3, wraps=betterproto.TYPE_INT32
    )
    """line number in B this diff applies to"""

    b_parent_line_num: Optional[int] = betterproto.message_field(
        4, wraps=betterproto.TYPE_INT32
    )
    """line number of the parent command in B"""

    a_line: Optional[str] = betterproto.message_field(5, wraps=betterproto.TYPE_STRING)
    """content of config line in A"""

    b_line: Optional[str] = betterproto.message_field(6, wraps=betterproto.TYPE_STRING)
    """content of config line in B"""

    a_filter_code: "ConfigFilterCode" = betterproto.enum_field(7)
    """Config filter code of the line in A"""

    b_filter_code: "ConfigFilterCode" = betterproto.enum_field(8)
    """Config filter code of the line in B"""

    a_parent_line_num: Optional[int] = betterproto.message_field(
        9, wraps=betterproto.TYPE_INT32
    )
    """line number of the parent command in A"""


@dataclass(eq=False, repr=False)
class DiffEntries(betterproto.Message):
    """DiffEntries indicates potential multiple lines of config diff"""

    values: List["DiffEntry"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ConfigSource(betterproto.Message):
    """
    ConfigSource describes an individual source of the proposed/designed config
    """

    source_type: "ConfigSourceType" = betterproto.enum_field(1)
    source_id: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """
    source_id identifier to distinguish between multiple instances of the
    source type source_id is :        configlet name for
    CONFIG_SOURCE_TYPE_NETWORK_PROVISIONING_CONFIGLET    studio id for
    CONFIG_SOURCE_TYPE_STUDIO configlet id for CONFIG_SOURCE_TYPE_STUDIO_STATIC
    """


@dataclass(eq=False, repr=False)
class ConfigSources(betterproto.Message):
    """ConfigSources is the list of sources of the proposed/designed config"""

    values: List["ConfigSource"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ConfigSummary(betterproto.Message):
    """ConfigSummary represents device configuration summary."""

    sync: "ConfigSyncCode" = betterproto.enum_field(1)
    nop_lines: Optional[int] = betterproto.message_field(
        2, wraps=betterproto.TYPE_INT32
    )
    """Number of lines with code no-operation"""

    ignored_lines: Optional[int] = betterproto.message_field(
        3, wraps=betterproto.TYPE_INT32
    )
    """Number of lines with code IGNORE"""

    added_lines: Optional[int] = betterproto.message_field(
        4, wraps=betterproto.TYPE_INT32
    )
    """Number of lines with code ADD"""

    deleted_lines: Optional[int] = betterproto.message_field(
        5, wraps=betterproto.TYPE_INT32
    )
    """Number of lines with code DELETE"""

    changed_lines: Optional[int] = betterproto.message_field(
        6, wraps=betterproto.TYPE_INT32
    )
    """Number of lines with code CHANGE"""

    designed_config_errors: Optional[int] = betterproto.message_field(
        7, wraps=betterproto.TYPE_INT32
    )
    """Number of designed config errors"""

    designed_config_warnings: Optional[int] = betterproto.message_field(
        8, wraps=betterproto.TYPE_INT32
    )
    """Number of designed config warnings"""

    running_config_update_time: datetime = betterproto.message_field(9)
    """Timestamp at which running config is updated"""

    designed_config_update_time: datetime = betterproto.message_field(10)
    """Timestamp at which designed config is updated"""

    running_config_uri: Optional[str] = betterproto.message_field(
        11, wraps=betterproto.TYPE_STRING
    )
    """
    The HTTP URI client can use to GET running config and associated errors
    """

    designed_config_uri: Optional[str] = betterproto.message_field(
        12, wraps=betterproto.TYPE_STRING
    )
    """
    The HTTP URI client can use to GET designed config and associated errors
    """

    diff_uri: Optional[str] = betterproto.message_field(
        13, wraps=betterproto.TYPE_STRING
    )
    """The HTTP URI client can use to GET config diff and associated errors"""

    digest: Optional[str] = betterproto.message_field(14, wraps=betterproto.TYPE_STRING)
    """Digest (SHA-256) of the config diff."""


@dataclass(eq=False, repr=False)
class ConfigKey(betterproto.Message):
    """ConfigKey uniquely identifies a config request."""

    device_id: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    """Device_id is the serial number of the device"""

    type: "ConfigType" = betterproto.enum_field(2)
    """Type describes the config type"""


@dataclass(eq=False, repr=False)
class Configuration(betterproto.Message):
    """Configuration represents device's CLI configuration"""

    key: "ConfigKey" = betterproto.message_field(1)
    uri: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """
    Uri represents the HTTP URI client can use to GET config body and
    associated errors
    """


@dataclass(eq=False, repr=False)
class ConfigDiffKey(betterproto.Message):
    """ConfigDiffKey uniquely identifies a configuration diff request"""

    a_device_id: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    """
    A_device_id is the serial number of the device on A side (left hand side)
    """

    a_type: "ConfigType" = betterproto.enum_field(2)
    """A_type is the config type on A side (left hand side)"""

    a_time: datetime = betterproto.message_field(3)
    """
    A_time is the time at which to fetch config on A side (left hand side)
    """

    b_device_id: Optional[str] = betterproto.message_field(
        4, wraps=betterproto.TYPE_STRING
    )
    """
    B_device_id is the serial number of the device on B side (right hand side)
    """

    b_type: "ConfigType" = betterproto.enum_field(5)
    """B_type is the config type on B side (right hand side)"""

    b_time: datetime = betterproto.message_field(6)
    """
    B_time is the time at which to fetch config on B side (right hand side)
    """


@dataclass(eq=False, repr=False)
class ConfigDiff(betterproto.Message):
    key: "ConfigDiffKey" = betterproto.message_field(1)
    """Key represents config diff key"""

    uri: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """
    Uri represents the HTTP URI client can use to GET config diff and
    associated errors
    """


@dataclass(eq=False, repr=False)
class SummaryKey(betterproto.Message):
    """SummaryKey uniquely identifies a device summary request"""

    device_id: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    """Device_id is the serial number of the device"""


@dataclass(eq=False, repr=False)
class Summary(betterproto.Message):
    key: "SummaryKey" = betterproto.message_field(1)
    summary: "ConfigSummary" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class SecurityProfile(betterproto.Message):
    """
    SecurityProfile holds the EOS configuration for the security profile.
    """

    key: "ConfigKey" = betterproto.message_field(1)
    """key uniquely identifies the configuration"""

    config: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """config describes the security profile config body"""


@dataclass(eq=False, repr=False)
class SecurityProfileComplianceSummary(betterproto.Message):
    """
    SecurityProfileComplianceSummary holds the compliance summary for security
    profile configuration.
    """

    sync: "ConfigSyncCode" = betterproto.enum_field(1)
    nop_lines: Optional[int] = betterproto.message_field(
        2, wraps=betterproto.TYPE_INT32
    )
    """nop_lines is the number of lines with code no-operation"""

    ignored_lines: Optional[int] = betterproto.message_field(
        3, wraps=betterproto.TYPE_INT32
    )
    """ignored_lines is the number of lines with code IGNORE"""

    added_lines: Optional[int] = betterproto.message_field(
        4, wraps=betterproto.TYPE_INT32
    )
    """added_lines is the number of lines with code ADD"""

    deleted_lines: Optional[int] = betterproto.message_field(
        5, wraps=betterproto.TYPE_INT32
    )
    """deleted_lines is the number of lines with code DELETE"""

    changed_lines: Optional[int] = betterproto.message_field(
        6, wraps=betterproto.TYPE_INT32
    )
    """changed_lines is the Number of lines with code CHANGE"""

    digest: Optional[str] = betterproto.message_field(7, wraps=betterproto.TYPE_STRING)
    """
    digest is the digest (SHA-256 hash) of the security profile configuration
    diff
    """

    running_config_update_time: datetime = betterproto.message_field(8)
    """
    running_config_update_time is the timestamp at which running security
    profile or running config is updated
    """

    designed_config_update_time: datetime = betterproto.message_field(9)
    """
    designed_config_update_time is the timestamp at which designed security
    profile or designed config is updated
    """


@dataclass(eq=False, repr=False)
class SecurityProfileDiffSummary(betterproto.Message):
    """
    SecurityProfileDiffSummary holds device compliance summary w.r.t security
    profile.
    """

    key: "SummaryKey" = betterproto.message_field(1)
    """key uniquely identifies the Summary"""

    summary: "SecurityProfileComplianceSummary" = betterproto.message_field(2)
    """summary is the security profile configuration compliance summary"""


@dataclass(eq=False, repr=False)
class SecurityProfileDiff(betterproto.Message):
    """SecurityProfileDiff holds the security profile configuration diff."""

    key: "ConfigDiffKey" = betterproto.message_field(1)
    """key represents security profile config diff key"""

    diff: "DiffEntries" = betterproto.message_field(2)
    """diff represents diff entries"""


@dataclass(eq=False, repr=False)
class ConfigDiffRequest(betterproto.Message):
    key: "ConfigDiffKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a ConfigDiff instance to retrieve. This value must
    be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class ConfigDiffResponse(betterproto.Message):
    value: "ConfigDiff" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the ConfigDiff
    instance in this response.
    """


@dataclass(eq=False, repr=False)
class ConfigDiffStreamRequest(betterproto.Message):
    partial_eq_filter: List["ConfigDiff"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class ConfigDiffStreamResponse(betterproto.Message):
    value: "ConfigDiff" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """Time holds the timestamp of this ConfigDiff's last modification."""

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the ConfigDiff value in this response should be
    considered. Under non-subscribe requests, this value should always be
    INITIAL. In a subscription, once all initial data is streamed and the
    client begins to receive modification updates, you should not see INITIAL
    again.
    """


@dataclass(eq=False, repr=False)
class ConfigurationRequest(betterproto.Message):
    key: "ConfigKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a Configuration instance to retrieve. This value
    must be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class ConfigurationResponse(betterproto.Message):
    value: "Configuration" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    Configuration instance in this response.
    """


@dataclass(eq=False, repr=False)
class ConfigurationStreamRequest(betterproto.Message):
    partial_eq_filter: List["Configuration"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class ConfigurationStreamResponse(betterproto.Message):
    value: "Configuration" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """Time holds the timestamp of this Configuration's last modification."""

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the Configuration value in this response should be
    considered. Under non-subscribe requests, this value should always be
    INITIAL. In a subscription, once all initial data is streamed and the
    client begins to receive modification updates, you should not see INITIAL
    again.
    """


@dataclass(eq=False, repr=False)
class SecurityProfileRequest(betterproto.Message):
    key: "ConfigKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a SecurityProfile instance to retrieve. This value
    must be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class SecurityProfileResponse(betterproto.Message):
    value: "SecurityProfile" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    SecurityProfile instance in this response.
    """


@dataclass(eq=False, repr=False)
class SecurityProfileStreamRequest(betterproto.Message):
    partial_eq_filter: List["SecurityProfile"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class SecurityProfileStreamResponse(betterproto.Message):
    value: "SecurityProfile" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time holds the timestamp of this SecurityProfile's last modification.
    """

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the SecurityProfile value in this response should
    be considered. Under non-subscribe requests, this value should always be
    INITIAL. In a subscription, once all initial data is streamed and the
    client begins to receive modification updates, you should not see INITIAL
    again.
    """


@dataclass(eq=False, repr=False)
class SecurityProfileDiffRequest(betterproto.Message):
    key: "ConfigDiffKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a SecurityProfileDiff instance to retrieve. This
    value must be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class SecurityProfileDiffResponse(betterproto.Message):
    value: "SecurityProfileDiff" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    SecurityProfileDiff instance in this response.
    """


@dataclass(eq=False, repr=False)
class SecurityProfileDiffStreamRequest(betterproto.Message):
    partial_eq_filter: List["SecurityProfileDiff"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class SecurityProfileDiffStreamResponse(betterproto.Message):
    value: "SecurityProfileDiff" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time holds the timestamp of this SecurityProfileDiff's last modification.
    """

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the SecurityProfileDiff value in this response
    should be considered. Under non-subscribe requests, this value should
    always be INITIAL. In a subscription, once all initial data is streamed and
    the client begins to receive modification updates, you should not see
    INITIAL again.
    """


@dataclass(eq=False, repr=False)
class SecurityProfileDiffSummaryRequest(betterproto.Message):
    key: "SummaryKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a SecurityProfileDiffSummary instance to retrieve.
    This value must be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class SecurityProfileDiffSummaryResponse(betterproto.Message):
    value: "SecurityProfileDiffSummary" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    SecurityProfileDiffSummary instance in this response.
    """


@dataclass(eq=False, repr=False)
class SecurityProfileDiffSummaryStreamRequest(betterproto.Message):
    partial_eq_filter: List["SecurityProfileDiffSummary"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class SecurityProfileDiffSummaryStreamResponse(betterproto.Message):
    value: "SecurityProfileDiffSummary" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time holds the timestamp of this SecurityProfileDiffSummary's last
    modification.
    """

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the SecurityProfileDiffSummary value in this
    response should be considered. Under non-subscribe requests, this value
    should always be INITIAL. In a subscription, once all initial data is
    streamed and the client begins to receive modification updates, you should
    not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class SummaryRequest(betterproto.Message):
    key: "SummaryKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a Summary instance to retrieve. This value must be
    populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class SummaryResponse(betterproto.Message):
    value: "Summary" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the Summary
    instance in this response.
    """


@dataclass(eq=False, repr=False)
class SummaryStreamRequest(betterproto.Message):
    partial_eq_filter: List["Summary"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class SummaryStreamResponse(betterproto.Message):
    value: "Summary" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """Time holds the timestamp of this Summary's last modification."""

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the Summary value in this response should be
    considered. Under non-subscribe requests, this value should always be
    INITIAL. In a subscription, once all initial data is streamed and the
    client begins to receive modification updates, you should not see INITIAL
    again.
    """


class ConfigDiffServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        config_diff_request: "ConfigDiffRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ConfigDiffResponse":
        return await self._unary_unary(
            "/arista.configstatus.v1.ConfigDiffService/GetOne",
            config_diff_request,
            ConfigDiffResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        config_diff_stream_request: "ConfigDiffStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ConfigDiffStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.configstatus.v1.ConfigDiffService/GetAll",
            config_diff_stream_request,
            ConfigDiffStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        config_diff_stream_request: "ConfigDiffStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ConfigDiffStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.configstatus.v1.ConfigDiffService/Subscribe",
            config_diff_stream_request,
            ConfigDiffStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class ConfigurationServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        configuration_request: "ConfigurationRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ConfigurationResponse":
        return await self._unary_unary(
            "/arista.configstatus.v1.ConfigurationService/GetOne",
            configuration_request,
            ConfigurationResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        configuration_stream_request: "ConfigurationStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ConfigurationStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.configstatus.v1.ConfigurationService/GetAll",
            configuration_stream_request,
            ConfigurationStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        configuration_stream_request: "ConfigurationStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ConfigurationStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.configstatus.v1.ConfigurationService/Subscribe",
            configuration_stream_request,
            ConfigurationStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class SecurityProfileServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        security_profile_request: "SecurityProfileRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SecurityProfileResponse":
        return await self._unary_unary(
            "/arista.configstatus.v1.SecurityProfileService/GetOne",
            security_profile_request,
            SecurityProfileResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        security_profile_stream_request: "SecurityProfileStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["SecurityProfileStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.configstatus.v1.SecurityProfileService/GetAll",
            security_profile_stream_request,
            SecurityProfileStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        security_profile_stream_request: "SecurityProfileStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["SecurityProfileStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.configstatus.v1.SecurityProfileService/Subscribe",
            security_profile_stream_request,
            SecurityProfileStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class SecurityProfileDiffServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        security_profile_diff_request: "SecurityProfileDiffRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SecurityProfileDiffResponse":
        return await self._unary_unary(
            "/arista.configstatus.v1.SecurityProfileDiffService/GetOne",
            security_profile_diff_request,
            SecurityProfileDiffResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        security_profile_diff_stream_request: "SecurityProfileDiffStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["SecurityProfileDiffStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.configstatus.v1.SecurityProfileDiffService/GetAll",
            security_profile_diff_stream_request,
            SecurityProfileDiffStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        security_profile_diff_stream_request: "SecurityProfileDiffStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["SecurityProfileDiffStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.configstatus.v1.SecurityProfileDiffService/Subscribe",
            security_profile_diff_stream_request,
            SecurityProfileDiffStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class SecurityProfileDiffSummaryServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        security_profile_diff_summary_request: "SecurityProfileDiffSummaryRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SecurityProfileDiffSummaryResponse":
        return await self._unary_unary(
            "/arista.configstatus.v1.SecurityProfileDiffSummaryService/GetOne",
            security_profile_diff_summary_request,
            SecurityProfileDiffSummaryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        security_profile_diff_summary_stream_request: "SecurityProfileDiffSummaryStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["SecurityProfileDiffSummaryStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.configstatus.v1.SecurityProfileDiffSummaryService/GetAll",
            security_profile_diff_summary_stream_request,
            SecurityProfileDiffSummaryStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        security_profile_diff_summary_stream_request: "SecurityProfileDiffSummaryStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["SecurityProfileDiffSummaryStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.configstatus.v1.SecurityProfileDiffSummaryService/Subscribe",
            security_profile_diff_summary_stream_request,
            SecurityProfileDiffSummaryStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class SummaryServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        summary_request: "SummaryRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SummaryResponse":
        return await self._unary_unary(
            "/arista.configstatus.v1.SummaryService/GetOne",
            summary_request,
            SummaryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        summary_stream_request: "SummaryStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["SummaryStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.configstatus.v1.SummaryService/GetAll",
            summary_stream_request,
            SummaryStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        summary_stream_request: "SummaryStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["SummaryStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.configstatus.v1.SummaryService/Subscribe",
            summary_stream_request,
            SummaryStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class ConfigDiffServiceBase(ServiceBase):
    async def get_one(
        self, config_diff_request: "ConfigDiffRequest"
    ) -> "ConfigDiffResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, config_diff_stream_request: "ConfigDiffStreamRequest"
    ) -> AsyncIterator["ConfigDiffStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ConfigDiffStreamResponse()

    async def subscribe(
        self, config_diff_stream_request: "ConfigDiffStreamRequest"
    ) -> AsyncIterator["ConfigDiffStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ConfigDiffStreamResponse()

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[ConfigDiffRequest, ConfigDiffResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[ConfigDiffStreamRequest, ConfigDiffStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[ConfigDiffStreamRequest, ConfigDiffStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.configstatus.v1.ConfigDiffService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                ConfigDiffRequest,
                ConfigDiffResponse,
            ),
            "/arista.configstatus.v1.ConfigDiffService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                ConfigDiffStreamRequest,
                ConfigDiffStreamResponse,
            ),
            "/arista.configstatus.v1.ConfigDiffService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                ConfigDiffStreamRequest,
                ConfigDiffStreamResponse,
            ),
        }


class ConfigurationServiceBase(ServiceBase):
    async def get_one(
        self, configuration_request: "ConfigurationRequest"
    ) -> "ConfigurationResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, configuration_stream_request: "ConfigurationStreamRequest"
    ) -> AsyncIterator["ConfigurationStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ConfigurationStreamResponse()

    async def subscribe(
        self, configuration_stream_request: "ConfigurationStreamRequest"
    ) -> AsyncIterator["ConfigurationStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ConfigurationStreamResponse()

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[ConfigurationRequest, ConfigurationResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[ConfigurationStreamRequest, ConfigurationStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[ConfigurationStreamRequest, ConfigurationStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.configstatus.v1.ConfigurationService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                ConfigurationRequest,
                ConfigurationResponse,
            ),
            "/arista.configstatus.v1.ConfigurationService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                ConfigurationStreamRequest,
                ConfigurationStreamResponse,
            ),
            "/arista.configstatus.v1.ConfigurationService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                ConfigurationStreamRequest,
                ConfigurationStreamResponse,
            ),
        }


class SecurityProfileServiceBase(ServiceBase):
    async def get_one(
        self, security_profile_request: "SecurityProfileRequest"
    ) -> "SecurityProfileResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, security_profile_stream_request: "SecurityProfileStreamRequest"
    ) -> AsyncIterator["SecurityProfileStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield SecurityProfileStreamResponse()

    async def subscribe(
        self, security_profile_stream_request: "SecurityProfileStreamRequest"
    ) -> AsyncIterator["SecurityProfileStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield SecurityProfileStreamResponse()

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[SecurityProfileRequest, SecurityProfileResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[SecurityProfileStreamRequest, SecurityProfileStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[SecurityProfileStreamRequest, SecurityProfileStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.configstatus.v1.SecurityProfileService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                SecurityProfileRequest,
                SecurityProfileResponse,
            ),
            "/arista.configstatus.v1.SecurityProfileService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                SecurityProfileStreamRequest,
                SecurityProfileStreamResponse,
            ),
            "/arista.configstatus.v1.SecurityProfileService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                SecurityProfileStreamRequest,
                SecurityProfileStreamResponse,
            ),
        }


class SecurityProfileDiffServiceBase(ServiceBase):
    async def get_one(
        self, security_profile_diff_request: "SecurityProfileDiffRequest"
    ) -> "SecurityProfileDiffResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, security_profile_diff_stream_request: "SecurityProfileDiffStreamRequest"
    ) -> AsyncIterator["SecurityProfileDiffStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield SecurityProfileDiffStreamResponse()

    async def subscribe(
        self, security_profile_diff_stream_request: "SecurityProfileDiffStreamRequest"
    ) -> AsyncIterator["SecurityProfileDiffStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield SecurityProfileDiffStreamResponse()

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[SecurityProfileDiffRequest, SecurityProfileDiffResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[SecurityProfileDiffStreamRequest, SecurityProfileDiffStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[SecurityProfileDiffStreamRequest, SecurityProfileDiffStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.configstatus.v1.SecurityProfileDiffService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                SecurityProfileDiffRequest,
                SecurityProfileDiffResponse,
            ),
            "/arista.configstatus.v1.SecurityProfileDiffService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                SecurityProfileDiffStreamRequest,
                SecurityProfileDiffStreamResponse,
            ),
            "/arista.configstatus.v1.SecurityProfileDiffService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                SecurityProfileDiffStreamRequest,
                SecurityProfileDiffStreamResponse,
            ),
        }


class SecurityProfileDiffSummaryServiceBase(ServiceBase):
    async def get_one(
        self, security_profile_diff_summary_request: "SecurityProfileDiffSummaryRequest"
    ) -> "SecurityProfileDiffSummaryResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self,
        security_profile_diff_summary_stream_request: "SecurityProfileDiffSummaryStreamRequest",
    ) -> AsyncIterator["SecurityProfileDiffSummaryStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield SecurityProfileDiffSummaryStreamResponse()

    async def subscribe(
        self,
        security_profile_diff_summary_stream_request: "SecurityProfileDiffSummaryStreamRequest",
    ) -> AsyncIterator["SecurityProfileDiffSummaryStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield SecurityProfileDiffSummaryStreamResponse()

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[SecurityProfileDiffSummaryRequest, SecurityProfileDiffSummaryResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[SecurityProfileDiffSummaryStreamRequest, SecurityProfileDiffSummaryStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[SecurityProfileDiffSummaryStreamRequest, SecurityProfileDiffSummaryStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.configstatus.v1.SecurityProfileDiffSummaryService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                SecurityProfileDiffSummaryRequest,
                SecurityProfileDiffSummaryResponse,
            ),
            "/arista.configstatus.v1.SecurityProfileDiffSummaryService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                SecurityProfileDiffSummaryStreamRequest,
                SecurityProfileDiffSummaryStreamResponse,
            ),
            "/arista.configstatus.v1.SecurityProfileDiffSummaryService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                SecurityProfileDiffSummaryStreamRequest,
                SecurityProfileDiffSummaryStreamResponse,
            ),
        }


class SummaryServiceBase(ServiceBase):
    async def get_one(self, summary_request: "SummaryRequest") -> "SummaryResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, summary_stream_request: "SummaryStreamRequest"
    ) -> AsyncIterator["SummaryStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield SummaryStreamResponse()

    async def subscribe(
        self, summary_stream_request: "SummaryStreamRequest"
    ) -> AsyncIterator["SummaryStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield SummaryStreamResponse()

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[SummaryRequest, SummaryResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[SummaryStreamRequest, SummaryStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[SummaryStreamRequest, SummaryStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.configstatus.v1.SummaryService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                SummaryRequest,
                SummaryResponse,
            ),
            "/arista.configstatus.v1.SummaryService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                SummaryStreamRequest,
                SummaryStreamResponse,
            ),
            "/arista.configstatus.v1.SummaryService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                SummaryStreamRequest,
                SummaryStreamResponse,
            ),
        }
