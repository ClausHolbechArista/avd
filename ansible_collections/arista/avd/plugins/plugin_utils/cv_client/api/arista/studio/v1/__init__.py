# Copyright (c) 2023 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: arista/studio.v1/services.gen.proto, arista/studio.v1/studio.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from .... import fmp as ___fmp__
from ... import (
    subscriptions as __subscriptions__,
    time as __time__,
)
from ...workspace import v1 as __workspace_v1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class TemplateType(betterproto.Enum):
    TEMPLATE_TYPE_UNSPECIFIED = 0
    TEMPLATE_TYPE_MAKO = 1
    TEMPLATE_TYPE_JINJA = 2
    TEMPLATE_TYPE_GO = 3


class InputFieldType(betterproto.Enum):
    INPUT_FIELD_TYPE_UNSPECIFIED = 0
    INPUT_FIELD_TYPE_BOOLEAN = 1
    INPUT_FIELD_TYPE_INTEGER = 2
    INPUT_FIELD_TYPE_FLOAT = 3
    INPUT_FIELD_TYPE_STRING = 4
    INPUT_FIELD_TYPE_GROUP = 5
    INPUT_FIELD_TYPE_COLLECTION = 6
    INPUT_FIELD_TYPE_RESOLVER = 7


class ResolverFieldInputMode(betterproto.Enum):
    RESOLVER_FIELD_INPUT_MODE_UNSPECIFIED = 0
    RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG = 1
    RESOLVER_FIELD_INPUT_MODE_SINGLE_INTERFACE_TAG = 2
    RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG = 3
    RESOLVER_FIELD_INPUT_MODE_MULTI_INTERFACE_TAG = 4


class ResolverFieldDisplayMode(betterproto.Enum):
    RESOLVER_FIELD_DISPLAY_MODE_UNSPECIFIED = 0
    RESOLVER_FIELD_DISPLAY_MODE_ALL = 1
    RESOLVER_FIELD_DISPLAY_MODE_SPARSE = 2


@dataclass(eq=False, repr=False)
class StudioKey(betterproto.Message):
    """Studio key"""

    studio_id: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    """studio_id is the unique identifier of the studio"""

    workspace_id: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """
    workspace_id is the unique identifier of the workspace empty string ("")
    stands for the "mainline"
    """


@dataclass(eq=False, repr=False)
class StudioConfig(betterproto.Message):
    """Studio configuration"""

    key: "StudioKey" = betterproto.message_field(1)
    remove: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    """
    remove specifies that the resource identified by the key is to be removed
    from mainline Other data fields are not allowed when this field is set to
    true
    """

    display_name: Optional[str] = betterproto.message_field(
        3, wraps=betterproto.TYPE_STRING
    )
    """
    Changes to the below data fields in a workspace are applied on top of
    mainline content at the time the workspace was created
    """

    description: Optional[str] = betterproto.message_field(
        4, wraps=betterproto.TYPE_STRING
    )
    template: "Template" = betterproto.message_field(5)
    input_schema: "InputSchema" = betterproto.message_field(6)


@dataclass(eq=False, repr=False)
class Studio(betterproto.Message):
    """Studio state"""

    key: "StudioKey" = betterproto.message_field(1)
    created_at: datetime = betterproto.message_field(2)
    created_by: Optional[str] = betterproto.message_field(
        3, wraps=betterproto.TYPE_STRING
    )
    last_modified_at: datetime = betterproto.message_field(4)
    last_modified_by: Optional[str] = betterproto.message_field(
        5, wraps=betterproto.TYPE_STRING
    )
    display_name: Optional[str] = betterproto.message_field(
        6, wraps=betterproto.TYPE_STRING
    )
    """
    Below are config fields, with workspace changes applied on top of mainline
    Note that this resource will be present in a workspace only if the studio
    is modified (via the StudioConfig resource)
    """

    description: Optional[str] = betterproto.message_field(
        7, wraps=betterproto.TYPE_STRING
    )
    template: "Template" = betterproto.message_field(8)
    input_schema: "InputSchema" = betterproto.message_field(9)
    input_validation_results: "__workspace_v1__.InputValidationResults" = (
        betterproto.message_field(10)
    )


@dataclass(eq=False, repr=False)
class AssignedTagsConfig(betterproto.Message):
    """
    AssignedTagsConfig is the configuration to assign a studio to the set of
    devices matching a tag query
    """

    key: "StudioKey" = betterproto.message_field(1)
    remove: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    """
    remove specifies that the resource identified by the key is to be removed
    from mainline Other data fields are not allowed when this field is set to
    true
    """

    query: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)


@dataclass(eq=False, repr=False)
class AssignedTags(betterproto.Message):
    """AssignedTags is the state of studio assignment"""

    key: "StudioKey" = betterproto.message_field(1)
    created_at: datetime = betterproto.message_field(2)
    created_by: Optional[str] = betterproto.message_field(
        3, wraps=betterproto.TYPE_STRING
    )
    last_modified_at: datetime = betterproto.message_field(4)
    last_modified_by: Optional[str] = betterproto.message_field(
        5, wraps=betterproto.TYPE_STRING
    )
    query: Optional[str] = betterproto.message_field(6, wraps=betterproto.TYPE_STRING)


@dataclass(eq=False, repr=False)
class InputsKey(betterproto.Message):
    """Inputskey is the key of the InputsConfig and Inputs resources"""

    studio_id: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    """studio_id is the unique identifier of the studio"""

    workspace_id: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """
    workspace_id is the unique identifier of the workspace empty string ("")
    stands for the "mainline"
    """

    path: "___fmp__.RepeatedString" = betterproto.message_field(3)
    """
    path is the sequence of elements that uniquely identify an input field
    empty sequence stands for the "root", or the entire set of inputs
    """


@dataclass(eq=False, repr=False)
class InputsConfig(betterproto.Message):
    """InputsConfig provides values to the input fields of a studio"""

    key: "InputsKey" = betterproto.message_field(1)
    remove: Optional[bool] = betterproto.message_field(2, wraps=betterproto.TYPE_BOOL)
    """
    remove specifies that the resource identified by the key is to be removed
    from mainline Other data fields are not allowed when this field is set to
    true
    """

    inputs: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)
    """
    inputs is the value of the input field as a JSON string. It can be the
    value for a simple or complex input field
    """


@dataclass(eq=False, repr=False)
class Inputs(betterproto.Message):
    """Inputs is the state of inputs to a studio"""

    key: "InputsKey" = betterproto.message_field(1)
    created_at: datetime = betterproto.message_field(2)
    created_by: Optional[str] = betterproto.message_field(
        3, wraps=betterproto.TYPE_STRING
    )
    last_modified_at: datetime = betterproto.message_field(4)
    last_modified_by: Optional[str] = betterproto.message_field(
        5, wraps=betterproto.TYPE_STRING
    )
    inputs: Optional[str] = betterproto.message_field(6, wraps=betterproto.TYPE_STRING)
    """
    inputs is the entire set of inputs, a single JSON string starting with
    root. This is the result of applying workspace-specific InputsConfig
    changes on top of mainline.
    """


@dataclass(eq=False, repr=False)
class Template(betterproto.Message):
    """Template of the studio, with its type"""

    type: "TemplateType" = betterproto.enum_field(1)
    body: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)


@dataclass(eq=False, repr=False)
class BooleanInputFieldProps(betterproto.Message):
    default_value: Optional[bool] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BOOL
    )
    """
    default_value represents the default value of the boolean input field
    (optional)
    """


@dataclass(eq=False, repr=False)
class IntegerInputFieldProps(betterproto.Message):
    default_value: Optional[int] = betterproto.message_field(
        1, wraps=betterproto.TYPE_INT64
    )
    """
    default_value represents the default value of the integer input field
    (optional)
    """

    static_options: "___fmp__.RepeatedInt64" = betterproto.message_field(2)
    """
    static_options represents the list of valid integer values (optional)
    """

    dynamic_options: "___fmp__.RepeatedString" = betterproto.message_field(4)
    """
    dynamic_options contains a pointer expression that reference an input field
    with a collection of integer input values which will be used as a list of
    valid values (optional)
    """

    range: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)
    """
    range represents the range constraint imposed on the integer value; eg.
    "-10..10", "min..10", "-10..max" (optional)
    """


@dataclass(eq=False, repr=False)
class FloatInputFieldProps(betterproto.Message):
    default_value: Optional[float] = betterproto.message_field(
        2, wraps=betterproto.TYPE_FLOAT
    )
    """
    default_value represents the default value of the float input field
    (optional)
    """

    static_options: "___fmp__.RepeatedFloat" = betterproto.message_field(3)
    """static_options represents the list of valid float values (optional)"""

    dynamic_options: "___fmp__.RepeatedString" = betterproto.message_field(4)
    """
    dynamic_options contains a pointer expression that reference an input field
    with a collection of float input values which will be used as a list of
    valid values (optional)
    """


@dataclass(eq=False, repr=False)
class StringInputFieldProps(betterproto.Message):
    default_value: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """
    default_value represents the default value of the string input field
    (optional)
    """

    static_options: "___fmp__.RepeatedString" = betterproto.message_field(3)
    """static_options represents the list of valid string values (optional)"""

    dynamic_options: "___fmp__.RepeatedString" = betterproto.message_field(4)
    """
    dynamic_options contains a pointer expression that reference an input field
    with a collection of string input values which will be used as a list of
    valid values (optional)
    """

    length: Optional[str] = betterproto.message_field(5, wraps=betterproto.TYPE_STRING)
    """
    length represents the length constraint imposed on the string value; eg.
    "5..10", "min..10", "5..max" (optional)
    """

    pattern: Optional[str] = betterproto.message_field(6, wraps=betterproto.TYPE_STRING)
    """
    pattern represents the regexp-based pattern constraint imposed on the
    string value; eg. "^[0-9a-fA-F]*$" (optional)
    """

    format: Optional[str] = betterproto.message_field(7, wraps=betterproto.TYPE_STRING)
    """
    format represents the format imposed on string value; supported formats:
    "ip", "ipv6", "mac" (optional)
    """


@dataclass(eq=False, repr=False)
class GroupInputFieldProps(betterproto.Message):
    members: "___fmp__.RepeatedString" = betterproto.message_field(1)
    """members represents all the fields in the group input field"""


@dataclass(eq=False, repr=False)
class CollectionInputFieldProps(betterproto.Message):
    base_field_id: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    """
    base_field_id represent the ID of the collection input field's base field
    """

    key: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    """
    key specifies a key in the collection that identifies each element It only
    supports the group base field type `INPUT_FIELD_TYPE_GROUP`. The key field
    specified the ID of the group member and each element of the collection can
    be uniquely identified by the key. If the type of the base field is: -
    `INPUT_FIELD_TYPE_GROUP`: the value of specified by the key field will used
    as the collection element's key. The key field specifies the ID of the
    group member, the group member type must be one of the following field
    types:    `INPUT_FIELD_TYPE_INTEGER`, `INPUT_FIELD_TYPE_FLOAT`,
    `INPUT_FIELD_TYPE_STRING`.
    """


@dataclass(eq=False, repr=False)
class ResolverInputFieldProps(betterproto.Message):
    base_field_id: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING
    )
    """
    base_field_id represent the ID of the resolver input field's base field
    """

    display_mode: "ResolverFieldDisplayMode" = betterproto.enum_field(2)
    """display_mode represents the resolver input field's display mode"""

    input_mode: "ResolverFieldInputMode" = betterproto.enum_field(3)
    """input_mode represents the resolver input field's input mode"""

    input_tag_label: Optional[str] = betterproto.message_field(
        4, wraps=betterproto.TYPE_STRING
    )
    """
    input_tag_label represents the tag label to allow in tag inputs (optional)
    """

    tag_filter_query: Optional[str] = betterproto.message_field(
        5, wraps=betterproto.TYPE_STRING
    )
    """tag_filter_query specifies the tags that can be used in a resolver"""


@dataclass(eq=False, repr=False)
class InputField(betterproto.Message):
    id: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    """
    id represents the ID of the input field, which should be unique within the
    input schema resource
    """

    type: "InputFieldType" = betterproto.enum_field(2)
    """type represents the type of the input field"""

    name: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)
    """
    type represents the variable name use to reference the value of the input
    field
    """

    label: Optional[str] = betterproto.message_field(4, wraps=betterproto.TYPE_STRING)
    """label represents the label of the input field"""

    description: Optional[str] = betterproto.message_field(
        5, wraps=betterproto.TYPE_STRING
    )
    """description represents the description of the input field (optional)"""

    required: Optional[bool] = betterproto.message_field(6, wraps=betterproto.TYPE_BOOL)
    """
    required indicates whether the input field requires a value, defaults to
    `false` if unset (optional)
    """

    boolean_props: "BooleanInputFieldProps" = betterproto.message_field(7)
    """
    boolean_props contains properties for input fields of
    INPUT_FIELD_TYPE_BOOLEAN type (optional)
    """

    integer_props: "IntegerInputFieldProps" = betterproto.message_field(8)
    """
    integer_props contains properties for input fields of
    INPUT_FIELD_TYPE_INTEGER type (optional)
    """

    float_props: "FloatInputFieldProps" = betterproto.message_field(9)
    """
    float_props contains properties for input fields of INPUT_FIELD_TYPE_FLOAT
    type (optional)
    """

    string_props: "StringInputFieldProps" = betterproto.message_field(10)
    """
    string_props contains properties for input fields of
    INPUT_FIELD_TYPE_STRING type (optional)
    """

    group_props: "GroupInputFieldProps" = betterproto.message_field(11)
    """
    group_props contains properties for input fields of INPUT_FIELD_TYPE_GROUP
    type (optional)
    """

    collection_props: "CollectionInputFieldProps" = betterproto.message_field(12)
    """
    collection_props contains properties for input fields of
    INPUT_FIELD_TYPE_COLLECTION type (optional)
    """

    resolver_props: "ResolverInputFieldProps" = betterproto.message_field(13)
    """
    resolver_props contains properties for input fields of
    INPUT_FIELD_TYPE_RESOLVER type (optional)
    """

    auto_fill_action_id: Optional[str] = betterproto.message_field(
        14, wraps=betterproto.TYPE_STRING
    )
    """
    auto_fill_action_id represents the link between the field and the autofill
    script that provides a value for it (optional)
    """


@dataclass(eq=False, repr=False)
class InputFields(betterproto.Message):
    values: Dict[str, "InputField"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """
    values contains all input field configuration, mapped by each input field's
    respective field ID
    """


@dataclass(eq=False, repr=False)
class Layout(betterproto.Message):
    """Layout specifies the display properties input fields"""

    value: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)


@dataclass(eq=False, repr=False)
class InputSchema(betterproto.Message):
    """
    InputSchema specifies the input schema definition of a studio, consisting
    of a set of input fields, and optionally their layout information
    """

    fields: "InputFields" = betterproto.message_field(1)
    layout: "Layout" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class AssignedTagsRequest(betterproto.Message):
    key: "StudioKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a AssignedTags instance to retrieve. This value
    must be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class AssignedTagsResponse(betterproto.Message):
    value: "AssignedTags" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    AssignedTags instance in this response.
    """


@dataclass(eq=False, repr=False)
class AssignedTagsStreamRequest(betterproto.Message):
    partial_eq_filter: List["AssignedTags"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class AssignedTagsStreamResponse(betterproto.Message):
    value: "AssignedTags" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """Time holds the timestamp of this AssignedTags's last modification."""

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the AssignedTags value in this response should be
    considered. Under non-subscribe requests, this value should always be
    INITIAL. In a subscription, once all initial data is streamed and the
    client begins to receive modification updates, you should not see INITIAL
    again.
    """


@dataclass(eq=False, repr=False)
class AssignedTagsConfigRequest(betterproto.Message):
    key: "StudioKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a AssignedTagsConfig instance to retrieve. This
    value must be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class AssignedTagsConfigResponse(betterproto.Message):
    value: "AssignedTagsConfig" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    AssignedTagsConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class AssignedTagsConfigStreamRequest(betterproto.Message):
    partial_eq_filter: List["AssignedTagsConfig"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class AssignedTagsConfigStreamResponse(betterproto.Message):
    value: "AssignedTagsConfig" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time holds the timestamp of this AssignedTagsConfig's last modification.
    """

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the AssignedTagsConfig value in this response
    should be considered. Under non-subscribe requests, this value should
    always be INITIAL. In a subscription, once all initial data is streamed and
    the client begins to receive modification updates, you should not see
    INITIAL again.
    """


@dataclass(eq=False, repr=False)
class AssignedTagsConfigSetRequest(betterproto.Message):
    value: "AssignedTagsConfig" = betterproto.message_field(1)
    """
    AssignedTagsConfig carries the value to set into the datastore. See the
    documentation on the AssignedTagsConfig struct for which fields are
    required.
    """


@dataclass(eq=False, repr=False)
class AssignedTagsConfigSetResponse(betterproto.Message):
    value: "AssignedTagsConfig" = betterproto.message_field(1)
    """
    Value carries all the values given in the AssignedTagsConfigSetRequest as
    well as any server-generated values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    creation. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class AssignedTagsConfigDeleteRequest(betterproto.Message):
    key: "StudioKey" = betterproto.message_field(1)
    """
    Key indicates which AssignedTagsConfig instance to remove. This field must
    always be set.
    """


@dataclass(eq=False, repr=False)
class AssignedTagsConfigDeleteResponse(betterproto.Message):
    key: "StudioKey" = betterproto.message_field(1)
    """Key echoes back the key of the deleted AssignedTagsConfig instance."""

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    deletion. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class InputsRequest(betterproto.Message):
    key: "InputsKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a Inputs instance to retrieve. This value must be
    populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class InputsResponse(betterproto.Message):
    value: "Inputs" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the Inputs
    instance in this response.
    """


@dataclass(eq=False, repr=False)
class InputsStreamRequest(betterproto.Message):
    partial_eq_filter: List["Inputs"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class InputsStreamResponse(betterproto.Message):
    value: "Inputs" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """Time holds the timestamp of this Inputs's last modification."""

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the Inputs value in this response should be
    considered. Under non-subscribe requests, this value should always be
    INITIAL. In a subscription, once all initial data is streamed and the
    client begins to receive modification updates, you should not see INITIAL
    again.
    """


@dataclass(eq=False, repr=False)
class InputsConfigRequest(betterproto.Message):
    key: "InputsKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a InputsConfig instance to retrieve. This value
    must be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class InputsConfigResponse(betterproto.Message):
    value: "InputsConfig" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    InputsConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class InputsConfigStreamRequest(betterproto.Message):
    partial_eq_filter: List["InputsConfig"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class InputsConfigStreamResponse(betterproto.Message):
    value: "InputsConfig" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """Time holds the timestamp of this InputsConfig's last modification."""

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the InputsConfig value in this response should be
    considered. Under non-subscribe requests, this value should always be
    INITIAL. In a subscription, once all initial data is streamed and the
    client begins to receive modification updates, you should not see INITIAL
    again.
    """


@dataclass(eq=False, repr=False)
class InputsConfigSetRequest(betterproto.Message):
    value: "InputsConfig" = betterproto.message_field(1)
    """
    InputsConfig carries the value to set into the datastore. See the
    documentation on the InputsConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class InputsConfigSetResponse(betterproto.Message):
    value: "InputsConfig" = betterproto.message_field(1)
    """
    Value carries all the values given in the InputsConfigSetRequest as well as
    any server-generated values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    creation. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class InputsConfigDeleteRequest(betterproto.Message):
    key: "InputsKey" = betterproto.message_field(1)
    """
    Key indicates which InputsConfig instance to remove. This field must always
    be set.
    """


@dataclass(eq=False, repr=False)
class InputsConfigDeleteResponse(betterproto.Message):
    key: "InputsKey" = betterproto.message_field(1)
    """Key echoes back the key of the deleted InputsConfig instance."""

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    deletion. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class StudioRequest(betterproto.Message):
    key: "StudioKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a Studio instance to retrieve. This value must be
    populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class StudioResponse(betterproto.Message):
    value: "Studio" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the Studio
    instance in this response.
    """


@dataclass(eq=False, repr=False)
class StudioStreamRequest(betterproto.Message):
    partial_eq_filter: List["Studio"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class StudioStreamResponse(betterproto.Message):
    value: "Studio" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """Time holds the timestamp of this Studio's last modification."""

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the Studio value in this response should be
    considered. Under non-subscribe requests, this value should always be
    INITIAL. In a subscription, once all initial data is streamed and the
    client begins to receive modification updates, you should not see INITIAL
    again.
    """


@dataclass(eq=False, repr=False)
class StudioConfigRequest(betterproto.Message):
    key: "StudioKey" = betterproto.message_field(1)
    """
    Key uniquely identifies a StudioConfig instance to retrieve. This value
    must be populated.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data. If no
    time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class StudioConfigResponse(betterproto.Message):
    value: "StudioConfig" = betterproto.message_field(1)
    """
    Value is the value requested. This structure will be fully-populated as it
    exists in the datastore. If optional fields were not given at creation,
    these fields will be empty or set to default values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    StudioConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class StudioConfigStreamRequest(betterproto.Message):
    partial_eq_filter: List["StudioConfig"] = betterproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response. While
    transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = betterproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are
    required. This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class StudioConfigStreamResponse(betterproto.Message):
    value: "StudioConfig" = betterproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request. This structure
    will always have its key-field populated. Which other fields are populated,
    and why, depends on the value of Operation and what triggered this
    notification.
    """

    time: datetime = betterproto.message_field(2)
    """Time holds the timestamp of this StudioConfig's last modification."""

    type: "__subscriptions__.Operation" = betterproto.enum_field(3)
    """
    Operation indicates how the StudioConfig value in this response should be
    considered. Under non-subscribe requests, this value should always be
    INITIAL. In a subscription, once all initial data is streamed and the
    client begins to receive modification updates, you should not see INITIAL
    again.
    """


@dataclass(eq=False, repr=False)
class StudioConfigSetRequest(betterproto.Message):
    value: "StudioConfig" = betterproto.message_field(1)
    """
    StudioConfig carries the value to set into the datastore. See the
    documentation on the StudioConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class StudioConfigSetResponse(betterproto.Message):
    value: "StudioConfig" = betterproto.message_field(1)
    """
    Value carries all the values given in the StudioConfigSetRequest as well as
    any server-generated values.
    """

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    creation. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class StudioConfigDeleteRequest(betterproto.Message):
    key: "StudioKey" = betterproto.message_field(1)
    """
    Key indicates which StudioConfig instance to remove. This field must always
    be set.
    """


@dataclass(eq=False, repr=False)
class StudioConfigDeleteResponse(betterproto.Message):
    key: "StudioKey" = betterproto.message_field(1)
    """Key echoes back the key of the deleted StudioConfig instance."""

    time: datetime = betterproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    deletion. The only guarantees made about this timestamp are:    - it is
    after the time the request was received    - a time-ranged query with
    StartTime==DeletedAt will not include this instance.
    """


class AssignedTagsServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        assigned_tags_request: "AssignedTagsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AssignedTagsResponse":
        return await self._unary_unary(
            "/arista.studio.v1.AssignedTagsService/GetOne",
            assigned_tags_request,
            AssignedTagsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        assigned_tags_stream_request: "AssignedTagsStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["AssignedTagsStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio.v1.AssignedTagsService/GetAll",
            assigned_tags_stream_request,
            AssignedTagsStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        assigned_tags_stream_request: "AssignedTagsStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["AssignedTagsStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio.v1.AssignedTagsService/Subscribe",
            assigned_tags_stream_request,
            AssignedTagsStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class AssignedTagsConfigServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        assigned_tags_config_request: "AssignedTagsConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AssignedTagsConfigResponse":
        return await self._unary_unary(
            "/arista.studio.v1.AssignedTagsConfigService/GetOne",
            assigned_tags_config_request,
            AssignedTagsConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        assigned_tags_config_stream_request: "AssignedTagsConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["AssignedTagsConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio.v1.AssignedTagsConfigService/GetAll",
            assigned_tags_config_stream_request,
            AssignedTagsConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        assigned_tags_config_stream_request: "AssignedTagsConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["AssignedTagsConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio.v1.AssignedTagsConfigService/Subscribe",
            assigned_tags_config_stream_request,
            AssignedTagsConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        assigned_tags_config_set_request: "AssignedTagsConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AssignedTagsConfigSetResponse":
        return await self._unary_unary(
            "/arista.studio.v1.AssignedTagsConfigService/Set",
            assigned_tags_config_set_request,
            AssignedTagsConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete(
        self,
        assigned_tags_config_delete_request: "AssignedTagsConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AssignedTagsConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.studio.v1.AssignedTagsConfigService/Delete",
            assigned_tags_config_delete_request,
            AssignedTagsConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class InputsServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        inputs_request: "InputsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InputsResponse":
        return await self._unary_unary(
            "/arista.studio.v1.InputsService/GetOne",
            inputs_request,
            InputsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        inputs_stream_request: "InputsStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InputsStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio.v1.InputsService/GetAll",
            inputs_stream_request,
            InputsStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        inputs_stream_request: "InputsStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InputsStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio.v1.InputsService/Subscribe",
            inputs_stream_request,
            InputsStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class InputsConfigServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        inputs_config_request: "InputsConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InputsConfigResponse":
        return await self._unary_unary(
            "/arista.studio.v1.InputsConfigService/GetOne",
            inputs_config_request,
            InputsConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        inputs_config_stream_request: "InputsConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InputsConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio.v1.InputsConfigService/GetAll",
            inputs_config_stream_request,
            InputsConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        inputs_config_stream_request: "InputsConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InputsConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio.v1.InputsConfigService/Subscribe",
            inputs_config_stream_request,
            InputsConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        inputs_config_set_request: "InputsConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InputsConfigSetResponse":
        return await self._unary_unary(
            "/arista.studio.v1.InputsConfigService/Set",
            inputs_config_set_request,
            InputsConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete(
        self,
        inputs_config_delete_request: "InputsConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InputsConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.studio.v1.InputsConfigService/Delete",
            inputs_config_delete_request,
            InputsConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class StudioServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        studio_request: "StudioRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StudioResponse":
        return await self._unary_unary(
            "/arista.studio.v1.StudioService/GetOne",
            studio_request,
            StudioResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        studio_stream_request: "StudioStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["StudioStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio.v1.StudioService/GetAll",
            studio_stream_request,
            StudioStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        studio_stream_request: "StudioStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["StudioStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio.v1.StudioService/Subscribe",
            studio_stream_request,
            StudioStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class StudioConfigServiceStub(betterproto.ServiceStub):
    async def get_one(
        self,
        studio_config_request: "StudioConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StudioConfigResponse":
        return await self._unary_unary(
            "/arista.studio.v1.StudioConfigService/GetOne",
            studio_config_request,
            StudioConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        studio_config_stream_request: "StudioConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["StudioConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio.v1.StudioConfigService/GetAll",
            studio_config_stream_request,
            StudioConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        studio_config_stream_request: "StudioConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["StudioConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio.v1.StudioConfigService/Subscribe",
            studio_config_stream_request,
            StudioConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        studio_config_set_request: "StudioConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StudioConfigSetResponse":
        return await self._unary_unary(
            "/arista.studio.v1.StudioConfigService/Set",
            studio_config_set_request,
            StudioConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete(
        self,
        studio_config_delete_request: "StudioConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StudioConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.studio.v1.StudioConfigService/Delete",
            studio_config_delete_request,
            StudioConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class AssignedTagsServiceBase(ServiceBase):
    async def get_one(
        self, assigned_tags_request: "AssignedTagsRequest"
    ) -> "AssignedTagsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, assigned_tags_stream_request: "AssignedTagsStreamRequest"
    ) -> AsyncIterator["AssignedTagsStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield AssignedTagsStreamResponse()

    async def subscribe(
        self, assigned_tags_stream_request: "AssignedTagsStreamRequest"
    ) -> AsyncIterator["AssignedTagsStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield AssignedTagsStreamResponse()

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[AssignedTagsRequest, AssignedTagsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[AssignedTagsStreamRequest, AssignedTagsStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[AssignedTagsStreamRequest, AssignedTagsStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio.v1.AssignedTagsService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                AssignedTagsRequest,
                AssignedTagsResponse,
            ),
            "/arista.studio.v1.AssignedTagsService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                AssignedTagsStreamRequest,
                AssignedTagsStreamResponse,
            ),
            "/arista.studio.v1.AssignedTagsService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                AssignedTagsStreamRequest,
                AssignedTagsStreamResponse,
            ),
        }


class AssignedTagsConfigServiceBase(ServiceBase):
    async def get_one(
        self, assigned_tags_config_request: "AssignedTagsConfigRequest"
    ) -> "AssignedTagsConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, assigned_tags_config_stream_request: "AssignedTagsConfigStreamRequest"
    ) -> AsyncIterator["AssignedTagsConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield AssignedTagsConfigStreamResponse()

    async def subscribe(
        self, assigned_tags_config_stream_request: "AssignedTagsConfigStreamRequest"
    ) -> AsyncIterator["AssignedTagsConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield AssignedTagsConfigStreamResponse()

    async def set(
        self, assigned_tags_config_set_request: "AssignedTagsConfigSetRequest"
    ) -> "AssignedTagsConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, assigned_tags_config_delete_request: "AssignedTagsConfigDeleteRequest"
    ) -> "AssignedTagsConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[AssignedTagsConfigRequest, AssignedTagsConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[AssignedTagsConfigStreamRequest, AssignedTagsConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[AssignedTagsConfigStreamRequest, AssignedTagsConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[AssignedTagsConfigSetRequest, AssignedTagsConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[AssignedTagsConfigDeleteRequest, AssignedTagsConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio.v1.AssignedTagsConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                AssignedTagsConfigRequest,
                AssignedTagsConfigResponse,
            ),
            "/arista.studio.v1.AssignedTagsConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                AssignedTagsConfigStreamRequest,
                AssignedTagsConfigStreamResponse,
            ),
            "/arista.studio.v1.AssignedTagsConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                AssignedTagsConfigStreamRequest,
                AssignedTagsConfigStreamResponse,
            ),
            "/arista.studio.v1.AssignedTagsConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                AssignedTagsConfigSetRequest,
                AssignedTagsConfigSetResponse,
            ),
            "/arista.studio.v1.AssignedTagsConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                AssignedTagsConfigDeleteRequest,
                AssignedTagsConfigDeleteResponse,
            ),
        }


class InputsServiceBase(ServiceBase):
    async def get_one(self, inputs_request: "InputsRequest") -> "InputsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, inputs_stream_request: "InputsStreamRequest"
    ) -> AsyncIterator["InputsStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield InputsStreamResponse()

    async def subscribe(
        self, inputs_stream_request: "InputsStreamRequest"
    ) -> AsyncIterator["InputsStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield InputsStreamResponse()

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[InputsRequest, InputsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self, stream: "grpclib.server.Stream[InputsStreamRequest, InputsStreamResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self, stream: "grpclib.server.Stream[InputsStreamRequest, InputsStreamResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio.v1.InputsService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                InputsRequest,
                InputsResponse,
            ),
            "/arista.studio.v1.InputsService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                InputsStreamRequest,
                InputsStreamResponse,
            ),
            "/arista.studio.v1.InputsService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                InputsStreamRequest,
                InputsStreamResponse,
            ),
        }


class InputsConfigServiceBase(ServiceBase):
    async def get_one(
        self, inputs_config_request: "InputsConfigRequest"
    ) -> "InputsConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, inputs_config_stream_request: "InputsConfigStreamRequest"
    ) -> AsyncIterator["InputsConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield InputsConfigStreamResponse()

    async def subscribe(
        self, inputs_config_stream_request: "InputsConfigStreamRequest"
    ) -> AsyncIterator["InputsConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield InputsConfigStreamResponse()

    async def set(
        self, inputs_config_set_request: "InputsConfigSetRequest"
    ) -> "InputsConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, inputs_config_delete_request: "InputsConfigDeleteRequest"
    ) -> "InputsConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[InputsConfigRequest, InputsConfigResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[InputsConfigStreamRequest, InputsConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[InputsConfigStreamRequest, InputsConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[InputsConfigSetRequest, InputsConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[InputsConfigDeleteRequest, InputsConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio.v1.InputsConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                InputsConfigRequest,
                InputsConfigResponse,
            ),
            "/arista.studio.v1.InputsConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                InputsConfigStreamRequest,
                InputsConfigStreamResponse,
            ),
            "/arista.studio.v1.InputsConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                InputsConfigStreamRequest,
                InputsConfigStreamResponse,
            ),
            "/arista.studio.v1.InputsConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                InputsConfigSetRequest,
                InputsConfigSetResponse,
            ),
            "/arista.studio.v1.InputsConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                InputsConfigDeleteRequest,
                InputsConfigDeleteResponse,
            ),
        }


class StudioServiceBase(ServiceBase):
    async def get_one(self, studio_request: "StudioRequest") -> "StudioResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, studio_stream_request: "StudioStreamRequest"
    ) -> AsyncIterator["StudioStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StudioStreamResponse()

    async def subscribe(
        self, studio_stream_request: "StudioStreamRequest"
    ) -> AsyncIterator["StudioStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StudioStreamResponse()

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[StudioRequest, StudioResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self, stream: "grpclib.server.Stream[StudioStreamRequest, StudioStreamResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self, stream: "grpclib.server.Stream[StudioStreamRequest, StudioStreamResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio.v1.StudioService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                StudioRequest,
                StudioResponse,
            ),
            "/arista.studio.v1.StudioService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                StudioStreamRequest,
                StudioStreamResponse,
            ),
            "/arista.studio.v1.StudioService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                StudioStreamRequest,
                StudioStreamResponse,
            ),
        }


class StudioConfigServiceBase(ServiceBase):
    async def get_one(
        self, studio_config_request: "StudioConfigRequest"
    ) -> "StudioConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, studio_config_stream_request: "StudioConfigStreamRequest"
    ) -> AsyncIterator["StudioConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StudioConfigStreamResponse()

    async def subscribe(
        self, studio_config_stream_request: "StudioConfigStreamRequest"
    ) -> AsyncIterator["StudioConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StudioConfigStreamResponse()

    async def set(
        self, studio_config_set_request: "StudioConfigSetRequest"
    ) -> "StudioConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, studio_config_delete_request: "StudioConfigDeleteRequest"
    ) -> "StudioConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[StudioConfigRequest, StudioConfigResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[StudioConfigStreamRequest, StudioConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[StudioConfigStreamRequest, StudioConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[StudioConfigSetRequest, StudioConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[StudioConfigDeleteRequest, StudioConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio.v1.StudioConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                StudioConfigRequest,
                StudioConfigResponse,
            ),
            "/arista.studio.v1.StudioConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                StudioConfigStreamRequest,
                StudioConfigStreamResponse,
            ),
            "/arista.studio.v1.StudioConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                StudioConfigStreamRequest,
                StudioConfigStreamResponse,
            ),
            "/arista.studio.v1.StudioConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                StudioConfigSetRequest,
                StudioConfigSetResponse,
            ),
            "/arista.studio.v1.StudioConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                StudioConfigDeleteRequest,
                StudioConfigDeleteResponse,
            ),
        }
