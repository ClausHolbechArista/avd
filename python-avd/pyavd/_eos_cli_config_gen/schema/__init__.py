# Copyright (c) 2024 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.

from typing import Annotated, Any

from pyavd._schema.models import AvdBase
from pyavd._schema.types import Format, Max, MaxLen, Min, MinLen, Pattern, ValidValues


class EosCliConfigGen(AvdBase):
    class AaaAccounting(AvdBase):
        class Exec(AvdBase):
            class Console(AvdBase):
                _fields = ("_custom_data", "type", "group", "logging")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                type: Annotated[str, ValidValues["none", "start-stop", "stop-only"]] | None = None
                group: str | None = None
                """Group Name."""
                logging: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    type: Annotated[str, ValidValues["none", "start-stop", "stop-only"]] | None = None,
                    group: str | None = None,
                    logging: bool | None = None,
                ) -> None:
                    """
                    Console.

                    Args:
                    -----
                        _custom_data: _custom_data
                        type: type
                        group: Group Name.
                        logging: logging

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Default(AvdBase):
                _fields = ("_custom_data", "type", "group", "logging")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                type: Annotated[str, ValidValues["none", "start-stop", "stop-only"]] | None = None
                group: str | None = None
                """Group Name."""
                logging: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    type: Annotated[str, ValidValues["none", "start-stop", "stop-only"]] | None = None,
                    group: str | None = None,
                    logging: bool | None = None,
                ) -> None:
                    """
                    Default.

                    Args:
                    -----
                        _custom_data: _custom_data
                        type: type
                        group: Group Name.
                        logging: logging

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "console", "default")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            console: Console | None = None
            default: Default | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, console: Console | None = None, default: Default | None = None) -> None:
                """
                Exec.

                Args:
                -----
                    _custom_data: _custom_data
                    console: console
                    default: default

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class System(AvdBase):
            class Default(AvdBase):
                _fields = ("_custom_data", "type", "group")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                type: Annotated[str, ValidValues["none", "start-stop", "stop-only"]] | None = None
                group: str | None = None
                """Group Name."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    type: Annotated[str, ValidValues["none", "start-stop", "stop-only"]] | None = None,
                    group: str | None = None,
                ) -> None:
                    """
                    Default.

                    Args:
                    -----
                        _custom_data: _custom_data
                        type: type
                        group: Group Name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "default")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            default: Default | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, default: Default | None = None) -> None:
                """
                System.

                Args:
                -----
                    _custom_data: _custom_data
                    default: default

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Dot1x(AvdBase):
            class Default(AvdBase):
                _fields = ("_custom_data", "type", "group")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                type: Annotated[str, ValidValues["start-stop", "stop-only"]] | None = None
                group: str | None = None
                """Group Name."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    type: Annotated[str, ValidValues["start-stop", "stop-only"]] | None = None,
                    group: str | None = None,
                ) -> None:
                    """
                    Default.

                    Args:
                    -----
                        _custom_data: _custom_data
                        type: type
                        group: Group Name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "default")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            default: Default | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, default: Default | None = None) -> None:
                """
                Dot1x.

                Args:
                -----
                    _custom_data: _custom_data
                    default: default

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Commands(AvdBase):
            class ConsoleItem(AvdBase):
                _fields = ("_custom_data", "commands", "type", "group", "logging")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                commands: str | None = None
                """Privilege level 'all' or 0-15."""
                type: Annotated[str, ValidValues["none", "start-stop", "stop-only"]] | None = None
                group: str | None = None
                """Group Name."""
                logging: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    commands: str | None = None,
                    type: Annotated[str, ValidValues["none", "start-stop", "stop-only"]] | None = None,
                    group: str | None = None,
                    logging: bool | None = None,
                ) -> None:
                    """
                    ConsoleItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        commands: Privilege level 'all' or 0-15.
                        type: type
                        group: Group Name.
                        logging: logging

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class DefaultItem(AvdBase):
                _fields = ("_custom_data", "commands", "type", "group", "logging")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                commands: str | None = None
                """Privilege level 'all' or 0-15."""
                type: Annotated[str, ValidValues["none", "start-stop", "stop-only"]] | None = None
                group: str | None = None
                """Group Name."""
                logging: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    commands: str | None = None,
                    type: Annotated[str, ValidValues["none", "start-stop", "stop-only"]] | None = None,
                    group: str | None = None,
                    logging: bool | None = None,
                ) -> None:
                    """
                    DefaultItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        commands: Privilege level 'all' or 0-15.
                        type: type
                        group: Group Name.
                        logging: logging

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "console", "default")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            console: list[ConsoleItem] | None = None
            default: list[DefaultItem] | None = None

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, console: list[ConsoleItem] | None = None, default: list[DefaultItem] | None = None
            ) -> None:
                """
                Commands.

                Args:
                -----
                    _custom_data: _custom_data
                    console: console
                    default: default

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "exec", "system", "dot1x", "commands")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        exec: Exec | None = None
        system: System | None = None
        dot1x: Dot1x | None = None
        commands: Commands | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            exec: Exec | None = None,
            system: System | None = None,
            dot1x: Dot1x | None = None,
            commands: Commands | None = None,
        ) -> None:
            """
            AaaAccounting.

            Args:
            -----
                _custom_data: _custom_data
                exec: exec
                system: system
                dot1x: dot1x
                commands: commands

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class AaaAuthentication(AvdBase):
        class Login(AvdBase):
            _fields = ("_custom_data", "default", "console")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            default: str | None = None
            """
            Login authentication method(s) as a string.
            Examples:
            - "group tacacs+ local"
            - "group MYGROUP none"
            - "group radius group MYGROUP local"
            """
            console: str | None = None
            """
            Console authentication method(s) as a string.
            Examples:
            - "group tacacs+ local"
            - "group MYGROUP
            none"
            - "group radius group MYGROUP local"
            """

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, default: str | None = None, console: str | None = None) -> None:
                """
                Login.

                Args:
                -----
                    _custom_data: _custom_data
                    default:
                       Login authentication method(s) as a string.

                Examples:
                       - "group tacacs+ local"
                       - "group MYGROUP none"
                       - "group radius group MYGROUP local"
                    console:
                       Console authentication method(s) as a string.

                Examples:
                       - "group tacacs+ local"
                       - "group MYGROUP
                       none"
                       - "group radius group MYGROUP local"

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Enable(AvdBase):
            _fields = ("_custom_data", "default")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            default: str | None = None
            """
            Enable authentication method(s) as a string.
            Examples:
            - "group tacacs+ local"
            - "group MYGROUP
            none"
            - "group radius group MYGROUP local"
            """

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, default: str | None = None) -> None:
                """
                Enable.

                Args:
                -----
                    _custom_data: _custom_data
                    default:
                       Enable authentication method(s) as a string.

                Examples:
                       - "group tacacs+ local"
                       - "group MYGROUP
                       none"
                       - "group radius group MYGROUP local"

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Dot1x(AvdBase):
            _fields = ("_custom_data", "default")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            default: str | None = None
            """
            802.1x authentication method(s) as a string.
            Examples:
            - "group radius"
            - "group MYGROUP group
            radius"
            """

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, default: str | None = None) -> None:
                """
                Dot1x.

                Args:
                -----
                    _custom_data: _custom_data
                    default:
                       802.1x authentication method(s) as a string.

                Examples:
                       - "group radius"
                       - "group MYGROUP group
                       radius"

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Policies(AvdBase):
            class Local(AvdBase):
                _fields = ("_custom_data", "allow_nopassword")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                allow_nopassword: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, allow_nopassword: bool | None = None) -> None:
                    """
                    Local.

                    Args:
                    -----
                        _custom_data: _custom_data
                        allow_nopassword: allow_nopassword

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Lockout(AvdBase):
                _fields = ("_custom_data", "failure", "duration", "window")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                failure: Annotated[int, Min[1], Max[255]] | None = None
                duration: Annotated[int, Min[1], Max[4294967295]] | None = None
                window: Annotated[int, Min[1], Max[4294967295]] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    failure: Annotated[int, Min[1], Max[255]] | None = None,
                    duration: Annotated[int, Min[1], Max[4294967295]] | None = None,
                    window: Annotated[int, Min[1], Max[4294967295]] | None = None,
                ) -> None:
                    """
                    Lockout.

                    Args:
                    -----
                        _custom_data: _custom_data
                        failure: failure
                        duration: duration
                        window: window

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "on_failure_log", "on_success_log", "local", "lockout")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            on_failure_log: bool | None = None
            on_success_log: bool | None = None
            local: Local | None = None
            lockout: Lockout | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                on_failure_log: bool | None = None,
                on_success_log: bool | None = None,
                local: Local | None = None,
                lockout: Lockout | None = None,
            ) -> None:
                """
                Policies.

                Args:
                -----
                    _custom_data: _custom_data
                    on_failure_log: on_failure_log
                    on_success_log: on_success_log
                    local: local
                    lockout: lockout

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "login", "enable", "dot1x", "policies")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        login: Login | None = None
        enable: Enable | None = None
        dot1x: Dot1x | None = None
        policies: Policies | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            login: Login | None = None,
            enable: Enable | None = None,
            dot1x: Dot1x | None = None,
            policies: Policies | None = None,
        ) -> None:
            """
            AaaAuthentication.

            Args:
            -----
                _custom_data: _custom_data
                login: login
                enable: enable
                dot1x: dot1x
                policies: policies

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class AaaAuthorization(AvdBase):
        class Policy(AvdBase):
            _fields = ("_custom_data", "local_default_role")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            local_default_role: str | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, local_default_role: str | None = None) -> None:
                """
                Policy.

                Args:
                -----
                    _custom_data: _custom_data
                    local_default_role: local_default_role

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Exec(AvdBase):
            _fields = ("_custom_data", "default")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            default: str | None = None
            """
            Exec authorization method(s) as a string.
            Examples:
            - "group tacacs+ local"
            - "group MYGROUP none"
            -
            "group radius group MYGROUP local"
            """

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, default: str | None = None) -> None:
                """
                Exec.

                Args:
                -----
                    _custom_data: _custom_data
                    default:
                       Exec authorization method(s) as a string.

                Examples:
                       - "group tacacs+ local"
                       - "group MYGROUP none"
                       -
                       "group radius group MYGROUP local"

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Dynamic(AvdBase):
            _fields = ("_custom_data", "dot1x_additional_groups")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            dot1x_additional_groups: list[str] | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, dot1x_additional_groups: list[str] | None = None) -> None:
                """
                Dynamic.

                Args:
                -----
                    _custom_data: _custom_data
                    dot1x_additional_groups: dot1x_additional_groups

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Commands(AvdBase):
            class PrivilegeItem(AvdBase):
                _fields = ("_custom_data", "level", "default")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                level: str | None = None
                """Privilege level(s) 0-15."""
                default: str | None = None
                """
                Command authorization method(s) as a string.
                Examples:
                - "group tacacs+ local"
                - "group MYGROUP
                none"
                - "group tacacs+ group MYGROUP local"
                """

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, level: str | None = None, default: str | None = None) -> None:
                    """
                    PrivilegeItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Privilege level(s) 0-15.
                        default:
                           Command authorization method(s) as a string.

                    Examples:
                           - "group tacacs+ local"
                           - "group MYGROUP
                           none"
                           - "group tacacs+ group MYGROUP local"

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "all_default", "privilege")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            all_default: str | None = None
            """
            Command authorization method(s) as a string.
            Examples:
            - "group tacacs+ local"
            - "group MYGROUP
            none"
            - "group tacacs+ group MYGROUP local
            """
            privilege: list[PrivilegeItem] | None = None

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, all_default: str | None = None, privilege: list[PrivilegeItem] | None = None
            ) -> None:
                """
                Commands.

                Args:
                -----
                    _custom_data: _custom_data
                    all_default:
                       Command authorization method(s) as a string.

                Examples:
                       - "group tacacs+ local"
                       - "group MYGROUP
                       none"
                       - "group tacacs+ group MYGROUP local
                    privilege: privilege

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "policy", "exec", "config_commands", "serial_console", "dynamic", "commands")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        policy: Policy | None = None
        exec: Exec | None = None
        config_commands: bool | None = None
        serial_console: bool | None = None
        dynamic: Dynamic | None = None
        commands: Commands | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            policy: Policy | None = None,
            exec: Exec | None = None,
            config_commands: bool | None = None,
            serial_console: bool | None = None,
            dynamic: Dynamic | None = None,
            commands: Commands | None = None,
        ) -> None:
            """
            AaaAuthorization.

            Args:
            -----
                _custom_data: _custom_data
                policy: policy
                exec: exec
                config_commands: config_commands
                serial_console: serial_console
                dynamic: dynamic
                commands: commands

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class AaaRoot(AvdBase):
        class Secret(AvdBase):
            _fields = ("_custom_data", "sha512_password")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            sha512_password: str | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, sha512_password: str | None = None) -> None:
                """
                Secret.

                Args:
                -----
                    _custom_data: _custom_data
                    sha512_password: sha512_password

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "disabled", "secret")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        disabled: bool | None = None
        """Set to `true` to configure `no aaa root` which is the EOS default."""
        secret: Secret | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, disabled: bool | None = None, secret: Secret | None = None) -> None:
            """
            AaaRoot.

            Args:
            -----
                _custom_data: _custom_data
                disabled: Set to `true` to configure `no aaa root` which is the EOS default.
                secret: secret

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class AaaServerGroupsItem(AvdBase):
        class ServersItem(AvdBase):
            _fields = ("_custom_data", "server", "vrf")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            server: str | None = None
            """Hostname or IP address."""
            vrf: str | None = None
            """VRF name."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, server: str | None = None, vrf: str | None = None) -> None:
                """
                ServersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    server: Hostname or IP address.
                    vrf: VRF name.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "name", "type", "servers")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str | None = None
        """Group name."""
        type: Annotated[str, ValidValues["tacacs+", "radius", "ldap"]] | None = None
        servers: list[ServersItem] | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str | None = None,
            type: Annotated[str, ValidValues["tacacs+", "radius", "ldap"]] | None = None,
            servers: list[ServersItem] | None = None,
        ) -> None:
            """
            AaaServerGroupsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Group name.
                type: type
                servers: servers

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class AccessListsItem(AvdBase):
        class SequenceNumbersItem(AvdBase):
            _fields = ("_custom_data", "sequence", "action")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            sequence: int = None
            """Sequence ID."""
            action: str = None
            """
            Action as string.
            Example: "deny ip any any"
            """

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, sequence: int = None, action: str = None) -> None:
                """
                SequenceNumbersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: Sequence ID.
                    action:
                       Action as string.
                       Example: "deny ip any any"

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "name", "counters_per_entry", "permit_response_traffic", "sequence_numbers")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Access-list Name."""
        counters_per_entry: bool | None = None
        permit_response_traffic: Annotated[str, ValidValues["nat"]] | None = None
        """
        Permit response traffic automatically based on NAT translations.
        Minimum EOS version requirement
        4.32.2F.
        """
        sequence_numbers: list[SequenceNumbersItem] = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str = None,
            counters_per_entry: bool | None = None,
            permit_response_traffic: Annotated[str, ValidValues["nat"]] | None = None,
            sequence_numbers: list[SequenceNumbersItem] = None,
        ) -> None:
            """
            AccessListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Access-list Name.
                counters_per_entry: counters_per_entry
                permit_response_traffic:
                   Permit response traffic automatically based on NAT translations.
                   Minimum EOS version requirement
                   4.32.2F.
                sequence_numbers: sequence_numbers

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class AddressLocking(AvdBase):
        class LeasesItem(AvdBase):
            _fields = ("_custom_data", "ip", "mac")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ip: str = None
            """IP address."""
            mac: str = None
            """MAC address (hhhh.hhhh.hhhh or hh:hh:hh:hh:hh:hh)."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, ip: str = None, mac: str = None) -> None:
                """
                LeasesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    ip: IP address.
                    mac: MAC address (hhhh.hhhh.hhhh or hh:hh:hh:hh:hh:hh).

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class LockedAddress(AvdBase):
            _fields = ("_custom_data", "expiration_mac_disabled", "ipv4_enforcement_disabled", "ipv6_enforcement_disabled")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            expiration_mac_disabled: bool | None = None
            """Configure deauthorizing locked addresses upon MAC aging out."""
            ipv4_enforcement_disabled: bool | None = None
            """Configure enforcement for locked IPv4 addresses."""
            ipv6_enforcement_disabled: bool | None = None
            """Configure enforcement for locked IPv6 addresses."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                expiration_mac_disabled: bool | None = None,
                ipv4_enforcement_disabled: bool | None = None,
                ipv6_enforcement_disabled: bool | None = None,
            ) -> None:
                """
                LockedAddress.

                Args:
                -----
                    _custom_data: _custom_data
                    expiration_mac_disabled: Configure deauthorizing locked addresses upon MAC aging out.
                    ipv4_enforcement_disabled: Configure enforcement for locked IPv4 addresses.
                    ipv6_enforcement_disabled: Configure enforcement for locked IPv6 addresses.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "dhcp_servers_ipv4", "disabled", "leases", "local_interface", "locked_address")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        dhcp_servers_ipv4: list[str] | None = None
        disabled: bool | None = None
        """Disable IP locking on configured ports."""
        leases: list[LeasesItem] | None = None
        local_interface: str | None = None
        locked_address: LockedAddress | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            dhcp_servers_ipv4: list[str] | None = None,
            disabled: bool | None = None,
            leases: list[LeasesItem] | None = None,
            local_interface: str | None = None,
            locked_address: LockedAddress | None = None,
        ) -> None:
            """
            AddressLocking.

            Args:
            -----
                _custom_data: _custom_data
                dhcp_servers_ipv4: dhcp_servers_ipv4
                disabled: Disable IP locking on configured ports.
                leases: leases
                local_interface: local_interface
                locked_address: locked_address

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class AgentsItem(AvdBase):
        class EnvironmentVariablesItem(AvdBase):
            _fields = ("_custom_data", "name", "value")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Environment variable name."""
            value: str = None
            """Environment variable value."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, value: str = None) -> None:
                """
                EnvironmentVariablesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Environment variable name.
                    value: Environment variable value.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "name", "environment_variables")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Agent name."""
        environment_variables: list[EnvironmentVariablesItem] | None = None

        def __init__(
            self, *, _custom_data: dict[str, Any] | None = None, name: str = None, environment_variables: list[EnvironmentVariablesItem] | None = None
        ) -> None:
            """
            AgentsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Agent name.
                environment_variables: environment_variables

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ApplicationTrafficRecognition(AvdBase):
        class CategoriesItem(AvdBase):
            class ApplicationsItem(AvdBase):
                _fields = ("_custom_data", "name", "service")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str | None = None
                """Application name."""
                service: (
                    Annotated[str, ValidValues["audio-video", "chat", "default", "file-transfer", "networking-protocols", "peer-to-peer", "software-update"]]
                    | None
                ) = None
                """
                Service Name.
                Specific service to target for this application.
                If no service is specified, all
                supported services of the application are matched.
                Not all valid values are valid for all
                applications, check on EOS CLI.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str | None = None,
                    service: Annotated[
                        str, ValidValues["audio-video", "chat", "default", "file-transfer", "networking-protocols", "peer-to-peer", "software-update"]
                    ]
                    | None = None,
                ) -> None:
                    """
                    ApplicationsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Application name.
                        service:
                           Service Name.
                           Specific service to target for this application.
                           If no service is specified, all
                           supported services of the application are matched.
                           Not all valid values are valid for all
                           applications, check on EOS CLI.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "applications")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Category name."""
            applications: list[ApplicationsItem] | None = None
            """List of applications."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, applications: list[ApplicationsItem] | None = None) -> None:
                """
                CategoriesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Category name.
                    applications: List of applications.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class FieldSets(AvdBase):
            class L4PortsItem(AvdBase):
                _fields = ("_custom_data", "name", "port_values")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """L4 port field-set name."""
                port_values: list[str] | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, port_values: list[str] | None = None) -> None:
                    """
                    L4PortsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: L4 port field-set name.
                        port_values: port_values

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv4PrefixesItem(AvdBase):
                _fields = ("_custom_data", "name", "prefix_values")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """IPv4 prefix field-set name."""
                prefix_values: list[str] | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, prefix_values: list[str] | None = None) -> None:
                    """
                    Ipv4PrefixesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: IPv4 prefix field-set name.
                        prefix_values: prefix_values

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "l4_ports", "ipv4_prefixes")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            l4_ports: list[L4PortsItem] | None = None
            """L4 port field-set."""
            ipv4_prefixes: list[Ipv4PrefixesItem] | None = None
            """IPv4 prefix field set."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                l4_ports: list[L4PortsItem] | None = None,
                ipv4_prefixes: list[Ipv4PrefixesItem] | None = None,
            ) -> None:
                """
                FieldSets.

                Args:
                -----
                    _custom_data: _custom_data
                    l4_ports: L4 port field-set.
                    ipv4_prefixes: IPv4 prefix field set.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Applications(AvdBase):
            class Ipv4ApplicationsItem(AvdBase):
                _fields = (
                    "_custom_data",
                    "name",
                    "src_prefix_set_name",
                    "dest_prefix_set_name",
                    "dscp_ranges",
                    "protocols",
                    "protocol_ranges",
                    "udp_src_port_set_name",
                    "tcp_src_port_set_name",
                    "udp_dest_port_set_name",
                    "tcp_dest_port_set_name",
                )
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Application name."""
                src_prefix_set_name: str | None = None
                """Source prefix set name."""
                dest_prefix_set_name: str | None = None
                """Destination prefix set name."""
                dscp_ranges: (
                    list[Annotated[str, Pattern[r"^(?:cs[1-7]|af[1-4][1-3]|ef|(?:(?:,|,\s|^)(?:\d|[1-5]\d|6[0-3])(?:-(?:\d|[1-5]\d|6[0-3]))?)+)$"]]] | None
                ) = None
                """
                Accept DSCP value(s) or range(s).
                DSCP values can be between 0 and 63.
                Other valid values are cs0 to
                cs7, af11-13, af21-23, af31-33, af41-af43 and ef.
                Note: The values are not sorted so the list items
                need to be supplied in the right order to match the CLI if required.
                """
                protocols: list[Annotated[str, ValidValues["ahp", "esp", "icmp", "igmp", "ospf", "pim", "rsvp", "tcp", "udp", "vrrp"]]] | None = None
                """
                List of protocols to consider for this application.
                To use port field-sets (source, destination or
                both), the list
                must contain only one or two protocols, either `tcp` or `udp`.
                When using both
                protocols, one line is rendered for each in the configuration,
                hence the field-sets must have the
                same value for `tcp_src_port_set_name` and
                `udp_src_port_set_name` and for `tcp_dest_port_set_name`
                and `udp_dest_port_set_name`
                if set in order to generate valid configuration in EOS.
                """
                protocol_ranges: list[str] | None = None
                """
                Accept protocol value(s) or range(s).
                Protocol values can be between 1 and 255.
                """
                udp_src_port_set_name: str | None = None
                """
                Name of field set for UDP source ports.
                When the `protocols` list contain both `tcp` and `udp`, this
                key value
                must be the same as `tcp_src_port_set_name`.
                """
                tcp_src_port_set_name: str | None = None
                """
                Name of field set for TCP source ports.
                When the `protocols` list contain both `tcp` and `udp`, this
                key value
                must be the same as `udp_src_port_set_name`.
                """
                udp_dest_port_set_name: str | None = None
                """
                Name of field set for UDP destination ports.
                When the `protocols` list contain both `tcp` and `udp`,
                this key value
                must be the same as `tcp_dest_port_set_name`.
                """
                tcp_dest_port_set_name: str | None = None
                """
                Name of field set for TCP destination ports.
                When the `protocols` list contain both `tcp` and `udp`,
                this key value
                must be the same as `udp_dest_port_set_name`.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    src_prefix_set_name: str | None = None,
                    dest_prefix_set_name: str | None = None,
                    dscp_ranges: list[
                        Annotated[str, Pattern[r"^(?:cs[1-7]|af[1-4][1-3]|ef|(?:(?:,|,\s|^)(?:\d|[1-5]\d|6[0-3])(?:-(?:\d|[1-5]\d|6[0-3]))?)+)$"]]
                    ]
                    | None = None,
                    protocols: list[Annotated[str, ValidValues["ahp", "esp", "icmp", "igmp", "ospf", "pim", "rsvp", "tcp", "udp", "vrrp"]]] | None = None,
                    protocol_ranges: list[str] | None = None,
                    udp_src_port_set_name: str | None = None,
                    tcp_src_port_set_name: str | None = None,
                    udp_dest_port_set_name: str | None = None,
                    tcp_dest_port_set_name: str | None = None,
                ) -> None:
                    """
                    Ipv4ApplicationsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Application name.
                        src_prefix_set_name: Source prefix set name.
                        dest_prefix_set_name: Destination prefix set name.
                        dscp_ranges:
                           Accept DSCP value(s) or range(s).
                           DSCP values can be between 0 and 63.
                           Other valid values are cs0 to
                           cs7, af11-13, af21-23, af31-33, af41-af43 and ef.
                           Note: The values are not sorted so the list items
                           need to be supplied in the right order to match the CLI if required.
                        protocols:
                           List of protocols to consider for this application.
                           To use port field-sets (source, destination or
                           both), the list
                           must contain only one or two protocols, either `tcp` or `udp`.
                           When using both
                           protocols, one line is rendered for each in the configuration,
                           hence the field-sets must have the
                           same value for `tcp_src_port_set_name` and
                           `udp_src_port_set_name` and for `tcp_dest_port_set_name`
                           and `udp_dest_port_set_name`
                           if set in order to generate valid configuration in EOS.
                        protocol_ranges:
                           Accept protocol value(s) or range(s).
                           Protocol values can be between 1 and 255.
                        udp_src_port_set_name:
                           Name of field set for UDP source ports.
                           When the `protocols` list contain both `tcp` and `udp`, this
                           key value
                           must be the same as `tcp_src_port_set_name`.
                        tcp_src_port_set_name:
                           Name of field set for TCP source ports.
                           When the `protocols` list contain both `tcp` and `udp`, this
                           key value
                           must be the same as `udp_src_port_set_name`.
                        udp_dest_port_set_name:
                           Name of field set for UDP destination ports.
                           When the `protocols` list contain both `tcp` and `udp`,
                           this key value
                           must be the same as `tcp_dest_port_set_name`.
                        tcp_dest_port_set_name:
                           Name of field set for TCP destination ports.
                           When the `protocols` list contain both `tcp` and `udp`,
                           this key value
                           must be the same as `udp_dest_port_set_name`.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class L4ApplicationsItem(AvdBase):
                _fields = (
                    "_custom_data",
                    "name",
                    "protocols",
                    "protocol_ranges",
                    "udp_src_port_set_name",
                    "tcp_src_port_set_name",
                    "udp_dest_port_set_name",
                    "tcp_dest_port_set_name",
                )
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Application name."""
                protocols: list[Annotated[str, ValidValues["ahp", "esp", "icmp", "igmp", "ospf", "pim", "rsvp", "tcp", "udp", "vrrp"]]] | None = None
                """
                List of protocols to consider for this application.
                To use port field-sets (source, destination or
                both), the list
                must contain only one or two protocols, either `tcp` or `udp`.
                When using both
                protocols, one line is rendered for each in the configuration,
                hence the field-sets must have the
                same value for `tcp_src_port_set_name` and
                `udp_src_port_set_name` and for `tcp_dest_port_set_name`
                and `udp_dest_port_set_name`
                if set in order to generate valid configuration in EOS.
                """
                protocol_ranges: list[str] | None = None
                """
                Accept protocol value(s) or range(s).
                Protocol values can be between 1 and 255.
                """
                udp_src_port_set_name: str | None = None
                """
                Name of field set for UDP source ports.
                When the `protocols` list contain both `tcp` and `udp`, this
                key value
                must be the same as `tcp_src_port_set_name`.
                """
                tcp_src_port_set_name: str | None = None
                """
                Name of field set for TCP source ports.
                When the `protocols` list contain both `tcp` and `udp`, this
                key value
                must be the same as `udp_src_port_set_name`.
                """
                udp_dest_port_set_name: str | None = None
                """
                Name of field set for UDP destination ports.
                When the `protocols` list contain both `tcp` and `udp`,
                this key value
                must be the same as `tcp_dest_port_set_name`.
                """
                tcp_dest_port_set_name: str | None = None
                """
                Name of field set for TCP destination ports.
                When the `protocols` list contain both `tcp` and `udp`,
                this key value
                must be the same as `udp_dest_port_set_name`.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    protocols: list[Annotated[str, ValidValues["ahp", "esp", "icmp", "igmp", "ospf", "pim", "rsvp", "tcp", "udp", "vrrp"]]] | None = None,
                    protocol_ranges: list[str] | None = None,
                    udp_src_port_set_name: str | None = None,
                    tcp_src_port_set_name: str | None = None,
                    udp_dest_port_set_name: str | None = None,
                    tcp_dest_port_set_name: str | None = None,
                ) -> None:
                    """
                    L4ApplicationsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Application name.
                        protocols:
                           List of protocols to consider for this application.
                           To use port field-sets (source, destination or
                           both), the list
                           must contain only one or two protocols, either `tcp` or `udp`.
                           When using both
                           protocols, one line is rendered for each in the configuration,
                           hence the field-sets must have the
                           same value for `tcp_src_port_set_name` and
                           `udp_src_port_set_name` and for `tcp_dest_port_set_name`
                           and `udp_dest_port_set_name`
                           if set in order to generate valid configuration in EOS.
                        protocol_ranges:
                           Accept protocol value(s) or range(s).
                           Protocol values can be between 1 and 255.
                        udp_src_port_set_name:
                           Name of field set for UDP source ports.
                           When the `protocols` list contain both `tcp` and `udp`, this
                           key value
                           must be the same as `tcp_src_port_set_name`.
                        tcp_src_port_set_name:
                           Name of field set for TCP source ports.
                           When the `protocols` list contain both `tcp` and `udp`, this
                           key value
                           must be the same as `udp_src_port_set_name`.
                        udp_dest_port_set_name:
                           Name of field set for UDP destination ports.
                           When the `protocols` list contain both `tcp` and `udp`,
                           this key value
                           must be the same as `tcp_dest_port_set_name`.
                        tcp_dest_port_set_name:
                           Name of field set for TCP destination ports.
                           When the `protocols` list contain both `tcp` and `udp`,
                           this key value
                           must be the same as `udp_dest_port_set_name`.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "ipv4_applications", "l4_applications")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv4_applications: list[Ipv4ApplicationsItem] | None = None
            """
            List of user defined IPv4 applications. The name should be unique over all defined applications
            (ipv4 and l4).
            """
            l4_applications: list[L4ApplicationsItem] | None = None
            """
            List of user defined L4 applications. The name should be unique over all defined applications (ipv4
            and l4).
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                ipv4_applications: list[Ipv4ApplicationsItem] | None = None,
                l4_applications: list[L4ApplicationsItem] | None = None,
            ) -> None:
                """
                Applications.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4_applications:
                       List of user defined IPv4 applications. The name should be unique over all defined applications
                       (ipv4 and l4).
                    l4_applications:
                       List of user defined L4 applications. The name should be unique over all defined applications (ipv4
                       and l4).

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ApplicationProfilesItem(AvdBase):
            class ApplicationsItem(AvdBase):
                _fields = ("_custom_data", "name", "service")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str | None = None
                """Application Name."""
                service: (
                    Annotated[str, ValidValues["audio-video", "chat", "default", "file-transfer", "networking-protocols", "peer-to-peer", "software-update"]]
                    | None
                ) = None
                """
                Service Name.
                Specific service to target for this application.
                If no service is specified, all
                supported services of the application are matched.
                Not all valid values are valid for all
                applications, check on EOS CLI.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str | None = None,
                    service: Annotated[
                        str, ValidValues["audio-video", "chat", "default", "file-transfer", "networking-protocols", "peer-to-peer", "software-update"]
                    ]
                    | None = None,
                ) -> None:
                    """
                    ApplicationsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Application Name.
                        service:
                           Service Name.
                           Specific service to target for this application.
                           If no service is specified, all
                           supported services of the application are matched.
                           Not all valid values are valid for all
                           applications, check on EOS CLI.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class CategoriesItem(AvdBase):
                _fields = ("_custom_data", "name", "service")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str | None = None
                """Name of a category."""
                service: (
                    Annotated[str, ValidValues["audio-video", "chat", "default", "file-transfer", "networking-protocols", "peer-to-peer", "software-update"]]
                    | None
                ) = None
                """
                Service Name.
                Specific service to target for this application.
                If no service is specified, all
                supported services of the application are matched.
                Not all valid values are valid for all
                applications, check on EOS CLI.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str | None = None,
                    service: Annotated[
                        str, ValidValues["audio-video", "chat", "default", "file-transfer", "networking-protocols", "peer-to-peer", "software-update"]
                    ]
                    | None = None,
                ) -> None:
                    """
                    CategoriesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Name of a category.
                        service:
                           Service Name.
                           Specific service to target for this application.
                           If no service is specified, all
                           supported services of the application are matched.
                           Not all valid values are valid for all
                           applications, check on EOS CLI.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "applications", "application_transports", "categories")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str | None = None
            """Application Profile name."""
            applications: list[ApplicationsItem] | None = None
            """List of applications part of the application profile."""
            application_transports: list[Annotated[str, ValidValues["http", "https", "udp", "tcp", "ip", "ip6", "ssl", "rtp", "sctp", "quic"]]] | None = None
            """List of transport protocols."""
            categories: list[CategoriesItem] | None = None
            """Categories under this application profile."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str | None = None,
                applications: list[ApplicationsItem] | None = None,
                application_transports: list[Annotated[str, ValidValues["http", "https", "udp", "tcp", "ip", "ip6", "ssl", "rtp", "sctp", "quic"]]]
                | None = None,
                categories: list[CategoriesItem] | None = None,
            ) -> None:
                """
                ApplicationProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Application Profile name.
                    applications: List of applications part of the application profile.
                    application_transports: List of transport protocols.
                    categories: Categories under this application profile.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "categories", "field_sets", "applications", "application_profiles")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        categories: list[CategoriesItem] | None = None
        """List of categories."""
        field_sets: FieldSets | None = None
        applications: Applications | None = None
        application_profiles: list[ApplicationProfilesItem] | None = None
        """Group of applications."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            categories: list[CategoriesItem] | None = None,
            field_sets: FieldSets | None = None,
            applications: Applications | None = None,
            application_profiles: list[ApplicationProfilesItem] | None = None,
        ) -> None:
            """
            ApplicationTrafficRecognition.

            Args:
            -----
                _custom_data: _custom_data
                categories: List of categories.
                field_sets: field_sets
                applications: applications
                application_profiles: Group of applications.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Arp(AvdBase):
        class Persistent(AvdBase):
            _fields = ("_custom_data", "enabled", "refresh_delay")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool = None
            """Restore the ARP cache after reboot."""
            refresh_delay: Annotated[int, Min[600], Max[3600]] | None = None
            """Time to wait in seconds before refreshing the ARP cache after reboot (EOS default 600)."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, refresh_delay: Annotated[int, Min[600], Max[3600]] | None = None
            ) -> None:
                """
                Persistent.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: Restore the ARP cache after reboot.
                    refresh_delay: Time to wait in seconds before refreshing the ARP cache after reboot (EOS default 600).

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Aging(AvdBase):
            _fields = ("_custom_data", "timeout_default")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            timeout_default: Annotated[int, Min[60], Max[65535]] | None = None
            """Timeout in seconds."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, timeout_default: Annotated[int, Min[60], Max[65535]] | None = None) -> None:
                """
                Aging.

                Args:
                -----
                    _custom_data: _custom_data
                    timeout_default: Timeout in seconds.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class StaticEntriesItem(AvdBase):
            _fields = ("_custom_data", "ipv4_address", "vrf", "mac_address")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv4_address: str = None
            """ARP entry IPv4 address."""
            vrf: str | None = None
            """ARP entry VRF."""
            mac_address: Annotated[str, Pattern[r"^[0-9A-Fa-f]{4}\.[0-9A-Fa-f]{4}\.[0-9A-Fa-f]{4}$"]] = None
            """ARP entry MAC address."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                ipv4_address: str = None,
                vrf: str | None = None,
                mac_address: Annotated[str, Pattern[r"^[0-9A-Fa-f]{4}\.[0-9A-Fa-f]{4}\.[0-9A-Fa-f]{4}$"]] = None,
            ) -> None:
                """
                StaticEntriesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4_address: ARP entry IPv4 address.
                    vrf: ARP entry VRF.
                    mac_address: ARP entry MAC address.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "persistent", "aging", "static_entries")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        persistent: Persistent | None = None
        aging: Aging | None = None
        static_entries: list[StaticEntriesItem] | None = None
        """Static ARP entries."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            persistent: Persistent | None = None,
            aging: Aging | None = None,
            static_entries: list[StaticEntriesItem] | None = None,
        ) -> None:
            """
            Arp.

            Args:
            -----
                _custom_data: _custom_data
                persistent: persistent
                aging: aging
                static_entries: Static ARP entries.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class AsPath(AvdBase):
        class AccessListsItem(AvdBase):
            class EntriesItem(AvdBase):
                _fields = ("_custom_data", "type", "match", "origin")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                type: Annotated[str, ValidValues["permit", "deny"]] | None = None
                match: str | None = None
                """Regex To Match."""
                origin: Annotated[str, ValidValues["any", "egp", "igp", "incomplete"]] | None = "any"

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    type: Annotated[str, ValidValues["permit", "deny"]] | None = None,
                    match: str | None = None,
                    origin: Annotated[str, ValidValues["any", "egp", "igp", "incomplete"]] | None = "any",
                ) -> None:
                    """
                    EntriesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        type: type
                        match: Regex To Match.
                        origin: origin

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "entries")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str | None = None
            """Access List Name."""
            entries: list[EntriesItem] | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, entries: list[EntriesItem] | None = None) -> None:
                """
                AccessListsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Access List Name.
                    entries: entries

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "regex_mode", "access_lists")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        regex_mode: Annotated[str, ValidValues["asn", "string"]] | None = None
        access_lists: list[AccessListsItem] | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            regex_mode: Annotated[str, ValidValues["asn", "string"]] | None = None,
            access_lists: list[AccessListsItem] | None = None,
        ) -> None:
            """
            AsPath.

            Args:
            -----
                _custom_data: _custom_data
                regex_mode: regex_mode
                access_lists: access_lists

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Banners(AvdBase):
        _fields = ("_custom_data", "login", "motd")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        login: str | None = None
        """Multiline string ending with EOF on the last line."""
        motd: str | None = None
        """Multiline string ending with EOF on the last line."""

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, login: str | None = None, motd: str | None = None) -> None:
            """
            Banners.

            Args:
            -----
                _custom_data: _custom_data
                login: Multiline string ending with EOF on the last line.
                motd: Multiline string ending with EOF on the last line.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class BgpGroupsItem(AvdBase):
        _fields = ("_custom_data", "name", "vrf", "neighbors", "bgp_maintenance_profiles")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Group Name."""
        vrf: str | None = None
        neighbors: list[str] | None = None
        bgp_maintenance_profiles: list[str] | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str = None,
            vrf: str | None = None,
            neighbors: list[str] | None = None,
            bgp_maintenance_profiles: list[str] | None = None,
        ) -> None:
            """
            BgpGroupsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Group Name.
                vrf: vrf
                neighbors: neighbors
                bgp_maintenance_profiles: bgp_maintenance_profiles

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Boot(AvdBase):
        class Secret(AvdBase):
            _fields = ("_custom_data", "hash_algorithm", "key")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            hash_algorithm: Annotated[str, ValidValues["md5", "sha512"]] | None = "sha512"
            key: str | None = None
            """Hashed Password."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                hash_algorithm: Annotated[str, ValidValues["md5", "sha512"]] | None = "sha512",
                key: str | None = None,
            ) -> None:
                """
                Secret.

                Args:
                -----
                    _custom_data: _custom_data
                    hash_algorithm: hash_algorithm
                    key: Hashed Password.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "secret")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        secret: Secret | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, secret: Secret | None = None) -> None:
            """
            Boot.

            Args:
            -----
                _custom_data: _custom_data
                secret: secret

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ClassMaps(AvdBase):
        class PbrItem(AvdBase):
            class Ip(AvdBase):
                _fields = ("_custom_data", "access_group")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                access_group: str | None = None
                """Standard Access-List Name."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, access_group: str | None = None) -> None:
                    """
                    Ip.

                    Args:
                    -----
                        _custom_data: _custom_data
                        access_group: Standard Access-List Name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "ip")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Class-Map Name."""
            ip: Ip | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, ip: Ip | None = None) -> None:
                """
                PbrItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Class-Map Name.
                    ip: ip

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class QosItem(AvdBase):
            class Ip(AvdBase):
                _fields = ("_custom_data", "access_group")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                access_group: str | None = None
                """IPv4 Access-List Name."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, access_group: str | None = None) -> None:
                    """
                    Ip.

                    Args:
                    -----
                        _custom_data: _custom_data
                        access_group: IPv4 Access-List Name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv6(AvdBase):
                _fields = ("_custom_data", "access_group")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                access_group: str | None = None
                """IPv6 Access-List Name."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, access_group: str | None = None) -> None:
                    """
                    Ipv6.

                    Args:
                    -----
                        _custom_data: _custom_data
                        access_group: IPv6 Access-List Name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "vlan", "cos", "ip", "ipv6")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Class-Map Name."""
            vlan: str | None = None
            """VLAN value(s) or range(s) of VLAN values."""
            cos: str | None = None
            """CoS value(s) or range(s) of CoS values."""
            ip: Ip | None = None
            ipv6: Ipv6 | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                vlan: str | None = None,
                cos: str | None = None,
                ip: Ip | None = None,
                ipv6: Ipv6 | None = None,
            ) -> None:
                """
                QosItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Class-Map Name.
                    vlan: VLAN value(s) or range(s) of VLAN values.
                    cos: CoS value(s) or range(s) of CoS values.
                    ip: ip
                    ipv6: ipv6

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "pbr", "qos")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        pbr: list[PbrItem] | None = None
        qos: list[QosItem] | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, pbr: list[PbrItem] | None = None, qos: list[QosItem] | None = None) -> None:
            """
            ClassMaps.

            Args:
            -----
                _custom_data: _custom_data
                pbr: pbr
                qos: qos

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Clock(AvdBase):
        _fields = ("_custom_data", "timezone")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        timezone: str | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, timezone: str | None = None) -> None:
            """
            Clock.

            Args:
            -----
                _custom_data: _custom_data
                timezone: timezone

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class CommunityListsItem(AvdBase):
        _fields = ("_custom_data", "name", "action")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Community-list Name."""
        action: str = None
        """
        Action as string.
        Example: "permit GSHUT 65123:123"
        """

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, action: str = None) -> None:
            """
            CommunityListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Community-list Name.
                action:
                   Action as string.
                   Example: "permit GSHUT 65123:123"

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Cvx(AvdBase):
        class Services(AvdBase):
            class Mcs(AvdBase):
                class Redis(AvdBase):
                    _fields = ("_custom_data", "password", "password_type")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    password: str | None = None
                    """Hashed password using the password_type."""
                    password_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = "7"

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        password: str | None = None,
                        password_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = "7",
                    ) -> None:
                        """
                        Redis.

                        Args:
                        -----
                            _custom_data: _custom_data
                            password: Hashed password using the password_type.
                            password_type: password_type

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "redis", "shutdown")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                redis: Redis | None = None
                shutdown: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, redis: Redis | None = None, shutdown: bool | None = None) -> None:
                    """
                    Mcs.

                    Args:
                    -----
                        _custom_data: _custom_data
                        redis: redis
                        shutdown: shutdown

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Vxlan(AvdBase):
                _fields = ("_custom_data", "shutdown", "vtep_mac_learning")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                shutdown: bool | None = None
                vtep_mac_learning: Annotated[str, ValidValues["control-plane", "data-plane"]] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    shutdown: bool | None = None,
                    vtep_mac_learning: Annotated[str, ValidValues["control-plane", "data-plane"]] | None = None,
                ) -> None:
                    """
                    Vxlan.

                    Args:
                    -----
                        _custom_data: _custom_data
                        shutdown: shutdown
                        vtep_mac_learning: vtep_mac_learning

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "mcs", "vxlan")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            mcs: Mcs | None = None
            vxlan: Vxlan | None = None
            """VXLAN Controller service."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, mcs: Mcs | None = None, vxlan: Vxlan | None = None) -> None:
                """
                Services.

                Args:
                -----
                    _custom_data: _custom_data
                    mcs: mcs
                    vxlan: VXLAN Controller service.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "shutdown", "peer_hosts", "services")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        shutdown: bool | None = None
        peer_hosts: list[str] | None = None
        services: Services | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            shutdown: bool | None = None,
            peer_hosts: list[str] | None = None,
            services: Services | None = None,
        ) -> None:
            """
            Cvx.

            Args:
            -----
                _custom_data: _custom_data
                shutdown: shutdown
                peer_hosts: peer_hosts
                services: services

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class DaemonTerminattr(AvdBase):
        class ClustersItem(AvdBase):
            class Cvauth(AvdBase):
                _fields = ("_custom_data", "method", "key", "token_file", "cert_file", "ca_file", "key_file")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                method: Annotated[str, ValidValues["token", "token-secure", "key", "certs"]] | None = None
                key: str | None = None
                token_file: str | None = None
                """
                Token file path.
                e.g. "/tmp/token"
                """
                cert_file: str | None = None
                """
                Client certificate file path.
                e.g. "/persist/secure/ssl/terminattr/primary/certs/client.crt"
                """
                ca_file: str | None = None
                """
                CA certificate file path (on-prem only).
                e.g. "/persist/secure/ssl/terminattr/primary/certs/ca.crt"
                """
                key_file: str | None = None
                """
                Client certificate key file path.
                e.g. "/persist/secure/ssl/terminattr/primary/keys/client.key"
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    method: Annotated[str, ValidValues["token", "token-secure", "key", "certs"]] | None = None,
                    key: str | None = None,
                    token_file: str | None = None,
                    cert_file: str | None = None,
                    ca_file: str | None = None,
                    key_file: str | None = None,
                ) -> None:
                    """
                    Cvauth.

                    Args:
                    -----
                        _custom_data: _custom_data
                        method: method
                        key: key
                        token_file:
                           Token file path.
                           e.g. "/tmp/token"
                        cert_file:
                           Client certificate file path.
                           e.g. "/persist/secure/ssl/terminattr/primary/certs/client.crt"
                        ca_file:
                           CA certificate file path (on-prem only).
                           e.g. "/persist/secure/ssl/terminattr/primary/certs/ca.crt"
                        key_file:
                           Client certificate key file path.
                           e.g. "/persist/secure/ssl/terminattr/primary/keys/client.key"

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "cvaddrs", "cvauth", "cvobscurekeyfile", "cvproxy", "cvsourceip", "cvsourceintf", "cvvrf")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Cluster Name."""
            cvaddrs: list[str] | None = None
            """
            Streaming address(es) for CloudVision cluster.
            - TCP 9910 is used for CV on-prem
            - TCP 443 is used
            for CV as a Service
            """
            cvauth: Cvauth | None = None
            """Authentication scheme used to connect to CloudVision."""
            cvobscurekeyfile: bool | None = None
            """Encrypt the private key used for authentication to CloudVision."""
            cvproxy: str | None = None
            """
            Proxy server through which CloudVision is reachable. Useful when the CloudVision server is hosted in
            the cloud.
            The expected form is http://[user:password@]ip:port, e.g.:
            `http://arista:arista@10.83.12.78:3128`. Available as of TerminAttr v1.13.0.
            """
            cvsourceip: str | None = None
            """Set source IP address in case of in-band management."""
            cvsourceintf: str | None = None
            """
            Set source interface in case of in-band management. Available as of TerminAttr v1.23.0.
            The
            interface name is case sensitive and has to match the interface name in the running-config,
            e.g.:Vlan100.
            """
            cvvrf: str | None = None
            """The VRF to use to connect to CloudVision."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                cvaddrs: list[str] | None = None,
                cvauth: Cvauth | None = None,
                cvobscurekeyfile: bool | None = None,
                cvproxy: str | None = None,
                cvsourceip: str | None = None,
                cvsourceintf: str | None = None,
                cvvrf: str | None = None,
            ) -> None:
                """
                ClustersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Cluster Name.
                    cvaddrs:
                       Streaming address(es) for CloudVision cluster.
                       - TCP 9910 is used for CV on-prem
                       - TCP 443 is used
                       for CV as a Service
                    cvauth: Authentication scheme used to connect to CloudVision.
                    cvobscurekeyfile: Encrypt the private key used for authentication to CloudVision.
                    cvproxy:
                       Proxy server through which CloudVision is reachable. Useful when the CloudVision server is hosted in
                       the cloud.
                       The expected form is http://[user:password@]ip:port, e.g.:
                       `http://arista:arista@10.83.12.78:3128`. Available as of TerminAttr v1.13.0.
                    cvsourceip: Set source IP address in case of in-band management.
                    cvsourceintf:
                       Set source interface in case of in-band management. Available as of TerminAttr v1.23.0.
                       The
                       interface name is case sensitive and has to match the interface name in the running-config,
                       e.g.:Vlan100.
                    cvvrf: The VRF to use to connect to CloudVision.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Cvauth(AvdBase):
            _fields = ("_custom_data", "method", "key", "token_file", "cert_file", "ca_file", "key_file")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            method: Annotated[str, ValidValues["token", "token-secure", "key", "certs"]] | None = None
            key: str | None = None
            token_file: str | None = None
            """
            Token file path.
            e.g. "/tmp/token"
            """
            cert_file: str | None = None
            """
            Client certificate file path.
            e.g. "/persist/secure/ssl/terminattr/primary/certs/client.crt"
            """
            ca_file: str | None = None
            """
            CA certificate file path (on-prem only).
            e.g. "/persist/secure/ssl/terminattr/primary/certs/ca.crt"
            """
            key_file: str | None = None
            """
            Client certificate key file path.
            e.g. "/persist/secure/ssl/terminattr/primary/keys/client.key"
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                method: Annotated[str, ValidValues["token", "token-secure", "key", "certs"]] | None = None,
                key: str | None = None,
                token_file: str | None = None,
                cert_file: str | None = None,
                ca_file: str | None = None,
                key_file: str | None = None,
            ) -> None:
                """
                Cvauth.

                Args:
                -----
                    _custom_data: _custom_data
                    method: method
                    key: key
                    token_file:
                       Token file path.
                       e.g. "/tmp/token"
                    cert_file:
                       Client certificate file path.
                       e.g. "/persist/secure/ssl/terminattr/primary/certs/client.crt"
                    ca_file:
                       CA certificate file path (on-prem only).
                       e.g. "/persist/secure/ssl/terminattr/primary/certs/ca.crt"
                    key_file:
                       Client certificate key file path.
                       e.g. "/persist/secure/ssl/terminattr/primary/keys/client.key"

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "cvaddrs",
            "clusters",
            "cvauth",
            "cvobscurekeyfile",
            "cvproxy",
            "cvsourceip",
            "cvsourceintf",
            "cvvrf",
            "cvgnmi",
            "disable_aaa",
            "grpcaddr",
            "grpcreadonly",
            "ingestexclude",
            "smashexcludes",
            "taillogs",
            "ecodhcpaddr",
            "ipfix",
            "ipfixaddr",
            "sflow",
            "sflowaddr",
            "cvconfig",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        cvaddrs: list[str] | None = None
        """
        Streaming address(es) for CloudVision single cluster.
        - TCP 9910 is used for CV on-prem
        - TCP 443 is
        used for CV as a Service
        """
        clusters: list[ClustersItem] | None = None
        """Multiple CloudVision clusters."""
        cvauth: Cvauth | None = None
        """Authentication scheme used to connect to CloudVision."""
        cvobscurekeyfile: bool | None = None
        """Encrypt the private key used for authentication to CloudVision."""
        cvproxy: str | None = None
        """
        Proxy server through which CloudVision is reachable. Useful when the CloudVision server is hosted in
        the cloud.
        The expected form is http://[user:password@]ip:port, e.g.:
        `http://arista:arista@10.83.12.78:3128`. Available as of TerminAttr v1.13.0.
        """
        cvsourceip: str | None = None
        """Set source IP address in case of in-band management."""
        cvsourceintf: str | None = None
        """
        Set source interface in case of in-band management.
        The interface name is case sensitive and has to
        match the interface name in the running-config, e.g.:Vlan100.
        """
        cvvrf: str | None = None
        """The VRF to use to connect to CloudVision."""
        cvgnmi: bool | None = None
        """Stream states from EOS gNMI servers (Openconfig) to CloudVision. Available as of TerminAttr v1.13.1."""
        disable_aaa: bool | None = None
        """
        Disable AAA authorization and accounting.
        When setting this flag, all commands pushed from
        CloudVision are applied directly to the CLI without authorization.
        """
        grpcaddr: str | None = None
        """
        Set the gRPC server address, the default is 127.0.0.1:6042.
        e.g. "MGMT/0.0.0.0:6042"
        """
        grpcreadonly: bool | None = None
        """gNMI read-only mode - Disable gnmi.Set()."""
        ingestexclude: str | None = None
        """
        Exclude paths from Sysdb on the ingest side.
        e.g. "/Sysdb/cell/1/agent,/Sysdb/cell/2/agent"
        """
        smashexcludes: str | None = None
        """
        Exclude paths from the shared memory table.
        e.g. "ale,flexCounter,hardware,kni,pulse,strata"
        """
        taillogs: str | None = None
        """
        Enable log file collection; /var/log/messages is streamed by default if no path is set.
        e.g.
        "/var/log/messages"
        """
        ecodhcpaddr: str | None = None
        """
        ECO DHCP Collector address or ECO DHCP Fingerprint listening address in standalone mode (default
        "127.0.0.1:67").
        """
        ipfix: bool | None = None
        """
        Enable IPFIX provider (TerminAttr default is true).
        This flag is enabled by default and does not
        have to be added to the daemon configuration.
        """
        ipfixaddr: str | None = None
        """
        ECO IPFIX Collector address to listen on to receive IPFIX packets (TerminAttr default
        "127.0.0.1:4739").
        """
        sflow: bool | None = None
        """Enable sFlow provider (TerminAttr default is true)."""
        sflowaddr: str | None = None
        """
        ECO sFlow Collector address to listen on to receive sFlow packets (TerminAttr default
        "127.0.0.1:6343").
        """
        cvconfig: bool | None = None
        """Subscribe to dynamic device configuration from CloudVision (TerminAttr default is false)."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            cvaddrs: list[str] | None = None,
            clusters: list[ClustersItem] | None = None,
            cvauth: Cvauth | None = None,
            cvobscurekeyfile: bool | None = None,
            cvproxy: str | None = None,
            cvsourceip: str | None = None,
            cvsourceintf: str | None = None,
            cvvrf: str | None = None,
            cvgnmi: bool | None = None,
            disable_aaa: bool | None = None,
            grpcaddr: str | None = None,
            grpcreadonly: bool | None = None,
            ingestexclude: str | None = None,
            smashexcludes: str | None = None,
            taillogs: str | None = None,
            ecodhcpaddr: str | None = None,
            ipfix: bool | None = None,
            ipfixaddr: str | None = None,
            sflow: bool | None = None,
            sflowaddr: str | None = None,
            cvconfig: bool | None = None,
        ) -> None:
            """
            DaemonTerminattr.

            Args:
            -----
                _custom_data: _custom_data
                cvaddrs:
                   Streaming address(es) for CloudVision single cluster.
                   - TCP 9910 is used for CV on-prem
                   - TCP 443 is
                   used for CV as a Service
                clusters: Multiple CloudVision clusters.
                cvauth: Authentication scheme used to connect to CloudVision.
                cvobscurekeyfile: Encrypt the private key used for authentication to CloudVision.
                cvproxy:
                   Proxy server through which CloudVision is reachable. Useful when the CloudVision server is hosted in
                   the cloud.
                   The expected form is http://[user:password@]ip:port, e.g.:
                   `http://arista:arista@10.83.12.78:3128`. Available as of TerminAttr v1.13.0.
                cvsourceip: Set source IP address in case of in-band management.
                cvsourceintf:
                   Set source interface in case of in-band management.
                   The interface name is case sensitive and has to
                   match the interface name in the running-config, e.g.:Vlan100.
                cvvrf: The VRF to use to connect to CloudVision.
                cvgnmi: Stream states from EOS gNMI servers (Openconfig) to CloudVision. Available as of TerminAttr v1.13.1.
                disable_aaa:
                   Disable AAA authorization and accounting.
                   When setting this flag, all commands pushed from
                   CloudVision are applied directly to the CLI without authorization.
                grpcaddr:
                   Set the gRPC server address, the default is 127.0.0.1:6042.
                   e.g. "MGMT/0.0.0.0:6042"
                grpcreadonly: gNMI read-only mode - Disable gnmi.Set().
                ingestexclude:
                   Exclude paths from Sysdb on the ingest side.
                   e.g. "/Sysdb/cell/1/agent,/Sysdb/cell/2/agent"
                smashexcludes:
                   Exclude paths from the shared memory table.
                   e.g. "ale,flexCounter,hardware,kni,pulse,strata"
                taillogs:
                   Enable log file collection; /var/log/messages is streamed by default if no path is set.
                   e.g.
                   "/var/log/messages"
                ecodhcpaddr:
                   ECO DHCP Collector address or ECO DHCP Fingerprint listening address in standalone mode (default
                   "127.0.0.1:67").
                ipfix:
                   Enable IPFIX provider (TerminAttr default is true).
                   This flag is enabled by default and does not
                   have to be added to the daemon configuration.
                ipfixaddr:
                   ECO IPFIX Collector address to listen on to receive IPFIX packets (TerminAttr default
                   "127.0.0.1:4739").
                sflow: Enable sFlow provider (TerminAttr default is true).
                sflowaddr:
                   ECO sFlow Collector address to listen on to receive sFlow packets (TerminAttr default
                   "127.0.0.1:6343").
                cvconfig: Subscribe to dynamic device configuration from CloudVision (TerminAttr default is false).

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class DaemonsItem(AvdBase):
        _fields = ("_custom_data", "name", "exec", "enabled")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Daemon Name."""
        exec: str = None
        """command to run as a daemon."""
        enabled: bool | None = True

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, exec: str = None, enabled: bool | None = True) -> None:
            """
            DaemonsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Daemon Name.
                exec: command to run as a daemon.
                enabled: enabled

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class DhcpRelay(AvdBase):
        _fields = ("_custom_data", "servers", "tunnel_requests_disabled", "mlag_peerlink_requests_disabled")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        servers: list[str] | None = None
        tunnel_requests_disabled: bool | None = None
        mlag_peerlink_requests_disabled: bool | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            servers: list[str] | None = None,
            tunnel_requests_disabled: bool | None = None,
            mlag_peerlink_requests_disabled: bool | None = None,
        ) -> None:
            """
            DhcpRelay.

            Args:
            -----
                _custom_data: _custom_data
                servers: servers
                tunnel_requests_disabled: tunnel_requests_disabled
                mlag_peerlink_requests_disabled: mlag_peerlink_requests_disabled

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class DhcpServersItem(AvdBase):
        class LeaseTimeIpv4(AvdBase):
            _fields = ("_custom_data", "days", "hours", "minutes")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            days: Annotated[int, Max[2000]] = None
            hours: Annotated[int, Max[23]] = None
            minutes: Annotated[int, Max[59]] = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                days: Annotated[int, Max[2000]] = None,
                hours: Annotated[int, Max[23]] = None,
                minutes: Annotated[int, Max[59]] = None,
            ) -> None:
                """
                LeaseTimeIpv4.

                Args:
                -----
                    _custom_data: _custom_data
                    days: days
                    hours: hours
                    minutes: minutes

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class LeaseTimeIpv6(AvdBase):
            _fields = ("_custom_data", "days", "hours", "minutes")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            days: Annotated[int, Max[2000]] = None
            hours: Annotated[int, Max[23]] = None
            minutes: Annotated[int, Max[59]] = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                days: Annotated[int, Max[2000]] = None,
                hours: Annotated[int, Max[23]] = None,
                minutes: Annotated[int, Max[59]] = None,
            ) -> None:
                """
                LeaseTimeIpv6.

                Args:
                -----
                    _custom_data: _custom_data
                    days: days
                    hours: hours
                    minutes: minutes

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TftpServer(AvdBase):
            _fields = ("_custom_data", "file_ipv4", "file_ipv6")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            file_ipv4: Annotated[str, MinLen[1], MaxLen[255]] | None = None
            """Name of TFTP file for IPv4 clients."""
            file_ipv6: Annotated[str, MinLen[1], MaxLen[255]] | None = None
            """Name of TFTP file for IPv6 clients."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                file_ipv4: Annotated[str, MinLen[1], MaxLen[255]] | None = None,
                file_ipv6: Annotated[str, MinLen[1], MaxLen[255]] | None = None,
            ) -> None:
                """
                TftpServer.

                Args:
                -----
                    _custom_data: _custom_data
                    file_ipv4: Name of TFTP file for IPv4 clients.
                    file_ipv6: Name of TFTP file for IPv6 clients.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv4VendorOptionsItem(AvdBase):
            class SubOptionsItem(AvdBase):
                _fields = ("_custom_data", "code", "string", "ipv4_address", "array_ipv4_address")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                code: Annotated[int, Min[1], Max[254]] = None
                string: str | None = None
                """
                String value for suboption data.
                Only one of `string`, `ipv4_address` and `array_ipv4_address`
                variables should be used for any one suboption.
                The order of precedence if multiple of these
                variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                """
                ipv4_address: str | None = None
                """
                IPv4 address value for suboption data.
                Only one of `string`, `ipv4_address` and `array_ipv4_address`
                variables should be used for any one suboption.
                The order of precedence if multiple of these
                variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                """
                array_ipv4_address: list[str] | None = None
                """
                Array of IPv4 addresses for suboption data.
                Only one of `string`, `ipv4_address` and
                `array_ipv4_address` variables should be used for any one suboption.
                The order of precedence if
                multiple of these variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    code: Annotated[int, Min[1], Max[254]] = None,
                    string: str | None = None,
                    ipv4_address: str | None = None,
                    array_ipv4_address: list[str] | None = None,
                ) -> None:
                    """
                    SubOptionsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        code: code
                        string:
                           String value for suboption data.
                           Only one of `string`, `ipv4_address` and `array_ipv4_address`
                           variables should be used for any one suboption.
                           The order of precedence if multiple of these
                           variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                        ipv4_address:
                           IPv4 address value for suboption data.
                           Only one of `string`, `ipv4_address` and `array_ipv4_address`
                           variables should be used for any one suboption.
                           The order of precedence if multiple of these
                           variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                        array_ipv4_address:
                           Array of IPv4 addresses for suboption data.
                           Only one of `string`, `ipv4_address` and
                           `array_ipv4_address` variables should be used for any one suboption.
                           The order of precedence if
                           multiple of these variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "vendor_id", "sub_options")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            vendor_id: str = None
            sub_options: list[SubOptionsItem] | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, vendor_id: str = None, sub_options: list[SubOptionsItem] | None = None) -> None:
                """
                Ipv4VendorOptionsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    vendor_id: vendor_id
                    sub_options: sub_options

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SubnetsItem(AvdBase):
            class RangesItem(AvdBase):
                _fields = ("_custom_data", "start", "end")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                start: str = None
                end: str = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, start: str = None, end: str = None) -> None:
                    """
                    RangesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        start: start
                        end: end

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class LeaseTime(AvdBase):
                _fields = ("_custom_data", "days", "hours", "minutes")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                days: Annotated[int, Max[2000]] = None
                hours: Annotated[int, Max[23]] = None
                minutes: Annotated[int, Max[59]] = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    days: Annotated[int, Max[2000]] = None,
                    hours: Annotated[int, Max[23]] = None,
                    minutes: Annotated[int, Max[59]] = None,
                ) -> None:
                    """
                    LeaseTime.

                    Args:
                    -----
                        _custom_data: _custom_data
                        days: days
                        hours: hours
                        minutes: minutes

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class ReservationsItem(AvdBase):
                _fields = ("_custom_data", "mac_address", "hostname", "ipv4_address", "ipv6_address")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                mac_address: str = None
                """Ethernet address in format - HHHH.HHHH.HHHH"""
                hostname: str | None = None
                ipv4_address: str | None = None
                """
                Valid IPv4 address from the given subnet.
                This should only be used within an IPv4 subnet.
                """
                ipv6_address: str | None = None
                """
                Valid IPv6 address from the given subnet.
                This should only be used within an IPv6 subnet.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    mac_address: str = None,
                    hostname: str | None = None,
                    ipv4_address: str | None = None,
                    ipv6_address: str | None = None,
                ) -> None:
                    """
                    ReservationsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        mac_address: Ethernet address in format - HHHH.HHHH.HHHH
                        hostname: hostname
                        ipv4_address:
                           Valid IPv4 address from the given subnet.
                           This should only be used within an IPv4 subnet.
                        ipv6_address:
                           Valid IPv6 address from the given subnet.
                           This should only be used within an IPv6 subnet.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "subnet", "name", "default_gateway", "dns_servers", "ranges", "lease_time", "reservations")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            subnet: str = None
            """IPv4/IPv6 subnet."""
            name: str | None = None
            default_gateway: str | None = None
            dns_servers: list[str] | None = None
            ranges: list[RangesItem] | None = None
            lease_time: LeaseTime | None = None
            reservations: list[ReservationsItem] | None = None
            """DHCP client reservations."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                subnet: str = None,
                name: str | None = None,
                default_gateway: str | None = None,
                dns_servers: list[str] | None = None,
                ranges: list[RangesItem] | None = None,
                lease_time: LeaseTime | None = None,
                reservations: list[ReservationsItem] | None = None,
            ) -> None:
                """
                SubnetsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    subnet: IPv4/IPv6 subnet.
                    name: name
                    default_gateway: default_gateway
                    dns_servers: dns_servers
                    ranges: ranges
                    lease_time: lease_time
                    reservations: DHCP client reservations.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "disabled",
            "vrf",
            "lease_time_ipv4",
            "lease_time_ipv6",
            "dns_domain_name_ipv4",
            "dns_domain_name_ipv6",
            "dns_servers_ipv4",
            "dns_servers_ipv6",
            "tftp_server",
            "ipv4_vendor_options",
            "subnets",
            "eos_cli",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        disabled: bool | None = None
        vrf: str = None
        """VRF in which to configure the DHCP server, use `default` to indicate default VRF."""
        lease_time_ipv4: LeaseTimeIpv4 | None = None
        lease_time_ipv6: LeaseTimeIpv6 | None = None
        dns_domain_name_ipv4: str | None = None
        dns_domain_name_ipv6: str | None = None
        dns_servers_ipv4: list[str] | None = None
        """List of DNS servers for IPv4 clients."""
        dns_servers_ipv6: list[str] | None = None
        """List of DNS servers for IPv6 clients."""
        tftp_server: TftpServer | None = None
        ipv4_vendor_options: list[Ipv4VendorOptionsItem] | None = None
        subnets: list[SubnetsItem] | None = None
        eos_cli: str | None = None
        """Multiline EOS CLI rendered directly on the dhcp server in the final EOS configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            disabled: bool | None = None,
            vrf: str = None,
            lease_time_ipv4: LeaseTimeIpv4 | None = None,
            lease_time_ipv6: LeaseTimeIpv6 | None = None,
            dns_domain_name_ipv4: str | None = None,
            dns_domain_name_ipv6: str | None = None,
            dns_servers_ipv4: list[str] | None = None,
            dns_servers_ipv6: list[str] | None = None,
            tftp_server: TftpServer | None = None,
            ipv4_vendor_options: list[Ipv4VendorOptionsItem] | None = None,
            subnets: list[SubnetsItem] | None = None,
            eos_cli: str | None = None,
        ) -> None:
            """
            DhcpServersItem.

            Args:
            -----
                _custom_data: _custom_data
                disabled: disabled
                vrf: VRF in which to configure the DHCP server, use `default` to indicate default VRF.
                lease_time_ipv4: lease_time_ipv4
                lease_time_ipv6: lease_time_ipv6
                dns_domain_name_ipv4: dns_domain_name_ipv4
                dns_domain_name_ipv6: dns_domain_name_ipv6
                dns_servers_ipv4: List of DNS servers for IPv4 clients.
                dns_servers_ipv6: List of DNS servers for IPv6 clients.
                tftp_server: tftp_server
                ipv4_vendor_options: ipv4_vendor_options
                subnets: subnets
                eos_cli: Multiline EOS CLI rendered directly on the dhcp server in the final EOS configuration.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Dot1x(AvdBase):
        class MacBasedAuthentication(AvdBase):
            _fields = ("_custom_data", "delay", "hold_period")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            delay: Annotated[int, Max[300]] | None = None
            hold_period: Annotated[int, Min[1], Max[300]] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                delay: Annotated[int, Max[300]] | None = None,
                hold_period: Annotated[int, Min[1], Max[300]] | None = None,
            ) -> None:
                """
                MacBasedAuthentication.

                Args:
                -----
                    _custom_data: _custom_data
                    delay: delay
                    hold_period: hold_period

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class RadiusAvPairUsernameFormat(AvdBase):
            _fields = ("_custom_data", "delimiter", "mac_string_case")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            delimiter: Annotated[str, ValidValues["colon", "hyphen", "none", "period"]] = None
            """Delimiter to use in MAC address string."""
            mac_string_case: Annotated[str, ValidValues["lowercase", "uppercase"]] = None
            """MAC address string in lowercase/uppercase."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                delimiter: Annotated[str, ValidValues["colon", "hyphen", "none", "period"]] = None,
                mac_string_case: Annotated[str, ValidValues["lowercase", "uppercase"]] = None,
            ) -> None:
                """
                RadiusAvPairUsernameFormat.

                Args:
                -----
                    _custom_data: _custom_data
                    delimiter: Delimiter to use in MAC address string.
                    mac_string_case: MAC address string in lowercase/uppercase.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class RadiusAvPair(AvdBase):
            _fields = ("_custom_data", "service_type", "framed_mtu")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            service_type: bool | None = None
            framed_mtu: Annotated[int, Min[68], Max[9236]] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                service_type: bool | None = None,
                framed_mtu: Annotated[int, Min[68], Max[9236]] | None = None,
            ) -> None:
                """
                RadiusAvPair.

                Args:
                -----
                    _custom_data: _custom_data
                    service_type: service_type
                    framed_mtu: framed_mtu

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Aaa(AvdBase):
            class Unresponsive(AvdBase):
                class Action(AvdBase):
                    class CachedResultsTimeout(AvdBase):
                        _fields = ("_custom_data", "time_duration", "time_duration_unit")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        time_duration: Annotated[int, Min[1]] | None = None
                        """
                        Enable caching for a specific duration -
                        <1-10000>      duration in days
                        <1-14400000>   duration in
                        minutes
                        <1-240000>     duration in hours
                        <1-864000000>  duration in seconds
                        """
                        time_duration_unit: Annotated[str, ValidValues["days", "hours", "minutes", "seconds"]] = None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            time_duration: Annotated[int, Min[1]] | None = None,
                            time_duration_unit: Annotated[str, ValidValues["days", "hours", "minutes", "seconds"]] = None,
                        ) -> None:
                            """
                            CachedResultsTimeout.

                            Args:
                            -----
                                _custom_data: _custom_data
                                time_duration:
                                   Enable caching for a specific duration -
                                   <1-10000>      duration in days
                                   <1-14400000>   duration in
                                   minutes
                                   <1-240000>     duration in hours
                                   <1-864000000>  duration in seconds
                                time_duration_unit: time_duration_unit

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "apply_cached_results", "cached_results_timeout", "apply_alternate", "traffic_allow", "traffic_allow_vlan")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    apply_cached_results: bool | None = None
                    """Use results from a previous AAA response."""
                    cached_results_timeout: CachedResultsTimeout | None = None
                    apply_alternate: bool | None = None
                    """
                    Apply alternate action if primary action fails.
                    eg. aaa unresponsive action apply cached-results
                    else traffic allow
                    """
                    traffic_allow: bool | None = None
                    """Set action for supplicant traffic when AAA times out."""
                    traffic_allow_vlan: Annotated[int, Min[1], Max[4094]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        apply_cached_results: bool | None = None,
                        cached_results_timeout: CachedResultsTimeout | None = None,
                        apply_alternate: bool | None = None,
                        traffic_allow: bool | None = None,
                        traffic_allow_vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                    ) -> None:
                        """
                        Action.

                        Args:
                        -----
                            _custom_data: _custom_data
                            apply_cached_results: Use results from a previous AAA response.
                            cached_results_timeout: cached_results_timeout
                            apply_alternate:
                               Apply alternate action if primary action fails.
                               eg. aaa unresponsive action apply cached-results
                               else traffic allow
                            traffic_allow: Set action for supplicant traffic when AAA times out.
                            traffic_allow_vlan: traffic_allow_vlan

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class PhoneAction(AvdBase):
                    class CachedResultsTimeout(AvdBase):
                        _fields = ("_custom_data", "time_duration", "time_duration_unit")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        time_duration: Annotated[int, Min[1]] | None = None
                        """
                        Enable caching for a specific duration -
                        <1-10000>      duration in days
                        <1-14400000>   duration in
                        minutes
                        <1-240000>     duration in hours
                        <1-864000000>  duration in seconds
                        """
                        time_duration_unit: Annotated[str, ValidValues["days", "hours", "minutes", "seconds"]] = None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            time_duration: Annotated[int, Min[1]] | None = None,
                            time_duration_unit: Annotated[str, ValidValues["days", "hours", "minutes", "seconds"]] = None,
                        ) -> None:
                            """
                            CachedResultsTimeout.

                            Args:
                            -----
                                _custom_data: _custom_data
                                time_duration:
                                   Enable caching for a specific duration -
                                   <1-10000>      duration in days
                                   <1-14400000>   duration in
                                   minutes
                                   <1-240000>     duration in hours
                                   <1-864000000>  duration in seconds
                                time_duration_unit: time_duration_unit

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "apply_cached_results", "cached_results_timeout", "apply_alternate", "traffic_allow")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    apply_cached_results: bool | None = None
                    """Use results from a previous AAA response."""
                    cached_results_timeout: CachedResultsTimeout | None = None
                    apply_alternate: bool | None = None
                    """
                    Apply alternate action if primary action fails.
                    eg. aaa unresponsive phone action apply cached-
                    results else traffic allow
                    """
                    traffic_allow: bool | None = None
                    """Set action for supplicant traffic when AAA times out."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        apply_cached_results: bool | None = None,
                        cached_results_timeout: CachedResultsTimeout | None = None,
                        apply_alternate: bool | None = None,
                        traffic_allow: bool | None = None,
                    ) -> None:
                        """
                        PhoneAction.

                        Args:
                        -----
                            _custom_data: _custom_data
                            apply_cached_results: Use results from a previous AAA response.
                            cached_results_timeout: cached_results_timeout
                            apply_alternate:
                               Apply alternate action if primary action fails.
                               eg. aaa unresponsive phone action apply cached-
                               results else traffic allow
                            traffic_allow: Set action for supplicant traffic when AAA times out.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "eap_response", "action", "phone_action", "recovery_action_reauthenticate")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                eap_response: Annotated[str, ValidValues["success", "disabled"]] | None = None
                """EAP response to send."""
                action: Action | None = None
                """Set action for supplicant when AAA times out."""
                phone_action: PhoneAction | None = None
                """Set action for supplicant when AAA times out."""
                recovery_action_reauthenticate: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    eap_response: Annotated[str, ValidValues["success", "disabled"]] | None = None,
                    action: Action | None = None,
                    phone_action: PhoneAction | None = None,
                    recovery_action_reauthenticate: bool | None = None,
                ) -> None:
                    """
                    Unresponsive.

                    Args:
                    -----
                        _custom_data: _custom_data
                        eap_response: EAP response to send.
                        action: Set action for supplicant when AAA times out.
                        phone_action: Set action for supplicant when AAA times out.
                        recovery_action_reauthenticate: recovery_action_reauthenticate

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "unresponsive", "accounting_update_interval")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            unresponsive: Unresponsive | None = None
            """Configure AAA timeout options."""
            accounting_update_interval: Annotated[int, Min[5], Max[65535]] | None = None
            """Interval period in seconds."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                unresponsive: Unresponsive | None = None,
                accounting_update_interval: Annotated[int, Min[5], Max[65535]] | None = None,
            ) -> None:
                """
                Aaa.

                Args:
                -----
                    _custom_data: _custom_data
                    unresponsive: Configure AAA timeout options.
                    accounting_update_interval: Interval period in seconds.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class CaptivePortal(AvdBase):
            _fields = ("_custom_data", "enabled", "url", "ssl_profile", "start_limit_infinite", "access_list_ipv4")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool = None
            url: str | None = None
            """
            Supported URL type:
              - http: http://<hostname>[:<port>]
              - https: https://<hostname>[:<port>]
            """
            ssl_profile: str | None = None
            start_limit_infinite: bool | None = None
            """Set captive-portal start limit to infinite."""
            access_list_ipv4: str | None = None
            """Standard access-list name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enabled: bool = None,
                url: str | None = None,
                ssl_profile: str | None = None,
                start_limit_infinite: bool | None = None,
                access_list_ipv4: str | None = None,
            ) -> None:
                """
                CaptivePortal.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    url:
                       Supported URL type:
                         - http: http://<hostname>[:<port>]
                         - https: https://<hostname>[:<port>]
                    ssl_profile: ssl_profile
                    start_limit_infinite: Set captive-portal start limit to infinite.
                    access_list_ipv4: Standard access-list name.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Supplicant(AvdBase):
            class ProfilesItem(AvdBase):
                _fields = ("_custom_data", "name", "eap_method", "identity", "passphrase_type", "passphrase", "ssl_profile")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                eap_method: Annotated[str, ValidValues["fast", "tls"]] | None = None
                """
                Extensible Authentication Protocol method:
                  - EAP Flexible Authentication via Secure Tunneling.
                  -
                EAP with Transport Layer Security.
                """
                identity: str | None = None
                """User identity."""
                passphrase_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = "7"
                passphrase: str | None = None
                """Extensible Authentication Protocol password."""
                ssl_profile: str | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    eap_method: Annotated[str, ValidValues["fast", "tls"]] | None = None,
                    identity: str | None = None,
                    passphrase_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = "7",
                    passphrase: str | None = None,
                    ssl_profile: str | None = None,
                ) -> None:
                    """
                    ProfilesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        eap_method:
                           Extensible Authentication Protocol method:
                             - EAP Flexible Authentication via Secure Tunneling.
                             -
                           EAP with Transport Layer Security.
                        identity: User identity.
                        passphrase_type: passphrase_type
                        passphrase: Extensible Authentication Protocol password.
                        ssl_profile: ssl_profile

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "profiles", "logging", "disconnect_cached_results_timeout")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            profiles: list[ProfilesItem] | None = None
            """Dot1x supplicant profiles."""
            logging: bool | None = None
            """Enable supplicant logging."""
            disconnect_cached_results_timeout: Annotated[int, Min[60], Max[65535]] | None = None
            """Timeout in seconds for removing a disconnected supplicant."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                profiles: list[ProfilesItem] | None = None,
                logging: bool | None = None,
                disconnect_cached_results_timeout: Annotated[int, Min[60], Max[65535]] | None = None,
            ) -> None:
                """
                Supplicant.

                Args:
                -----
                    _custom_data: _custom_data
                    profiles: Dot1x supplicant profiles.
                    logging: Enable supplicant logging.
                    disconnect_cached_results_timeout: Timeout in seconds for removing a disconnected supplicant.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "system_auth_control",
            "protocol_lldp_bypass",
            "protocol_bpdu_bypass",
            "dynamic_authorization",
            "mac_based_authentication",
            "radius_av_pair_username_format",
            "radius_av_pair",
            "aaa",
            "captive_portal",
            "supplicant",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        system_auth_control: bool | None = None
        protocol_lldp_bypass: bool | None = None
        protocol_bpdu_bypass: bool | None = None
        dynamic_authorization: bool | None = None
        mac_based_authentication: MacBasedAuthentication | None = None
        radius_av_pair_username_format: RadiusAvPairUsernameFormat | None = None
        """RADIUS AV-pair username settings."""
        radius_av_pair: RadiusAvPair | None = None
        aaa: Aaa | None = None
        """Configure AAA parameters."""
        captive_portal: CaptivePortal | None = None
        """
        Web authentication feature authenticates a supplicant through a web page, referred to as a captive
        portal.
        """
        supplicant: Supplicant | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            system_auth_control: bool | None = None,
            protocol_lldp_bypass: bool | None = None,
            protocol_bpdu_bypass: bool | None = None,
            dynamic_authorization: bool | None = None,
            mac_based_authentication: MacBasedAuthentication | None = None,
            radius_av_pair_username_format: RadiusAvPairUsernameFormat | None = None,
            radius_av_pair: RadiusAvPair | None = None,
            aaa: Aaa | None = None,
            captive_portal: CaptivePortal | None = None,
            supplicant: Supplicant | None = None,
        ) -> None:
            """
            Dot1x.

            Args:
            -----
                _custom_data: _custom_data
                system_auth_control: system_auth_control
                protocol_lldp_bypass: protocol_lldp_bypass
                protocol_bpdu_bypass: protocol_bpdu_bypass
                dynamic_authorization: dynamic_authorization
                mac_based_authentication: mac_based_authentication
                radius_av_pair_username_format: RADIUS AV-pair username settings.
                radius_av_pair: radius_av_pair
                aaa: Configure AAA parameters.
                captive_portal:
                   Web authentication feature authenticates a supplicant through a web page, referred to as a captive
                   portal.
                supplicant: supplicant

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class DpsInterfacesItem(AvdBase):
        class FlowTracker(AvdBase):
            _fields = ("_custom_data", "sampled", "hardware")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            sampled: str | None = None
            """Sampled flow tracker name."""
            hardware: str | None = None
            """Hardware flow tracker name,"""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, sampled: str | None = None, hardware: str | None = None) -> None:
                """
                FlowTracker.

                Args:
                -----
                    _custom_data: _custom_data
                    sampled: Sampled flow tracker name.
                    hardware: Hardware flow tracker name,

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TcpMssCeiling(AvdBase):
            _fields = ("_custom_data", "ipv4", "ipv6", "direction")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv4: Annotated[int, Min[64], Max[65495]] | None = None
            """Segment Size for IPv4."""
            ipv6: Annotated[int, Min[64], Max[65475]] | None = None
            """Segment Size for IPv6."""
            direction: Annotated[str, ValidValues["ingress", "egress"]] | None = None
            """Optional direction ('ingress', 'egress')  for tcp mss ceiling."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                ipv4: Annotated[int, Min[64], Max[65495]] | None = None,
                ipv6: Annotated[int, Min[64], Max[65475]] | None = None,
                direction: Annotated[str, ValidValues["ingress", "egress"]] | None = None,
            ) -> None:
                """
                TcpMssCeiling.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: Segment Size for IPv4.
                    ipv6: Segment Size for IPv6.
                    direction: Optional direction ('ingress', 'egress')  for tcp mss ceiling.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "name", "description", "shutdown", "mtu", "ip_address", "flow_tracker", "tcp_mss_ceiling", "eos_cli")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: Annotated[str, ValidValues["Dps1"]] = None
        """"Dps1" is currently the only supported interface."""
        description: str | None = None
        shutdown: bool | None = None
        mtu: Annotated[int, Min[68], Max[65535]] | None = None
        """Maximum Transmission Unit in bytes."""
        ip_address: str | None = None
        """IPv4 address/mask."""
        flow_tracker: FlowTracker | None = None
        tcp_mss_ceiling: TcpMssCeiling | None = None
        eos_cli: str | None = None
        """Multiline String with EOS CLI rendered directly on the Dps interface in the final EOS configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: Annotated[str, ValidValues["Dps1"]] = None,
            description: str | None = None,
            shutdown: bool | None = None,
            mtu: Annotated[int, Min[68], Max[65535]] | None = None,
            ip_address: str | None = None,
            flow_tracker: FlowTracker | None = None,
            tcp_mss_ceiling: TcpMssCeiling | None = None,
            eos_cli: str | None = None,
        ) -> None:
            """
            DpsInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: "Dps1" is currently the only supported interface.
                description: description
                shutdown: shutdown
                mtu: Maximum Transmission Unit in bytes.
                ip_address: IPv4 address/mask.
                flow_tracker: flow_tracker
                tcp_mss_ceiling: tcp_mss_ceiling
                eos_cli: Multiline String with EOS CLI rendered directly on the Dps interface in the final EOS configuration.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class DynamicPrefixListsItem(AvdBase):
        class PrefixList(AvdBase):
            _fields = ("_custom_data", "ipv4", "ipv6")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv4: str | None = None
            """Prefix-list name."""
            ipv6: str | None = None
            """Prefix-list name."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, ipv4: str | None = None, ipv6: str | None = None) -> None:
                """
                PrefixList.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: Prefix-list name.
                    ipv6: Prefix-list name.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "name", "match_map", "prefix_list")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str | None = None
        """Dynamic prefix-list name."""
        match_map: str | None = None
        """Route-map name."""
        prefix_list: PrefixList | None = None

        def __init__(
            self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, match_map: str | None = None, prefix_list: PrefixList | None = None
        ) -> None:
            """
            DynamicPrefixListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Dynamic prefix-list name.
                match_map: Route-map name.
                prefix_list: prefix_list

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class EnablePassword(AvdBase):
        _fields = ("_custom_data", "disabled", "hash_algorithm", "key")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        disabled: bool | None = None
        """Set to `true` to configure `no enable password` which is the EOS default."""
        hash_algorithm: Annotated[str, ValidValues["md5", "sha512"]] | None = None
        key: str | None = None
        """
        Must be the hash of the password using the specified algorithm.
        By default EOS salts the password,
        so the simplest is to generate the hash on an EOS device.
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            disabled: bool | None = None,
            hash_algorithm: Annotated[str, ValidValues["md5", "sha512"]] | None = None,
            key: str | None = None,
        ) -> None:
            """
            EnablePassword.

            Args:
            -----
                _custom_data: _custom_data
                disabled: Set to `true` to configure `no enable password` which is the EOS default.
                hash_algorithm: hash_algorithm
                key:
                   Must be the hash of the password using the specified algorithm.
                   By default EOS salts the password,
                   so the simplest is to generate the hash on an EOS device.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class EosCliConfigGenConfiguration(AvdBase):
        _fields = ("_custom_data", "enable", "hide_passwords")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        enable: bool | None = True
        """Generate device EOS configurations."""
        hide_passwords: bool | None = False
        """
        Replace the input data using the `hide_passwords` filter in the Jinja2 templates by '<removed>' in
        the configuration if true.
        """

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, enable: bool | None = True, hide_passwords: bool | None = False) -> None:
            """
            EosCliConfigGenConfiguration.

            Args:
            -----
                _custom_data: _custom_data
                enable: Generate device EOS configurations.
                hide_passwords:
                   Replace the input data using the `hide_passwords` filter in the Jinja2 templates by '<removed>' in
                   the configuration if true.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class EosCliConfigGenDocumentation(AvdBase):
        _fields = ("_custom_data", "enable", "hide_passwords")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        enable: bool | None = True
        """Generate device Markdown documentation."""
        hide_passwords: bool | None = True
        """
        Replace the input data using the `hide_passwords` filter in the Jinja2 templates by '<removed>' in
        the documentation if true.
        """

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, enable: bool | None = True, hide_passwords: bool | None = True) -> None:
            """
            EosCliConfigGenDocumentation.

            Args:
            -----
                _custom_data: _custom_data
                enable: Generate device Markdown documentation.
                hide_passwords:
                   Replace the input data using the `hide_passwords` filter in the Jinja2 templates by '<removed>' in
                   the documentation if true.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Errdisable(AvdBase):
        class Detect(AvdBase):
            _fields = ("_custom_data", "causes")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            causes: (
                list[
                    Annotated[
                        str,
                        ValidValues["acl", "arp-inspection", "dot1x", "link-change", "tapagg", "xcvr-misconfigured", "xcvr-overheat", "xcvr-power-unsupported"],
                    ]
                ]
                | None
            ) = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                causes: list[
                    Annotated[
                        str,
                        ValidValues["acl", "arp-inspection", "dot1x", "link-change", "tapagg", "xcvr-misconfigured", "xcvr-overheat", "xcvr-power-unsupported"],
                    ]
                ]
                | None = None,
            ) -> None:
                """
                Detect.

                Args:
                -----
                    _custom_data: _custom_data
                    causes: causes

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Recovery(AvdBase):
            _fields = ("_custom_data", "causes", "interval")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            causes: (
                list[
                    Annotated[
                        str,
                        ValidValues[
                            "arp-inspection",
                            "bpduguard",
                            "dot1x",
                            "hitless-reload-down",
                            "lacp-rate-limit",
                            "link-flap",
                            "no-internal-vlan",
                            "portchannelguard",
                            "portsec",
                            "speed-misconfigured",
                            "tap-port-init",
                            "tapagg",
                            "uplink-failure-detection",
                            "xcvr-misconfigured",
                            "xcvr-overheat",
                            "xcvr-power-unsupported",
                            "xcvr-unsupported",
                        ],
                    ]
                ]
                | None
            ) = None
            interval: Annotated[int, Min[30], Max[86400]] | None = 300
            """Interval in seconds."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                causes: list[
                    Annotated[
                        str,
                        ValidValues[
                            "arp-inspection",
                            "bpduguard",
                            "dot1x",
                            "hitless-reload-down",
                            "lacp-rate-limit",
                            "link-flap",
                            "no-internal-vlan",
                            "portchannelguard",
                            "portsec",
                            "speed-misconfigured",
                            "tap-port-init",
                            "tapagg",
                            "uplink-failure-detection",
                            "xcvr-misconfigured",
                            "xcvr-overheat",
                            "xcvr-power-unsupported",
                            "xcvr-unsupported",
                        ],
                    ]
                ]
                | None = None,
                interval: Annotated[int, Min[30], Max[86400]] | None = 300,
            ) -> None:
                """
                Recovery.

                Args:
                -----
                    _custom_data: _custom_data
                    causes: causes
                    interval: Interval in seconds.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "detect", "recovery")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        detect: Detect | None = None
        recovery: Recovery | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, detect: Detect | None = None, recovery: Recovery | None = None) -> None:
            """
            Errdisable.

            Args:
            -----
                _custom_data: _custom_data
                detect: detect
                recovery: recovery

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class EthernetInterfacesItem(AvdBase):
        class Phone(AvdBase):
            _fields = ("_custom_data", "trunk", "vlan")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            trunk: Annotated[str, ValidValues["tagged", "tagged phone", "untagged", "untagged phone"]] | None = None
            vlan: Annotated[int, Min[1], Max[4094]] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                trunk: Annotated[str, ValidValues["tagged", "tagged phone", "untagged", "untagged phone"]] | None = None,
                vlan: Annotated[int, Min[1], Max[4094]] | None = None,
            ) -> None:
                """
                Phone.

                Args:
                -----
                    _custom_data: _custom_data
                    trunk: trunk
                    vlan: vlan

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class L2Protocol(AvdBase):
            _fields = ("_custom_data", "encapsulation_dot1q_vlan", "forwarding_profile")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            encapsulation_dot1q_vlan: int | None = None
            """Vlan tag to configure on sub-interface."""
            forwarding_profile: str | None = None
            """L2 protocol forwarding profile."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, encapsulation_dot1q_vlan: int | None = None, forwarding_profile: str | None = None
            ) -> None:
                """
                L2Protocol.

                Args:
                -----
                    _custom_data: _custom_data
                    encapsulation_dot1q_vlan: Vlan tag to configure on sub-interface.
                    forwarding_profile: L2 protocol forwarding profile.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressLocking(AvdBase):
            _fields = ("_custom_data", "ipv4", "ipv6")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv4: bool | None = None
            """Enable address locking for IPv4."""
            ipv6: bool | None = None
            """Enable address locking for IPv6."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, ipv4: bool | None = None, ipv6: bool | None = None) -> None:
                """
                AddressLocking.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: Enable address locking for IPv4.
                    ipv6: Enable address locking for IPv6.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Flowcontrol(AvdBase):
            _fields = ("_custom_data", "received")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            received: Annotated[str, ValidValues["desired", "on", "off"]] | None = None

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, received: Annotated[str, ValidValues["desired", "on", "off"]] | None = None
            ) -> None:
                """
                Flowcontrol.

                Args:
                -----
                    _custom_data: _custom_data
                    received: received

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class FlowTracker(AvdBase):
            _fields = ("_custom_data", "sampled", "hardware")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            sampled: str | None = None
            """Sampled flow tracker name."""
            hardware: str | None = None
            """Hardware flow tracker name."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, sampled: str | None = None, hardware: str | None = None) -> None:
                """
                FlowTracker.

                Args:
                -----
                    _custom_data: _custom_data
                    sampled: Sampled flow tracker name.
                    hardware: Hardware flow tracker name.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ErrorCorrectionEncoding(AvdBase):
            _fields = ("_custom_data", "enabled", "fire_code", "reed_solomon")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool | None = True
            fire_code: bool | None = None
            reed_solomon: bool | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enabled: bool | None = True,
                fire_code: bool | None = None,
                reed_solomon: bool | None = None,
            ) -> None:
                """
                ErrorCorrectionEncoding.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    fire_code: fire_code
                    reed_solomon: reed_solomon

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class LinkTrackingGroupsItem(AvdBase):
            _fields = ("_custom_data", "name", "direction")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Group name."""
            direction: Annotated[str, ValidValues["upstream", "downstream"]] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                direction: Annotated[str, ValidValues["upstream", "downstream"]] | None = None,
            ) -> None:
                """
                LinkTrackingGroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Group name.
                    direction: direction

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class EvpnEthernetSegment(AvdBase):
            class DesignatedForwarderElection(AvdBase):
                _fields = (
                    "_custom_data",
                    "algorithm",
                    "preference_value",
                    "dont_preempt",
                    "hold_time",
                    "subsequent_hold_time",
                    "candidate_reachability_required",
                )
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                algorithm: Annotated[str, ValidValues["modulus", "preference"]] | None = None
                preference_value: Annotated[int, Max[65535]] | None = None
                """Preference_value is only used when "algorithm" is "preference"."""
                dont_preempt: bool | None = None
                """Dont_preempt is only used when "algorithm" is "preference"."""
                hold_time: int | None = None
                subsequent_hold_time: int | None = None
                candidate_reachability_required: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    algorithm: Annotated[str, ValidValues["modulus", "preference"]] | None = None,
                    preference_value: Annotated[int, Max[65535]] | None = None,
                    dont_preempt: bool | None = None,
                    hold_time: int | None = None,
                    subsequent_hold_time: int | None = None,
                    candidate_reachability_required: bool | None = None,
                ) -> None:
                    """
                    DesignatedForwarderElection.

                    Args:
                    -----
                        _custom_data: _custom_data
                        algorithm: algorithm
                        preference_value: Preference_value is only used when "algorithm" is "preference".
                        dont_preempt: Dont_preempt is only used when "algorithm" is "preference".
                        hold_time: hold_time
                        subsequent_hold_time: subsequent_hold_time
                        candidate_reachability_required: candidate_reachability_required

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Mpls(AvdBase):
                _fields = ("_custom_data", "shared_index", "tunnel_flood_filter_time")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                shared_index: Annotated[int, Min[1], Max[1024]] | None = None
                tunnel_flood_filter_time: int | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    shared_index: Annotated[int, Min[1], Max[1024]] | None = None,
                    tunnel_flood_filter_time: int | None = None,
                ) -> None:
                    """
                    Mpls.

                    Args:
                    -----
                        _custom_data: _custom_data
                        shared_index: shared_index
                        tunnel_flood_filter_time: tunnel_flood_filter_time

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "identifier", "redundancy", "designated_forwarder_election", "mpls", "route_target")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            identifier: str | None = None
            """EVPN Ethernet Segment Identifier (Type 1 format)."""
            redundancy: Annotated[str, ValidValues["all-active", "single-active"]] | None = None
            designated_forwarder_election: DesignatedForwarderElection | None = None
            mpls: Mpls | None = None
            route_target: str | None = None
            """EVPN Route Target for ESI with format xx:xx:xx:xx:xx:xx."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                identifier: str | None = None,
                redundancy: Annotated[str, ValidValues["all-active", "single-active"]] | None = None,
                designated_forwarder_election: DesignatedForwarderElection | None = None,
                mpls: Mpls | None = None,
                route_target: str | None = None,
            ) -> None:
                """
                EvpnEthernetSegment.

                Args:
                -----
                    _custom_data: _custom_data
                    identifier: EVPN Ethernet Segment Identifier (Type 1 format).
                    redundancy: redundancy
                    designated_forwarder_election: designated_forwarder_election
                    mpls: mpls
                    route_target: EVPN Route Target for ESI with format xx:xx:xx:xx:xx:xx.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class EncapsulationDot1q(AvdBase):
            _fields = ("_custom_data", "vlan", "inner_vlan")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            vlan: Annotated[int, Min[1], Max[4094]] = None
            """VLAD ID."""
            inner_vlan: Annotated[int, Min[1], Max[4094]] | None = None
            """Inner VLAN ID. This setting can only be applied to sub-interfaces on EOS."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                vlan: Annotated[int, Min[1], Max[4094]] = None,
                inner_vlan: Annotated[int, Min[1], Max[4094]] | None = None,
            ) -> None:
                """
                EncapsulationDot1q.

                Args:
                -----
                    _custom_data: _custom_data
                    vlan: VLAD ID.
                    inner_vlan: Inner VLAN ID. This setting can only be applied to sub-interfaces on EOS.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class EncapsulationVlan(AvdBase):
            class Client(AvdBase):
                class Dot1q(AvdBase):
                    _fields = ("_custom_data", "vlan", "outer", "inner")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    vlan: Annotated[int, Min[1], Max[4094]] | None = None
                    """Client VLAN ID."""
                    outer: Annotated[int, Min[1], Max[4094]] | None = None
                    """Client Outer VLAN ID."""
                    inner: int | None = None
                    """Client Inner VLAN ID."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                        outer: Annotated[int, Min[1], Max[4094]] | None = None,
                        inner: int | None = None,
                    ) -> None:
                        """
                        Dot1q.

                        Args:
                        -----
                            _custom_data: _custom_data
                            vlan: Client VLAN ID.
                            outer: Client Outer VLAN ID.
                            inner: Client Inner VLAN ID.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "dot1q", "unmatched", "encapsulation", "vlan", "outer_vlan", "inner_vlan", "inner_encapsulation")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                dot1q: Dot1q | None = None
                unmatched: bool | None = None
                encapsulation: Annotated[str, ValidValues["dot1q", "dot1ad", "unmatched", "untagged"]] | None = None
                vlan: Annotated[int, Min[1], Max[4094]] | None = None
                """Client VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                outer_vlan: Annotated[int, Min[1], Max[4094]] | None = None
                """Client Outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                inner_vlan: Annotated[int, Min[1], Max[4094]] | None = None
                """Client Inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                inner_encapsulation: Annotated[str, ValidValues["dot1q", "dot1ad"]] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    dot1q: Dot1q | None = None,
                    unmatched: bool | None = None,
                    encapsulation: Annotated[str, ValidValues["dot1q", "dot1ad", "unmatched", "untagged"]] | None = None,
                    vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                    outer_vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                    inner_vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                    inner_encapsulation: Annotated[str, ValidValues["dot1q", "dot1ad"]] | None = None,
                ) -> None:
                    """
                    Client.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dot1q: dot1q
                        unmatched: unmatched
                        encapsulation: encapsulation
                        vlan: Client VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                        outer_vlan: Client Outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                        inner_vlan: Client Inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                        inner_encapsulation: inner_encapsulation

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Network(AvdBase):
                class Dot1q(AvdBase):
                    _fields = ("_custom_data", "vlan", "outer", "inner")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    vlan: Annotated[int, Min[1], Max[4094]] | None = None
                    """Network VLAN ID."""
                    outer: Annotated[int, Min[1], Max[4094]] | None = None
                    """Network outer VLAN ID."""
                    inner: Annotated[int, Min[1], Max[4094]] | None = None
                    """Network inner VLAN ID."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                        outer: Annotated[int, Min[1], Max[4094]] | None = None,
                        inner: Annotated[int, Min[1], Max[4094]] | None = None,
                    ) -> None:
                        """
                        Dot1q.

                        Args:
                        -----
                            _custom_data: _custom_data
                            vlan: Network VLAN ID.
                            outer: Network outer VLAN ID.
                            inner: Network inner VLAN ID.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "dot1q", "client", "encapsulation", "vlan", "outer_vlan", "inner_vlan", "inner_encapsulation")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                dot1q: Dot1q | None = None
                client: bool | None = None
                encapsulation: Annotated[str, ValidValues["dot1q", "dot1ad", "client", "client inner", "untagged"]] | None = None
                """
                `untagged` (no encapsulation) is applicable for `untagged` client only.
                `client` and `client inner`
                (retain client encapsulation) is not applicable for `untagged` client.
                """
                vlan: Annotated[int, Min[1], Max[4094]] | None = None
                """Network VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                outer_vlan: Annotated[int, Min[1], Max[4094]] | None = None
                """Network outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                inner_vlan: Annotated[int, Min[1], Max[4094]] | None = None
                """Network inner VLAN ID.  Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                inner_encapsulation: Annotated[str, ValidValues["dot1q", "dot1ad"]] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    dot1q: Dot1q | None = None,
                    client: bool | None = None,
                    encapsulation: Annotated[str, ValidValues["dot1q", "dot1ad", "client", "client inner", "untagged"]] | None = None,
                    vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                    outer_vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                    inner_vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                    inner_encapsulation: Annotated[str, ValidValues["dot1q", "dot1ad"]] | None = None,
                ) -> None:
                    """
                    Network.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dot1q: dot1q
                        client: client
                        encapsulation:
                           `untagged` (no encapsulation) is applicable for `untagged` client only.
                           `client` and `client inner`
                           (retain client encapsulation) is not applicable for `untagged` client.
                        vlan: Network VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                        outer_vlan: Network outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                        inner_vlan: Network inner VLAN ID.  Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                        inner_encapsulation: inner_encapsulation

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "client", "network")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            client: Client | None = None
            network: Network | None = None
            """Network encapsulations are all optional and skipped if using client unmatched."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, client: Client | None = None, network: Network | None = None) -> None:
                """
                EncapsulationVlan.

                Args:
                -----
                    _custom_data: _custom_data
                    client: client
                    network: Network encapsulations are all optional and skipped if using client unmatched.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IpHelpersItem(AvdBase):
            _fields = ("_custom_data", "ip_helper", "source_interface", "vrf")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ip_helper: str = None
            source_interface: str | None = None
            """Source interface name."""
            vrf: str | None = None
            """VRF name."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, ip_helper: str = None, source_interface: str | None = None, vrf: str | None = None
            ) -> None:
                """
                IpHelpersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    ip_helper: ip_helper
                    source_interface: Source interface name.
                    vrf: VRF name.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IpNat(AvdBase):
            class Destination(AvdBase):
                class DynamicItem(AvdBase):
                    _fields = ("_custom_data", "access_list", "comment", "pool_name", "priority")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    access_list: str = None
                    comment: str | None = None
                    pool_name: str = None
                    priority: Annotated[int, Max[4294967295]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        access_list: str = None,
                        comment: str | None = None,
                        pool_name: str = None,
                        priority: Annotated[int, Max[4294967295]] | None = None,
                    ) -> None:
                        """
                        DynamicItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: access_list
                            comment: comment
                            pool_name: pool_name
                            priority: priority

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class StaticItem(AvdBase):
                    _fields = (
                        "_custom_data",
                        "access_list",
                        "comment",
                        "direction",
                        "group",
                        "original_ip",
                        "original_port",
                        "priority",
                        "protocol",
                        "translated_ip",
                        "translated_port",
                    )
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    access_list: str | None = None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None = None
                    direction: Annotated[str, ValidValues["egress", "ingress"]] | None = None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: Annotated[int, Min[1], Max[65535]] | None = None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None = None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: Annotated[int, Min[1], Max[65535]] | None = None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: Annotated[int, Max[4294967295]] | None = None
                    protocol: Annotated[str, ValidValues["udp", "tcp"]] | None = None
                    translated_ip: str = None
                    """IPv4 address."""
                    translated_port: Annotated[int, Min[1], Max[65535]] | None = None
                    """requires 'original_port'."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        access_list: str | None = None,
                        comment: str | None = None,
                        direction: Annotated[str, ValidValues["egress", "ingress"]] | None = None,
                        group: Annotated[int, Min[1], Max[65535]] | None = None,
                        original_ip: str | None = None,
                        original_port: Annotated[int, Min[1], Max[65535]] | None = None,
                        priority: Annotated[int, Max[4294967295]] | None = None,
                        protocol: Annotated[str, ValidValues["udp", "tcp"]] | None = None,
                        translated_ip: str = None,
                        translated_port: Annotated[int, Min[1], Max[65535]] | None = None,
                    ) -> None:
                        """
                        StaticItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: 'access_list' and 'group' are mutual exclusive.
                            comment: comment
                            direction:
                               Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                               platform.
                               EOS might remove this keyword in the configuration. So, check the configuration on
                               targeted HW/SW.
                            group: 'access_list' and 'group' are mutual exclusive.
                            original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                            original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                            priority: priority
                            protocol: protocol
                            translated_ip: IPv4 address.
                            translated_port: requires 'original_port'.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "dynamic", "static")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                dynamic: list[DynamicItem] | None = None
                static: list[StaticItem] | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, dynamic: list[DynamicItem] | None = None, static: list[StaticItem] | None = None
                ) -> None:
                    """
                    Destination.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dynamic: dynamic
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Source(AvdBase):
                class DynamicItem(AvdBase):
                    _fields = ("_custom_data", "access_list", "comment", "nat_type", "pool_name", "priority")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    access_list: str = None
                    comment: str | None = None
                    nat_type: Annotated[str, ValidValues["overload", "pool", "pool-address-only", "pool-full-cone"]] = None
                    pool_name: str | None = None
                    """
                    required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                    ignored if 'nat_type' is
                    overload.
                    """
                    priority: Annotated[int, Max[4294967295]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        access_list: str = None,
                        comment: str | None = None,
                        nat_type: Annotated[str, ValidValues["overload", "pool", "pool-address-only", "pool-full-cone"]] = None,
                        pool_name: str | None = None,
                        priority: Annotated[int, Max[4294967295]] | None = None,
                    ) -> None:
                        """
                        DynamicItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: access_list
                            comment: comment
                            nat_type: nat_type
                            pool_name:
                               required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                               ignored if 'nat_type' is
                               overload.
                            priority: priority

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class StaticItem(AvdBase):
                    _fields = (
                        "_custom_data",
                        "access_list",
                        "comment",
                        "direction",
                        "group",
                        "original_ip",
                        "original_port",
                        "priority",
                        "protocol",
                        "translated_ip",
                        "translated_port",
                    )
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    access_list: str | None = None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None = None
                    direction: Annotated[str, ValidValues["egress", "ingress"]] | None = None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: Annotated[int, Min[1], Max[65535]] | None = None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None = None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: Annotated[int, Min[1], Max[65535]] | None = None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: Annotated[int, Max[4294967295]] | None = None
                    protocol: Annotated[str, ValidValues["udp", "tcp"]] | None = None
                    translated_ip: str = None
                    """IPv4 address."""
                    translated_port: Annotated[int, Min[1], Max[65535]] | None = None
                    """requires 'original_port'."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        access_list: str | None = None,
                        comment: str | None = None,
                        direction: Annotated[str, ValidValues["egress", "ingress"]] | None = None,
                        group: Annotated[int, Min[1], Max[65535]] | None = None,
                        original_ip: str | None = None,
                        original_port: Annotated[int, Min[1], Max[65535]] | None = None,
                        priority: Annotated[int, Max[4294967295]] | None = None,
                        protocol: Annotated[str, ValidValues["udp", "tcp"]] | None = None,
                        translated_ip: str = None,
                        translated_port: Annotated[int, Min[1], Max[65535]] | None = None,
                    ) -> None:
                        """
                        StaticItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: 'access_list' and 'group' are mutual exclusive.
                            comment: comment
                            direction:
                               Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                               platform.
                               EOS might remove this keyword in the configuration. So, check the configuration on
                               targeted HW/SW.
                            group: 'access_list' and 'group' are mutual exclusive.
                            original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                            original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                            priority: priority
                            protocol: protocol
                            translated_ip: IPv4 address.
                            translated_port: requires 'original_port'.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "dynamic", "static")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                dynamic: list[DynamicItem] | None = None
                static: list[StaticItem] | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, dynamic: list[DynamicItem] | None = None, static: list[StaticItem] | None = None
                ) -> None:
                    """
                    Source.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dynamic: dynamic
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "service_profile", "destination", "source")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            service_profile: str | None = None
            """NAT interface profile."""
            destination: Destination | None = None
            source: Source | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                service_profile: str | None = None,
                destination: Destination | None = None,
                source: Source | None = None,
            ) -> None:
                """
                IpNat.

                Args:
                -----
                    _custom_data: _custom_data
                    service_profile: NAT interface profile.
                    destination: destination
                    source: source

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6NdPrefixesItem(AvdBase):
            _fields = ("_custom_data", "ipv6_prefix", "valid_lifetime", "preferred_lifetime", "no_autoconfig_flag")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv6_prefix: str = None
            valid_lifetime: str | None = None
            """Infinite or lifetime in seconds."""
            preferred_lifetime: str | None = None
            """Infinite or lifetime in seconds."""
            no_autoconfig_flag: bool | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                ipv6_prefix: str = None,
                valid_lifetime: str | None = None,
                preferred_lifetime: str | None = None,
                no_autoconfig_flag: bool | None = None,
            ) -> None:
                """
                Ipv6NdPrefixesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv6_prefix: ipv6_prefix
                    valid_lifetime: Infinite or lifetime in seconds.
                    preferred_lifetime: Infinite or lifetime in seconds.
                    no_autoconfig_flag: no_autoconfig_flag

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6DhcpRelayDestinationsItem(AvdBase):
            _fields = ("_custom_data", "address", "vrf", "local_interface", "source_address", "link_address")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            address: str = None
            """DHCP server's IPv6 address."""
            vrf: str | None = None
            local_interface: str | None = None
            """Local interface to communicate with DHCP server - mutually exclusive to source_address."""
            source_address: str | None = None
            """Source IPv6 address to communicate with DHCP server - mutually exclusive to local_interface."""
            link_address: str | None = None
            """Override the default link address specified in the relayed DHCP packet."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                address: str = None,
                vrf: str | None = None,
                local_interface: str | None = None,
                source_address: str | None = None,
                link_address: str | None = None,
            ) -> None:
                """
                Ipv6DhcpRelayDestinationsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    address: DHCP server's IPv6 address.
                    vrf: vrf
                    local_interface: Local interface to communicate with DHCP server - mutually exclusive to source_address.
                    source_address: Source IPv6 address to communicate with DHCP server - mutually exclusive to local_interface.
                    link_address: Override the default link address specified in the relayed DHCP packet.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Multicast(AvdBase):
            class Ipv4(AvdBase):
                class BoundariesItem(AvdBase):
                    _fields = ("_custom_data", "boundary", "out")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    boundary: str | None = None
                    """ACL name or multicast IP subnet."""
                    out: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, boundary: str | None = None, out: bool | None = None) -> None:
                        """
                        BoundariesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            boundary: ACL name or multicast IP subnet.
                            out: out

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "boundaries", "static")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                boundaries: list[BoundariesItem] | None = None
                static: bool | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, boundaries: list[BoundariesItem] | None = None, static: bool | None = None
                ) -> None:
                    """
                    Ipv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        boundaries: boundaries
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv6(AvdBase):
                class BoundariesItem(AvdBase):
                    _fields = ("_custom_data", "boundary")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    boundary: str | None = None
                    """ACL name or multicast IP subnet."""

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, boundary: str | None = None) -> None:
                        """
                        BoundariesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            boundary: ACL name or multicast IP subnet.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "boundaries", "static")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                boundaries: list[BoundariesItem] | None = None
                static: bool | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, boundaries: list[BoundariesItem] | None = None, static: bool | None = None
                ) -> None:
                    """
                    Ipv6.

                    Args:
                    -----
                        _custom_data: _custom_data
                        boundaries: boundaries
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "ipv4", "ipv6")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv4: Ipv4 | None = None
            ipv6: Ipv6 | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, ipv4: Ipv4 | None = None, ipv6: Ipv6 | None = None) -> None:
                """
                Multicast.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: ipv4
                    ipv6: ipv6

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class OspfMessageDigestKeysItem(AvdBase):
            _fields = ("_custom_data", "id", "hash_algorithm", "key")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            id: int = None
            hash_algorithm: Annotated[str, ValidValues["md5", "sha1", "sha256", "sha384", "sha512"]] | None = None
            key: str | None = None
            """Encrypted password - only type 7 supported."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                id: int = None,
                hash_algorithm: Annotated[str, ValidValues["md5", "sha1", "sha256", "sha384", "sha512"]] | None = None,
                key: str | None = None,
            ) -> None:
                """
                OspfMessageDigestKeysItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: id
                    hash_algorithm: hash_algorithm
                    key: Encrypted password - only type 7 supported.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Pim(AvdBase):
            class Ipv4(AvdBase):
                class Hello(AvdBase):
                    _fields = ("_custom_data", "count", "interval")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    count: str | None = None
                    """Number of missed hellos after which the neighbor expires. Range <1.5-65535>."""
                    interval: Annotated[int, Min[1], Max[65535]] | None = None
                    """PIM hello interval in seconds."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        count: str | None = None,
                        interval: Annotated[int, Min[1], Max[65535]] | None = None,
                    ) -> None:
                        """
                        Hello.

                        Args:
                        -----
                            _custom_data: _custom_data
                            count: Number of missed hellos after which the neighbor expires. Range <1.5-65535>.
                            interval: PIM hello interval in seconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "border_router", "dr_priority", "sparse_mode", "bfd", "bidirectional", "hello")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                border_router: bool | None = None
                """Configure PIM border router. EOS default is false."""
                dr_priority: Annotated[int, Max[429467295]] | None = None
                sparse_mode: bool | None = None
                bfd: bool | None = None
                """Set the default for whether Bidirectional Forwarding Detection is enabled for PIM."""
                bidirectional: bool | None = None
                hello: Hello | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    border_router: bool | None = None,
                    dr_priority: Annotated[int, Max[429467295]] | None = None,
                    sparse_mode: bool | None = None,
                    bfd: bool | None = None,
                    bidirectional: bool | None = None,
                    hello: Hello | None = None,
                ) -> None:
                    """
                    Ipv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        border_router: Configure PIM border router. EOS default is false.
                        dr_priority: dr_priority
                        sparse_mode: sparse_mode
                        bfd: Set the default for whether Bidirectional Forwarding Detection is enabled for PIM.
                        bidirectional: bidirectional
                        hello: hello

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "ipv4")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv4: Ipv4 | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, ipv4: Ipv4 | None = None) -> None:
                """
                Pim.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: ipv4

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class MacSecurity(AvdBase):
            _fields = ("_custom_data", "profile")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            profile: str | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, profile: str | None = None) -> None:
                """
                MacSecurity.

                Args:
                -----
                    _custom_data: _custom_data
                    profile: profile

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TcpMssCeiling(AvdBase):
            _fields = ("_custom_data", "ipv4_segment_size", "ipv6_segment_size", "direction")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv4_segment_size: Annotated[int, Min[64], Max[65475]] | None = None
            ipv6_segment_size: Annotated[int, Min[64], Max[65475]] | None = None
            direction: Annotated[str, ValidValues["egress", "ingress"]] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                ipv4_segment_size: Annotated[int, Min[64], Max[65475]] | None = None,
                ipv6_segment_size: Annotated[int, Min[64], Max[65475]] | None = None,
                direction: Annotated[str, ValidValues["egress", "ingress"]] | None = None,
            ) -> None:
                """
                TcpMssCeiling.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4_segment_size: ipv4_segment_size
                    ipv6_segment_size: ipv6_segment_size
                    direction: direction

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ChannelGroup(AvdBase):
            _fields = ("_custom_data", "id", "mode")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            id: int | None = None
            mode: Annotated[str, ValidValues["on", "active", "passive"]] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                id: int | None = None,
                mode: Annotated[str, ValidValues["on", "active", "passive"]] | None = None,
            ) -> None:
                """
                ChannelGroup.

                Args:
                -----
                    _custom_data: _custom_data
                    id: id
                    mode: mode

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Poe(AvdBase):
            class Reboot(AvdBase):
                _fields = ("_custom_data", "action")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                action: Annotated[str, ValidValues["maintain", "power-off"]] | None = None
                """PoE action for interface."""

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, action: Annotated[str, ValidValues["maintain", "power-off"]] | None = None
                ) -> None:
                    """
                    Reboot.

                    Args:
                    -----
                        _custom_data: _custom_data
                        action: PoE action for interface.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class LinkDown(AvdBase):
                _fields = ("_custom_data", "action", "power_off_delay")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                action: Annotated[str, ValidValues["maintain", "power-off"]] | None = None
                """PoE action for interface."""
                power_off_delay: Annotated[int, Min[1], Max[86400]] | None = None
                """
                Number of seconds to delay shutting the power off after a link down event occurs. Default value is 5
                seconds in EOS.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    action: Annotated[str, ValidValues["maintain", "power-off"]] | None = None,
                    power_off_delay: Annotated[int, Min[1], Max[86400]] | None = None,
                ) -> None:
                    """
                    LinkDown.

                    Args:
                    -----
                        _custom_data: _custom_data
                        action: PoE action for interface.
                        power_off_delay:
                           Number of seconds to delay shutting the power off after a link down event occurs. Default value is 5
                           seconds in EOS.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Shutdown(AvdBase):
                _fields = ("_custom_data", "action")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                action: Annotated[str, ValidValues["maintain", "power-off"]] | None = None
                """PoE action for interface."""

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, action: Annotated[str, ValidValues["maintain", "power-off"]] | None = None
                ) -> None:
                    """
                    Shutdown.

                    Args:
                    -----
                        _custom_data: _custom_data
                        action: PoE action for interface.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Limit(AvdBase):
                _fields = ("_custom_data", "field_class", "watts", "fixed")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                field_class: Annotated[int, Max[8]] | None = None
                watts: str | None = None
                fixed: bool | None = None
                """Set to ignore hardware classification."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    field_class: Annotated[int, Max[8]] | None = None,
                    watts: str | None = None,
                    fixed: bool | None = None,
                ) -> None:
                    """
                    Limit.

                    Args:
                    -----
                        _custom_data: _custom_data
                        field_class: field_class
                        watts: watts
                        fixed: Set to ignore hardware classification.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "disabled", "priority", "reboot", "link_down", "shutdown", "limit", "negotiation_lldp", "legacy_detect")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            disabled: bool | None = False
            """Disable PoE on a POE capable port. PoE is enabled on all ports that support it by default in EOS."""
            priority: Annotated[str, ValidValues["critical", "high", "medium", "low"]] | None = None
            """Prioritize a port's power in the event that one of the switch's power supplies loses power."""
            reboot: Reboot | None = None
            """Set the PoE power behavior for a PoE port when the system is rebooted."""
            link_down: LinkDown | None = None
            """Set the PoE power behavior for a PoE port when the port goes down."""
            shutdown: Shutdown | None = None
            """Set the PoE power behavior for a PoE port when the port is admin down."""
            limit: Limit | None = None
            """
            Override the hardware-negotiated power limit using either wattage or a power class. Note that if
            using a power class, AVD will automatically convert the class value to the wattage value
            corresponding to that power class.
            """
            negotiation_lldp: bool | None = None
            """
            Disable to prevent port from negotiating power with powered devices over LLDP. Enabled by default in
            EOS.
            """
            legacy_detect: bool | None = None
            """
            Allow a subset of legacy devices to work with the PoE switch. Disabled by default in EOS because it
            can cause false positive detections.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                disabled: bool | None = False,
                priority: Annotated[str, ValidValues["critical", "high", "medium", "low"]] | None = None,
                reboot: Reboot | None = None,
                link_down: LinkDown | None = None,
                shutdown: Shutdown | None = None,
                limit: Limit | None = None,
                negotiation_lldp: bool | None = None,
                legacy_detect: bool | None = None,
            ) -> None:
                """
                Poe.

                Args:
                -----
                    _custom_data: _custom_data
                    disabled: Disable PoE on a POE capable port. PoE is enabled on all ports that support it by default in EOS.
                    priority: Prioritize a port's power in the event that one of the switch's power supplies loses power.
                    reboot: Set the PoE power behavior for a PoE port when the system is rebooted.
                    link_down: Set the PoE power behavior for a PoE port when the port goes down.
                    shutdown: Set the PoE power behavior for a PoE port when the port is admin down.
                    limit:
                       Override the hardware-negotiated power limit using either wattage or a power class. Note that if
                       using a power class, AVD will automatically convert the class value to the wattage value
                       corresponding to that power class.
                    negotiation_lldp:
                       Disable to prevent port from negotiating power with powered devices over LLDP. Enabled by default in
                       EOS.
                    legacy_detect:
                       Allow a subset of legacy devices to work with the PoE switch. Disabled by default in EOS because it
                       can cause false positive detections.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ptp(AvdBase):
            class Announce(AvdBase):
                _fields = ("_custom_data", "interval", "timeout")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                interval: int | None = None
                timeout: int | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, interval: int | None = None, timeout: int | None = None) -> None:
                    """
                    Announce.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interval: interval
                        timeout: timeout

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Profile(AvdBase):
                class G82751(AvdBase):
                    _fields = ("_custom_data", "destination_mac_address")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    destination_mac_address: Annotated[str, ValidValues["forwardable", "non-forwardable"]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        destination_mac_address: Annotated[str, ValidValues["forwardable", "non-forwardable"]] | None = None,
                    ) -> None:
                        """
                        G82751.

                        Args:
                        -----
                            _custom_data: _custom_data
                            destination_mac_address: destination_mac_address

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "g8275_1")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                g8275_1: G82751 | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, g8275_1: G82751 | None = None) -> None:
                    """
                    Profile.

                    Args:
                    -----
                        _custom_data: _custom_data
                        g8275_1: g8275_1

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class SyncMessage(AvdBase):
                _fields = ("_custom_data", "interval")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                interval: int | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, interval: int | None = None) -> None:
                    """
                    SyncMessage.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interval: interval

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "enable", "announce", "delay_req", "delay_mechanism", "profile", "sync_message", "role", "vlan", "transport")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enable: bool | None = None
            announce: Announce | None = None
            delay_req: int | None = None
            delay_mechanism: Annotated[str, ValidValues["e2e", "p2p"]] | None = None
            profile: Profile | None = None
            sync_message: SyncMessage | None = None
            role: Annotated[str, ValidValues["master", "dynamic"]] | None = None
            vlan: str | None = None
            """VLAN can be 'all' or list of vlans as string."""
            transport: Annotated[str, ValidValues["ipv4", "ipv6", "layer2"]] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enable: bool | None = None,
                announce: Announce | None = None,
                delay_req: int | None = None,
                delay_mechanism: Annotated[str, ValidValues["e2e", "p2p"]] | None = None,
                profile: Profile | None = None,
                sync_message: SyncMessage | None = None,
                role: Annotated[str, ValidValues["master", "dynamic"]] | None = None,
                vlan: str | None = None,
                transport: Annotated[str, ValidValues["ipv4", "ipv6", "layer2"]] | None = None,
            ) -> None:
                """
                Ptp.

                Args:
                -----
                    _custom_data: _custom_data
                    enable: enable
                    announce: announce
                    delay_req: delay_req
                    delay_mechanism: delay_mechanism
                    profile: profile
                    sync_message: sync_message
                    role: role
                    vlan: VLAN can be 'all' or list of vlans as string.
                    transport: transport

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class StormControl(AvdBase):
            class All(AvdBase):
                _fields = ("_custom_data", "level", "unit")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                level: str | None = None
                """Configure maximum storm-control level."""
                unit: Annotated[str, ValidValues["percent", "pps"]] | None = "percent"
                """Optional field and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    level: str | None = None,
                    unit: Annotated[str, ValidValues["percent", "pps"]] | None = "percent",
                ) -> None:
                    """
                    All.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional field and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Broadcast(AvdBase):
                _fields = ("_custom_data", "level", "unit")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                level: str | None = None
                """Configure maximum storm-control level."""
                unit: Annotated[str, ValidValues["percent", "pps"]] | None = "percent"
                """Optional field and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    level: str | None = None,
                    unit: Annotated[str, ValidValues["percent", "pps"]] | None = "percent",
                ) -> None:
                    """
                    Broadcast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional field and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Multicast(AvdBase):
                _fields = ("_custom_data", "level", "unit")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                level: str | None = None
                """Configure maximum storm-control level."""
                unit: Annotated[str, ValidValues["percent", "pps"]] | None = "percent"
                """Optional field and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    level: str | None = None,
                    unit: Annotated[str, ValidValues["percent", "pps"]] | None = "percent",
                ) -> None:
                    """
                    Multicast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional field and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class UnknownUnicast(AvdBase):
                _fields = ("_custom_data", "level", "unit")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                level: str | None = None
                """Configure maximum storm-control level."""
                unit: Annotated[str, ValidValues["percent", "pps"]] | None = "percent"
                """Optional field and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    level: str | None = None,
                    unit: Annotated[str, ValidValues["percent", "pps"]] | None = "percent",
                ) -> None:
                    """
                    UnknownUnicast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional field and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "all", "broadcast", "multicast", "unknown_unicast")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            all: All | None = None
            broadcast: Broadcast | None = None
            multicast: Multicast | None = None
            unknown_unicast: UnknownUnicast | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                all: All | None = None,
                broadcast: Broadcast | None = None,
                multicast: Multicast | None = None,
                unknown_unicast: UnknownUnicast | None = None,
            ) -> None:
                """
                StormControl.

                Args:
                -----
                    _custom_data: _custom_data
                    all: all
                    broadcast: broadcast
                    multicast: multicast
                    unknown_unicast: unknown_unicast

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Logging(AvdBase):
            class Event(AvdBase):
                _fields = ("_custom_data", "link_status", "congestion_drops", "spanning_tree", "storm_control_discards")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                link_status: bool | None = None
                congestion_drops: bool | None = None
                spanning_tree: bool | None = None
                storm_control_discards: bool | None = None
                """Discards due to storm-control."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    link_status: bool | None = None,
                    congestion_drops: bool | None = None,
                    spanning_tree: bool | None = None,
                    storm_control_discards: bool | None = None,
                ) -> None:
                    """
                    Event.

                    Args:
                    -----
                        _custom_data: _custom_data
                        link_status: link_status
                        congestion_drops: congestion_drops
                        spanning_tree: spanning_tree
                        storm_control_discards: Discards due to storm-control.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "event")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            event: Event | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, event: Event | None = None) -> None:
                """
                Logging.

                Args:
                -----
                    _custom_data: _custom_data
                    event: event

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Lldp(AvdBase):
            _fields = ("_custom_data", "transmit", "receive", "ztp_vlan")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            transmit: bool | None = None
            receive: bool | None = None
            ztp_vlan: int | None = None
            """ZTP vlan number."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, transmit: bool | None = None, receive: bool | None = None, ztp_vlan: int | None = None
            ) -> None:
                """
                Lldp.

                Args:
                -----
                    _custom_data: _custom_data
                    transmit: transmit
                    receive: receive
                    ztp_vlan: ZTP vlan number.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VlanTranslationsItem(AvdBase):
            _fields = ("_custom_data", "field_from", "to", "direction")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            field_from: str | None = None
            """List of vlans as string (only one vlan if direction is "both")."""
            to: int | None = None
            """VLAN ID."""
            direction: Annotated[str, ValidValues["in", "out", "both"]] | None = "both"

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                field_from: str | None = None,
                to: int | None = None,
                direction: Annotated[str, ValidValues["in", "out", "both"]] | None = "both",
            ) -> None:
                """
                VlanTranslationsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    field_from: List of vlans as string (only one vlan if direction is "both").
                    to: VLAN ID.
                    direction: direction

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Dot1x(AvdBase):
            class Pae(AvdBase):
                _fields = ("_custom_data", "mode")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                mode: Annotated[str, ValidValues["authenticator"]] | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, mode: Annotated[str, ValidValues["authenticator"]] | None = None) -> None:
                    """
                    Pae.

                    Args:
                    -----
                        _custom_data: _custom_data
                        mode: mode

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AuthenticationFailure(AvdBase):
                _fields = ("_custom_data", "action", "allow_vlan")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                action: Annotated[str, ValidValues["allow", "drop"]] | None = None
                allow_vlan: Annotated[int, Min[1], Max[4094]] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    action: Annotated[str, ValidValues["allow", "drop"]] | None = None,
                    allow_vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                ) -> None:
                    """
                    AuthenticationFailure.

                    Args:
                    -----
                        _custom_data: _custom_data
                        action: action
                        allow_vlan: allow_vlan

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class HostMode(AvdBase):
                _fields = ("_custom_data", "mode", "multi_host_authenticated")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                mode: Annotated[str, ValidValues["multi-host", "single-host"]] | None = None
                multi_host_authenticated: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    mode: Annotated[str, ValidValues["multi-host", "single-host"]] | None = None,
                    multi_host_authenticated: bool | None = None,
                ) -> None:
                    """
                    HostMode.

                    Args:
                    -----
                        _custom_data: _custom_data
                        mode: mode
                        multi_host_authenticated: multi_host_authenticated

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class MacBasedAuthentication(AvdBase):
                _fields = ("_custom_data", "enabled", "always", "host_mode_common")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                always: bool | None = None
                host_mode_common: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    enabled: bool | None = None,
                    always: bool | None = None,
                    host_mode_common: bool | None = None,
                ) -> None:
                    """
                    MacBasedAuthentication.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        always: always
                        host_mode_common: host_mode_common

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Timeout(AvdBase):
                _fields = ("_custom_data", "idle_host", "quiet_period", "reauth_period", "reauth_timeout_ignore", "tx_period")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                idle_host: Annotated[int, Min[10], Max[65535]] | None = None
                quiet_period: Annotated[int, Min[1], Max[65535]] | None = None
                reauth_period: str | None = None
                """Value can be 60-4294967295 or 'server'."""
                reauth_timeout_ignore: bool | None = None
                tx_period: Annotated[int, Min[1], Max[65535]] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    idle_host: Annotated[int, Min[10], Max[65535]] | None = None,
                    quiet_period: Annotated[int, Min[1], Max[65535]] | None = None,
                    reauth_period: str | None = None,
                    reauth_timeout_ignore: bool | None = None,
                    tx_period: Annotated[int, Min[1], Max[65535]] | None = None,
                ) -> None:
                    """
                    Timeout.

                    Args:
                    -----
                        _custom_data: _custom_data
                        idle_host: idle_host
                        quiet_period: quiet_period
                        reauth_period: Value can be 60-4294967295 or 'server'.
                        reauth_timeout_ignore: reauth_timeout_ignore
                        tx_period: tx_period

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Unauthorized(AvdBase):
                _fields = ("_custom_data", "access_vlan_membership_egress", "native_vlan_membership_egress")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                access_vlan_membership_egress: bool | None = None
                native_vlan_membership_egress: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    access_vlan_membership_egress: bool | None = None,
                    native_vlan_membership_egress: bool | None = None,
                ) -> None:
                    """
                    Unauthorized.

                    Args:
                    -----
                        _custom_data: _custom_data
                        access_vlan_membership_egress: access_vlan_membership_egress
                        native_vlan_membership_egress: native_vlan_membership_egress

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Eapol(AvdBase):
                class AuthenticationFailureFallbackMba(AvdBase):
                    _fields = ("_custom_data", "enabled", "timeout")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None
                    timeout: Annotated[int, Max[65535]] | None = None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, timeout: Annotated[int, Max[65535]] | None = None
                    ) -> None:
                        """
                        AuthenticationFailureFallbackMba.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            timeout: timeout

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "disabled", "authentication_failure_fallback_mba")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                disabled: bool | None = None
                authentication_failure_fallback_mba: AuthenticationFailureFallbackMba | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    disabled: bool | None = None,
                    authentication_failure_fallback_mba: AuthenticationFailureFallbackMba | None = None,
                ) -> None:
                    """
                    Eapol.

                    Args:
                    -----
                        _custom_data: _custom_data
                        disabled: disabled
                        authentication_failure_fallback_mba: authentication_failure_fallback_mba

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Aaa(AvdBase):
                class Unresponsive(AvdBase):
                    class Action(AvdBase):
                        class CachedResultsTimeout(AvdBase):
                            _fields = ("_custom_data", "time_duration", "time_duration_unit")
                            _required_fields = ()
                            _custom_data: dict[str, Any] | None = None
                            time_duration: Annotated[int, Min[1]] | None = None
                            """
                            Enable caching for a specific duration -
                            <1-10000>      duration in days
                            <1-14400000>   duration in
                            minutes
                            <1-240000>     duration in hours
                            <1-864000000>  duration in seconds
                            """
                            time_duration_unit: Annotated[str, ValidValues["days", "hours", "minutes", "seconds"]] = None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | None = None,
                                time_duration: Annotated[int, Min[1]] | None = None,
                                time_duration_unit: Annotated[str, ValidValues["days", "hours", "minutes", "seconds"]] = None,
                            ) -> None:
                                """
                                CachedResultsTimeout.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    time_duration:
                                       Enable caching for a specific duration -
                                       <1-10000>      duration in days
                                       <1-14400000>   duration in
                                       minutes
                                       <1-240000>     duration in hours
                                       <1-864000000>  duration in seconds
                                    time_duration_unit: time_duration_unit

                                """
                                for arg, arg_value in locals().items():
                                    if arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields = (
                            "_custom_data",
                            "traffic_allow_access_list",
                            "apply_cached_results",
                            "cached_results_timeout",
                            "apply_alternate",
                            "traffic_allow",
                            "traffic_allow_vlan",
                        )
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        traffic_allow_access_list: str | None = None
                        """Name of standard access-list to apply when AAA times out."""
                        apply_cached_results: bool | None = None
                        """Use results from a previous AAA response."""
                        cached_results_timeout: CachedResultsTimeout | None = None
                        apply_alternate: bool | None = None
                        """
                        Apply alternate action if primary action fails.
                        eg. aaa unresponsive action apply cached-results
                        else traffic allow
                        """
                        traffic_allow: bool | None = None
                        """Set action for supplicant traffic when AAA times out."""
                        traffic_allow_vlan: Annotated[int, Min[1], Max[4094]] | None = None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            traffic_allow_access_list: str | None = None,
                            apply_cached_results: bool | None = None,
                            cached_results_timeout: CachedResultsTimeout | None = None,
                            apply_alternate: bool | None = None,
                            traffic_allow: bool | None = None,
                            traffic_allow_vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                        ) -> None:
                            """
                            Action.

                            Args:
                            -----
                                _custom_data: _custom_data
                                traffic_allow_access_list: Name of standard access-list to apply when AAA times out.
                                apply_cached_results: Use results from a previous AAA response.
                                cached_results_timeout: cached_results_timeout
                                apply_alternate:
                                   Apply alternate action if primary action fails.
                                   eg. aaa unresponsive action apply cached-results
                                   else traffic allow
                                traffic_allow: Set action for supplicant traffic when AAA times out.
                                traffic_allow_vlan: traffic_allow_vlan

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class PhoneAction(AvdBase):
                        class CachedResultsTimeout(AvdBase):
                            _fields = ("_custom_data", "time_duration", "time_duration_unit")
                            _required_fields = ()
                            _custom_data: dict[str, Any] | None = None
                            time_duration: Annotated[int, Min[1]] | None = None
                            """
                            Enable caching for a specific duration -
                            <1-10000>      duration in days
                            <1-14400000>   duration in
                            minutes
                            <1-240000>     duration in hours
                            <1-864000000>  duration in seconds
                            """
                            time_duration_unit: Annotated[str, ValidValues["days", "hours", "minutes", "seconds"]] = None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | None = None,
                                time_duration: Annotated[int, Min[1]] | None = None,
                                time_duration_unit: Annotated[str, ValidValues["days", "hours", "minutes", "seconds"]] = None,
                            ) -> None:
                                """
                                CachedResultsTimeout.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    time_duration:
                                       Enable caching for a specific duration -
                                       <1-10000>      duration in days
                                       <1-14400000>   duration in
                                       minutes
                                       <1-240000>     duration in hours
                                       <1-864000000>  duration in seconds
                                    time_duration_unit: time_duration_unit

                                """
                                for arg, arg_value in locals().items():
                                    if arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields = ("_custom_data", "apply_cached_results", "cached_results_timeout", "apply_alternate", "traffic_allow")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        apply_cached_results: bool | None = None
                        """Use results from a previous AAA response."""
                        cached_results_timeout: CachedResultsTimeout | None = None
                        apply_alternate: bool | None = None
                        """
                        Apply alternate action if primary action fails.
                        eg. aaa unresponsive phone action apply cached-
                        results else traffic allow
                        """
                        traffic_allow: bool | None = None
                        """Set action for supplicant traffic when AAA times out."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            apply_cached_results: bool | None = None,
                            cached_results_timeout: CachedResultsTimeout | None = None,
                            apply_alternate: bool | None = None,
                            traffic_allow: bool | None = None,
                        ) -> None:
                            """
                            PhoneAction.

                            Args:
                            -----
                                _custom_data: _custom_data
                                apply_cached_results: Use results from a previous AAA response.
                                cached_results_timeout: cached_results_timeout
                                apply_alternate:
                                   Apply alternate action if primary action fails.
                                   eg. aaa unresponsive phone action apply cached-
                                   results else traffic allow
                                traffic_allow: Set action for supplicant traffic when AAA times out.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "eap_response", "action", "phone_action")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    eap_response: Annotated[str, ValidValues["success", "disabled"]] | None = None
                    """EAP response to send. EOS default is `success`."""
                    action: Action | None = None
                    """Set action for supplicant when AAA times out."""
                    phone_action: PhoneAction | None = None
                    """Set action for supplicant when AAA times out."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        eap_response: Annotated[str, ValidValues["success", "disabled"]] | None = None,
                        action: Action | None = None,
                        phone_action: PhoneAction | None = None,
                    ) -> None:
                        """
                        Unresponsive.

                        Args:
                        -----
                            _custom_data: _custom_data
                            eap_response: EAP response to send. EOS default is `success`.
                            action: Set action for supplicant when AAA times out.
                            phone_action: Set action for supplicant when AAA times out.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "unresponsive")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                unresponsive: Unresponsive | None = None
                """Configure AAA timeout options."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, unresponsive: Unresponsive | None = None) -> None:
                    """
                    Aaa.

                    Args:
                    -----
                        _custom_data: _custom_data
                        unresponsive: Configure AAA timeout options.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = (
                "_custom_data",
                "port_control",
                "port_control_force_authorized_phone",
                "reauthentication",
                "pae",
                "authentication_failure",
                "host_mode",
                "mac_based_authentication",
                "mac_based_access_list",
                "timeout",
                "reauthorization_request_limit",
                "unauthorized",
                "eapol",
                "aaa",
            )
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            port_control: Annotated[str, ValidValues["auto", "force-authorized", "force-unauthorized"]] | None = None
            port_control_force_authorized_phone: bool | None = None
            reauthentication: bool | None = None
            pae: Pae | None = None
            authentication_failure: AuthenticationFailure | None = None
            host_mode: HostMode | None = None
            mac_based_authentication: MacBasedAuthentication | None = None
            mac_based_access_list: bool | None = None
            """Operate interface in per-mac access-list mode."""
            timeout: Timeout | None = None
            reauthorization_request_limit: Annotated[int, Min[1], Max[10]] | None = None
            unauthorized: Unauthorized | None = None
            eapol: Eapol | None = None
            aaa: Aaa | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                port_control: Annotated[str, ValidValues["auto", "force-authorized", "force-unauthorized"]] | None = None,
                port_control_force_authorized_phone: bool | None = None,
                reauthentication: bool | None = None,
                pae: Pae | None = None,
                authentication_failure: AuthenticationFailure | None = None,
                host_mode: HostMode | None = None,
                mac_based_authentication: MacBasedAuthentication | None = None,
                mac_based_access_list: bool | None = None,
                timeout: Timeout | None = None,
                reauthorization_request_limit: Annotated[int, Min[1], Max[10]] | None = None,
                unauthorized: Unauthorized | None = None,
                eapol: Eapol | None = None,
                aaa: Aaa | None = None,
            ) -> None:
                """
                Dot1x.

                Args:
                -----
                    _custom_data: _custom_data
                    port_control: port_control
                    port_control_force_authorized_phone: port_control_force_authorized_phone
                    reauthentication: reauthentication
                    pae: pae
                    authentication_failure: authentication_failure
                    host_mode: host_mode
                    mac_based_authentication: mac_based_authentication
                    mac_based_access_list: Operate interface in per-mac access-list mode.
                    timeout: timeout
                    reauthorization_request_limit: reauthorization_request_limit
                    unauthorized: unauthorized
                    eapol: eapol
                    aaa: aaa

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Shape(AvdBase):
            _fields = ("_custom_data", "rate")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            rate: str | None = None
            """
            Rate in kbps, pps or percent.
            Supported options are platform dependent.
            Examples:
            - "5000 kbps"
            -
            "1000 pps"
            - "20 percent"
            """

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, rate: str | None = None) -> None:
                """
                Shape.

                Args:
                -----
                    _custom_data: _custom_data
                    rate:
                       Rate in kbps, pps or percent.
                       Supported options are platform dependent.

                Examples:
                       - "5000 kbps"
                       -
                       "1000 pps"
                       - "20 percent"

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Qos(AvdBase):
            _fields = ("_custom_data", "trust", "dscp", "cos")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            trust: Annotated[str, ValidValues["dscp", "cos", "disabled"]] | None = None
            dscp: int | None = None
            """DSCP value."""
            cos: int | None = None
            """COS value."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                trust: Annotated[str, ValidValues["dscp", "cos", "disabled"]] | None = None,
                dscp: int | None = None,
                cos: int | None = None,
            ) -> None:
                """
                Qos.

                Args:
                -----
                    _custom_data: _custom_data
                    trust: trust
                    dscp: DSCP value.
                    cos: COS value.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PriorityFlowControl(AvdBase):
            class PrioritiesItem(AvdBase):
                _fields = ("_custom_data", "priority", "no_drop")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                priority: Annotated[int, Max[7]] = None
                no_drop: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, priority: Annotated[int, Max[7]] = None, no_drop: bool | None = None) -> None:
                    """
                    PrioritiesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        priority: priority
                        no_drop: no_drop

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "enabled", "priorities")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool | None = None
            priorities: list[PrioritiesItem] | None = None

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, priorities: list[PrioritiesItem] | None = None
            ) -> None:
                """
                PriorityFlowControl.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    priorities: priorities

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Bfd(AvdBase):
            _fields = ("_custom_data", "echo", "interval", "min_rx", "multiplier")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            echo: bool | None = None
            interval: int | None = None
            """Interval in milliseconds."""
            min_rx: int | None = None
            """Rate in milliseconds."""
            multiplier: Annotated[int, Min[3], Max[50]] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                echo: bool | None = None,
                interval: int | None = None,
                min_rx: int | None = None,
                multiplier: Annotated[int, Min[3], Max[50]] | None = None,
            ) -> None:
                """
                Bfd.

                Args:
                -----
                    _custom_data: _custom_data
                    echo: echo
                    interval: Interval in milliseconds.
                    min_rx: Rate in milliseconds.
                    multiplier: multiplier

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ServicePolicy(AvdBase):
            class Pbr(AvdBase):
                _fields = ("_custom_data", "input")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                input: str | None = None
                """Policy Based Routing Policy-map name."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, input: str | None = None) -> None:
                    """
                    Pbr.

                    Args:
                    -----
                        _custom_data: _custom_data
                        input: Policy Based Routing Policy-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Qos(AvdBase):
                _fields = ("_custom_data", "input")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                input: str = None
                """Quality of Service Policy-map name."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, input: str = None) -> None:
                    """
                    Qos.

                    Args:
                    -----
                        _custom_data: _custom_data
                        input: Quality of Service Policy-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "pbr", "qos")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            pbr: Pbr | None = None
            qos: Qos | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, pbr: Pbr | None = None, qos: Qos | None = None) -> None:
                """
                ServicePolicy.

                Args:
                -----
                    _custom_data: _custom_data
                    pbr: pbr
                    qos: qos

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Mpls(AvdBase):
            class Ldp(AvdBase):
                _fields = ("_custom_data", "interface", "igp_sync")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                interface: bool | None = None
                igp_sync: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, interface: bool | None = None, igp_sync: bool | None = None) -> None:
                    """
                    Ldp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interface: interface
                        igp_sync: igp_sync

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "ip", "ldp")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ip: bool | None = None
            ldp: Ldp | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, ip: bool | None = None, ldp: Ldp | None = None) -> None:
                """
                Mpls.

                Args:
                -----
                    _custom_data: _custom_data
                    ip: ip
                    ldp: ldp

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class LacpTimer(AvdBase):
            _fields = ("_custom_data", "mode", "multiplier")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            mode: Annotated[str, ValidValues["fast", "normal"]] | None = None
            multiplier: Annotated[int, Min[3], Max[3000]] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                mode: Annotated[str, ValidValues["fast", "normal"]] | None = None,
                multiplier: Annotated[int, Min[3], Max[3000]] | None = None,
            ) -> None:
                """
                LacpTimer.

                Args:
                -----
                    _custom_data: _custom_data
                    mode: mode
                    multiplier: multiplier

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Transceiver(AvdBase):
            class Media(AvdBase):
                _fields = ("_custom_data", "override")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                override: str | None = None
                """Transceiver type."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, override: str | None = None) -> None:
                    """
                    Media.

                    Args:
                    -----
                        _custom_data: _custom_data
                        override: Transceiver type.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "frequency", "frequency_unit", "media")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            frequency: str | None = None
            """Transceiver Laser Frequency in GHz (min 190000, max 200000)."""
            frequency_unit: Annotated[str, ValidValues["ghz"]] | None = None
            """Unit of Transceiver Laser Frequency."""
            media: Media | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                frequency: str | None = None,
                frequency_unit: Annotated[str, ValidValues["ghz"]] | None = None,
                media: Media | None = None,
            ) -> None:
                """
                Transceiver.

                Args:
                -----
                    _custom_data: _custom_data
                    frequency: Transceiver Laser Frequency in GHz (min 190000, max 200000).
                    frequency_unit: Unit of Transceiver Laser Frequency.
                    media: media

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TrafficPolicy(AvdBase):
            _fields = ("_custom_data", "input", "output")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            input: str | None = None
            """Ingress traffic policy."""
            output: str | None = None
            """Egress traffic policy."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, input: str | None = None, output: str | None = None) -> None:
                """
                TrafficPolicy.

                Args:
                -----
                    _custom_data: _custom_data
                    input: Ingress traffic policy.
                    output: Egress traffic policy.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Bgp(AvdBase):
            _fields = ("_custom_data", "session_tracker")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            session_tracker: str | None = None
            """Name of session tracker."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, session_tracker: str | None = None) -> None:
                """
                Bgp.

                Args:
                -----
                    _custom_data: _custom_data
                    session_tracker: Name of session tracker.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IpIgmpHostProxy(AvdBase):
            class GroupsItem(AvdBase):
                class ExcludeItem(AvdBase):
                    _fields = ("_custom_data", "source")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    source: str = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, source: str = None) -> None:
                        """
                        ExcludeItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source: source

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class IncludeItem(AvdBase):
                    _fields = ("_custom_data", "source")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    source: str = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, source: str = None) -> None:
                        """
                        IncludeItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source: source

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "group", "exclude", "include")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                group: str = None
                """Multicast Address."""
                exclude: list[ExcludeItem] | None = None
                """The same source must not be present both in `exclude` and `include` list."""
                include: list[IncludeItem] | None = None
                """The same source must not be present both in `exclude` and `include` list."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    group: str = None,
                    exclude: list[ExcludeItem] | None = None,
                    include: list[IncludeItem] | None = None,
                ) -> None:
                    """
                    GroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        group: Multicast Address.
                        exclude: The same source must not be present both in `exclude` and `include` list.
                        include: The same source must not be present both in `exclude` and `include` list.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AccessListsItem(AvdBase):
                _fields = ("_custom_data", "name")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None) -> None:
                    """
                    AccessListsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "enabled", "groups", "report_interval", "access_lists", "version")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool | None = None
            groups: list[GroupsItem] | None = None
            report_interval: Annotated[int, Min[1], Max[31744]] | None = None
            """Time interval between unsolicited reports."""
            access_lists: list[AccessListsItem] | None = None
            """Non-standard Access List name."""
            version: Annotated[int, Min[1], Max[3]] | None = None
            """IGMP version on IGMP host-proxy interface."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enabled: bool | None = None,
                groups: list[GroupsItem] | None = None,
                report_interval: Annotated[int, Min[1], Max[31744]] | None = None,
                access_lists: list[AccessListsItem] | None = None,
                version: Annotated[int, Min[1], Max[3]] | None = None,
            ) -> None:
                """
                IpIgmpHostProxy.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    groups: groups
                    report_interval: Time interval between unsolicited reports.
                    access_lists: Non-standard Access List name.
                    version: IGMP version on IGMP host-proxy interface.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Sflow(AvdBase):
            class Egress(AvdBase):
                _fields = ("_custom_data", "enable", "unmodified_enable")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enable: bool | None = None
                unmodified_enable: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, enable: bool | None = None, unmodified_enable: bool | None = None) -> None:
                    """
                    Egress.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enable: enable
                        unmodified_enable: unmodified_enable

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "enable", "egress")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enable: bool | None = None
            egress: Egress | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, enable: bool | None = None, egress: Egress | None = None) -> None:
                """
                Sflow.

                Args:
                -----
                    _custom_data: _custom_data
                    enable: enable
                    egress: egress

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SyncE(AvdBase):
            _fields = ("_custom_data", "enable", "priority")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enable: bool | None = None
            priority: str | None = None
            """
            The priority is used to influence the reference clock selection. The EOS default priority is 127.
            The priority can be configured to any integer between 1-255, or set to `disabled`.
            """

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, enable: bool | None = None, priority: str | None = None) -> None:
                """
                SyncE.

                Args:
                -----
                    _custom_data: _custom_data
                    enable: enable
                    priority:
                       The priority is used to influence the reference clock selection. The EOS default priority is 127.
                       The priority can be configured to any integer between 1-255, or set to `disabled`.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class UcTxQueuesItem(AvdBase):
            class RandomDetect(AvdBase):
                class Ecn(AvdBase):
                    class Threshold(AvdBase):
                        _fields = ("_custom_data", "units", "min", "max", "max_probability", "weight")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        units: Annotated[str, ValidValues["segments", "bytes", "kbytes", "mbytes", "milliseconds"]] = None
                        """Indicate the units to be used for the threshold values."""
                        min: Annotated[int, Min[1], Max[256000000]] = None
                        """Set the random-detect ECN minimum-threshold."""
                        max: Annotated[int, Min[1], Max[256000000]] = None
                        """Set the random-detect ECN maximum-threshold."""
                        max_probability: Annotated[int, Min[1], Max[100]] | None = None
                        """Set the random-detect ECN max-mark-probability."""
                        weight: Annotated[int, Max[15]] | None = None
                        """Set the random-detect ECN weight."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            units: Annotated[str, ValidValues["segments", "bytes", "kbytes", "mbytes", "milliseconds"]] = None,
                            min: Annotated[int, Min[1], Max[256000000]] = None,
                            max: Annotated[int, Min[1], Max[256000000]] = None,
                            max_probability: Annotated[int, Min[1], Max[100]] | None = None,
                            weight: Annotated[int, Max[15]] | None = None,
                        ) -> None:
                            """
                            Threshold.

                            Args:
                            -----
                                _custom_data: _custom_data
                                units: Indicate the units to be used for the threshold values.
                                min: Set the random-detect ECN minimum-threshold.
                                max: Set the random-detect ECN maximum-threshold.
                                max_probability: Set the random-detect ECN max-mark-probability.
                                weight: Set the random-detect ECN weight.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "count", "threshold")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    count: bool | None = None
                    """Enable counter for random-detect ECNs."""
                    threshold: Threshold | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, count: bool | None = None, threshold: Threshold | None = None) -> None:
                        """
                        Ecn.

                        Args:
                        -----
                            _custom_data: _custom_data
                            count: Enable counter for random-detect ECNs.
                            threshold: threshold

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "ecn")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ecn: Ecn | None = None
                """Explicit Congestion Notification."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, ecn: Ecn | None = None) -> None:
                    """
                    RandomDetect.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ecn: Explicit Congestion Notification.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "id", "random_detect")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            id: int = None
            """TX-Queue ID."""
            random_detect: RandomDetect | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, id: int = None, random_detect: RandomDetect | None = None) -> None:
                """
                UcTxQueuesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: TX-Queue ID.
                    random_detect: random_detect

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TxQueuesItem(AvdBase):
            class RandomDetect(AvdBase):
                class Ecn(AvdBase):
                    class Threshold(AvdBase):
                        _fields = ("_custom_data", "units", "min", "max", "max_probability", "weight")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        units: Annotated[str, ValidValues["segments", "bytes", "kbytes", "mbytes", "milliseconds"]] = None
                        """Indicate the units to be used for the threshold values."""
                        min: Annotated[int, Min[1], Max[256000000]] | None = None
                        """Set the random-detect ECN minimum-threshold."""
                        max: Annotated[int, Min[1], Max[256000000]] = None
                        """Set the random-detect ECN maximum-threshold."""
                        max_probability: Annotated[int, Min[1], Max[100]] = None
                        """Set the random-detect ECN max-mark-probability."""
                        weight: Annotated[int, Max[15]] | None = None
                        """Set the random-detect ECN weight."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            units: Annotated[str, ValidValues["segments", "bytes", "kbytes", "mbytes", "milliseconds"]] = None,
                            min: Annotated[int, Min[1], Max[256000000]] | None = None,
                            max: Annotated[int, Min[1], Max[256000000]] = None,
                            max_probability: Annotated[int, Min[1], Max[100]] = None,
                            weight: Annotated[int, Max[15]] | None = None,
                        ) -> None:
                            """
                            Threshold.

                            Args:
                            -----
                                _custom_data: _custom_data
                                units: Indicate the units to be used for the threshold values.
                                min: Set the random-detect ECN minimum-threshold.
                                max: Set the random-detect ECN maximum-threshold.
                                max_probability: Set the random-detect ECN max-mark-probability.
                                weight: Set the random-detect ECN weight.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "count", "threshold")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    count: bool | None = None
                    """Enable counter for random-detect ECNs."""
                    threshold: Threshold | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, count: bool | None = None, threshold: Threshold | None = None) -> None:
                        """
                        Ecn.

                        Args:
                        -----
                            _custom_data: _custom_data
                            count: Enable counter for random-detect ECNs.
                            threshold: threshold

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "ecn")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ecn: Ecn | None = None
                """Explicit Congestion Notification."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, ecn: Ecn | None = None) -> None:
                    """
                    RandomDetect.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ecn: Explicit Congestion Notification.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "id", "random_detect")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            id: int = None
            """TX-Queue ID."""
            random_detect: RandomDetect | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, id: int = None, random_detect: RandomDetect | None = None) -> None:
                """
                TxQueuesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: TX-Queue ID.
                    random_detect: random_detect

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrrpIdsItem(AvdBase):
            class Advertisement(AvdBase):
                _fields = ("_custom_data", "interval")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                interval: Annotated[int, Min[1], Max[255]] | None = None
                """Interval in seconds."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, interval: Annotated[int, Min[1], Max[255]] | None = None) -> None:
                    """
                    Advertisement.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interval: Interval in seconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Preempt(AvdBase):
                class Delay(AvdBase):
                    _fields = ("_custom_data", "minimum", "reload")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    minimum: Annotated[int, Max[3600]] | None = None
                    """Minimum preempt delay in seconds."""
                    reload: Annotated[int, Max[3600]] | None = None
                    """Reload preempt delay in seconds."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        minimum: Annotated[int, Max[3600]] | None = None,
                        reload: Annotated[int, Max[3600]] | None = None,
                    ) -> None:
                        """
                        Delay.

                        Args:
                        -----
                            _custom_data: _custom_data
                            minimum: Minimum preempt delay in seconds.
                            reload: Reload preempt delay in seconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "enabled", "delay")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool = None
                delay: Delay | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, delay: Delay | None = None) -> None:
                    """
                    Preempt.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        delay: delay

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Timers(AvdBase):
                class Delay(AvdBase):
                    _fields = ("_custom_data", "reload")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    reload: Annotated[int, Max[3600]] | None = None
                    """Delay after reload in seconds."""

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, reload: Annotated[int, Max[3600]] | None = None) -> None:
                        """
                        Delay.

                        Args:
                        -----
                            _custom_data: _custom_data
                            reload: Delay after reload in seconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "delay")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                delay: Delay | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, delay: Delay | None = None) -> None:
                    """
                    Timers.

                    Args:
                    -----
                        _custom_data: _custom_data
                        delay: delay

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class TrackedObjectItem(AvdBase):
                _fields = ("_custom_data", "name", "decrement", "shutdown")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Tracked object name."""
                decrement: Annotated[int, Min[1], Max[254]] | None = None
                """Decrement VRRP priority by 1-254."""
                shutdown: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    decrement: Annotated[int, Min[1], Max[254]] | None = None,
                    shutdown: bool | None = None,
                ) -> None:
                    """
                    TrackedObjectItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Tracked object name.
                        decrement: Decrement VRRP priority by 1-254.
                        shutdown: shutdown

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv4(AvdBase):
                _fields = ("_custom_data", "address", "version")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                address: str = None
                """Virtual IPv4 address."""
                version: Annotated[int, ValidValues[2, 3]] | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, address: str = None, version: Annotated[int, ValidValues[2, 3]] | None = None
                ) -> None:
                    """
                    Ipv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        address: Virtual IPv4 address.
                        version: version

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv6(AvdBase):
                _fields = ("_custom_data", "address")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                address: str = None
                """Virtual IPv6 address."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, address: str = None) -> None:
                    """
                    Ipv6.

                    Args:
                    -----
                        _custom_data: _custom_data
                        address: Virtual IPv6 address.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "id", "priority_level", "advertisement", "preempt", "timers", "tracked_object", "ipv4", "ipv6")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            id: int = None
            """VRID."""
            priority_level: Annotated[int, Min[1], Max[254]] | None = None
            """Instance priority."""
            advertisement: Advertisement | None = None
            preempt: Preempt | None = None
            timers: Timers | None = None
            tracked_object: list[TrackedObjectItem] | None = None
            ipv4: Ipv4 | None = None
            ipv6: Ipv6 | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                id: int = None,
                priority_level: Annotated[int, Min[1], Max[254]] | None = None,
                advertisement: Advertisement | None = None,
                preempt: Preempt | None = None,
                timers: Timers | None = None,
                tracked_object: list[TrackedObjectItem] | None = None,
                ipv4: Ipv4 | None = None,
                ipv6: Ipv6 | None = None,
            ) -> None:
                """
                VrrpIdsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: VRID.
                    priority_level: Instance priority.
                    advertisement: advertisement
                    preempt: preempt
                    timers: timers
                    tracked_object: tracked_object
                    ipv4: ipv4
                    ipv6: ipv6

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Switchport(AvdBase):
            class Trunk(AvdBase):
                _fields = ("_custom_data", "allowed_vlan", "native_vlan", "native_vlan_tag", "private_vlan_secondary", "groups")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                allowed_vlan: str | None = None
                """
                VLAN ID or range(s) of VLAN IDs.
                Warning: This should not be combined with
                `ethernet_interfaces[].mode = trunk` and `ethernet_interface[].vlans`.
                """
                native_vlan: Annotated[int, Min[1], Max[4094]] | None = None
                """
                Set native VLAN when interface is in trunking mode.
                Warning: This should not be combined with
                `ethernet_interfaces[].native_vlan`.
                """
                native_vlan_tag: bool | None = None
                """
                If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                Warning: This
                should not be combined with `ethernet_interfaces[].native_vlan_tag`.
                """
                private_vlan_secondary: bool | None = None
                """
                Enable secondary VLAN mapping for a private vlan.
                Warning: This should not be combined with
                `ethernet_ineterfaces[].trunk_private_vlan_secondary`.
                """
                groups: list[str] | None = None
                """Warning: This should not be combined with `ethernet_ineterfaces[].trunk_groups`."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    allowed_vlan: str | None = None,
                    native_vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                    native_vlan_tag: bool | None = None,
                    private_vlan_secondary: bool | None = None,
                    groups: list[str] | None = None,
                ) -> None:
                    """
                    Trunk.

                    Args:
                    -----
                        _custom_data: _custom_data
                        allowed_vlan:
                           VLAN ID or range(s) of VLAN IDs.
                           Warning: This should not be combined with
                           `ethernet_interfaces[].mode = trunk` and `ethernet_interface[].vlans`.
                        native_vlan:
                           Set native VLAN when interface is in trunking mode.
                           Warning: This should not be combined with
                           `ethernet_interfaces[].native_vlan`.
                        native_vlan_tag:
                           If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                           Warning: This
                           should not be combined with `ethernet_interfaces[].native_vlan_tag`.
                        private_vlan_secondary:
                           Enable secondary VLAN mapping for a private vlan.
                           Warning: This should not be combined with
                           `ethernet_ineterfaces[].trunk_private_vlan_secondary`.
                        groups: Warning: This should not be combined with `ethernet_ineterfaces[].trunk_groups`.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Phone(AvdBase):
                _fields = ("_custom_data", "vlan", "trunk")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                vlan: Annotated[int, Min[1], Max[4094]] | None = None
                """Warning: This should not be combined with `ethernet_interfaces[].phone.vlan`."""
                trunk: Annotated[str, ValidValues["tagged", "tagged phone", "untagged", "untagged phone"]] | None = None
                """Warning: This should not be combined with `ethernet_interfaces[].phone.trunk`."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                    trunk: Annotated[str, ValidValues["tagged", "tagged phone", "untagged", "untagged phone"]] | None = None,
                ) -> None:
                    """
                    Phone.

                    Args:
                    -----
                        _custom_data: _custom_data
                        vlan: Warning: This should not be combined with `ethernet_interfaces[].phone.vlan`.
                        trunk: Warning: This should not be combined with `ethernet_interfaces[].phone.trunk`.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Dot1q(AvdBase):
                _fields = ("_custom_data", "ethertype", "vlan_tag")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ethertype: Annotated[int, Min[1536], Max[65535]] | None = None
                """Ethertype/TPID (Tag Protocol IDentifier) for VLAN tagged frames."""
                vlan_tag: Annotated[str, ValidValues["disallowed", "required"]] | None = None
                """Allow/disallow VLAN tagged frames."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    ethertype: Annotated[int, Min[1536], Max[65535]] | None = None,
                    vlan_tag: Annotated[str, ValidValues["disallowed", "required"]] | None = None,
                ) -> None:
                    """
                    Dot1q.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ethertype: Ethertype/TPID (Tag Protocol IDentifier) for VLAN tagged frames.
                        vlan_tag: Allow/disallow VLAN tagged frames.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class VlanTranslations(AvdBase):
                class DirectionInItem(AvdBase):
                    _fields = ("_custom_data", "field_from", "to", "dot1q_tunnel", "inner_vlan_from")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    field_from: str = None
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: Annotated[int, Min[1], Max[4094]] = None
                    """VLAN ID to map to."""
                    dot1q_tunnel: bool | None = None
                    inner_vlan_from: Annotated[int, Min[1], Max[4094]] | None = None
                    """Inner VLAN ID to map from."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        field_from: str = None,
                        to: Annotated[int, Min[1], Max[4094]] = None,
                        dot1q_tunnel: bool | None = None,
                        inner_vlan_from: Annotated[int, Min[1], Max[4094]] | None = None,
                    ) -> None:
                        """
                        DirectionInItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                            to: VLAN ID to map to.
                            dot1q_tunnel: dot1q_tunnel
                            inner_vlan_from: Inner VLAN ID to map from.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class DirectionOutItem(AvdBase):
                    _fields = ("_custom_data", "field_from", "to", "dot1q_tunnel_to", "inner_vlan_to")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    field_from: str = None
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: Annotated[int, Min[1], Max[4094]] | None = None
                    """VLAN ID to map to."""
                    dot1q_tunnel_to: str | None = None
                    """
                    VLAN ID or range of VLAN IDs or "all". Range 1-4094.
                    This takes precedence over `to` and
                    `inner_vlan_to`.
                    """
                    inner_vlan_to: Annotated[int, Min[1], Max[4094]] | None = None
                    """Inner VLAN ID to map to."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        field_from: str = None,
                        to: Annotated[int, Min[1], Max[4094]] | None = None,
                        dot1q_tunnel_to: str | None = None,
                        inner_vlan_to: Annotated[int, Min[1], Max[4094]] | None = None,
                    ) -> None:
                        """
                        DirectionOutItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                            to: VLAN ID to map to.
                            dot1q_tunnel_to:
                               VLAN ID or range of VLAN IDs or "all". Range 1-4094.
                               This takes precedence over `to` and
                               `inner_vlan_to`.
                            inner_vlan_to: Inner VLAN ID to map to.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class DirectionBothItem(AvdBase):
                    _fields = ("_custom_data", "field_from", "to", "dot1q_tunnel", "inner_vlan_from", "network")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    field_from: str = None
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: Annotated[int, Min[1], Max[4094]] = None
                    """VLAN ID to map to."""
                    dot1q_tunnel: bool | None = None
                    inner_vlan_from: Annotated[int, Min[1], Max[4094]] | None = None
                    """Inner VLAN ID to map from."""
                    network: bool | None = None
                    """
                    Enable use of network-side VLAN ID.
                    This setting can only be enabled when `inner_vlan_from` is
                    defined.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        field_from: str = None,
                        to: Annotated[int, Min[1], Max[4094]] = None,
                        dot1q_tunnel: bool | None = None,
                        inner_vlan_from: Annotated[int, Min[1], Max[4094]] | None = None,
                        network: bool | None = None,
                    ) -> None:
                        """
                        DirectionBothItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                            to: VLAN ID to map to.
                            dot1q_tunnel: dot1q_tunnel
                            inner_vlan_from: Inner VLAN ID to map from.
                            network:
                               Enable use of network-side VLAN ID.
                               This setting can only be enabled when `inner_vlan_from` is
                               defined.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "in_required", "out_required", "direction_in", "direction_out", "direction_both")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                in_required: bool | None = None
                """Drop the ingress traffic that do not match any VLAN mapping."""
                out_required: bool | None = None
                """Drop the egress traffic that do not match any VLAN mapping."""
                direction_in: list[DirectionInItem] | None = None
                """Map ingress traffic only."""
                direction_out: list[DirectionOutItem] | None = None
                """Map egress traffic only."""
                direction_both: list[DirectionBothItem] | None = None
                """Map both egress and ingress traffic."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    in_required: bool | None = None,
                    out_required: bool | None = None,
                    direction_in: list[DirectionInItem] | None = None,
                    direction_out: list[DirectionOutItem] | None = None,
                    direction_both: list[DirectionBothItem] | None = None,
                ) -> None:
                    """
                    VlanTranslations.

                    Args:
                    -----
                        _custom_data: _custom_data
                        in_required: Drop the ingress traffic that do not match any VLAN mapping.
                        out_required: Drop the egress traffic that do not match any VLAN mapping.
                        direction_in: Map ingress traffic only.
                        direction_out: Map egress traffic only.
                        direction_both: Map both egress and ingress traffic.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class BackupLink(AvdBase):
                _fields = ("_custom_data", "interface", "prefer_vlan")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                interface: str | None = None
                """Backup interface. Example - Ethernet4, Vlan10 etc."""
                prefer_vlan: str | None = None
                """VLANs to carry on the backup interface (1-4094)."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, interface: str | None = None, prefer_vlan: str | None = None) -> None:
                    """
                    BackupLink.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interface: Backup interface. Example - Ethernet4, Vlan10 etc.
                        prefer_vlan: VLANs to carry on the backup interface (1-4094).

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Backup(AvdBase):
                _fields = ("_custom_data", "dest_macaddr", "initial_mac_move_delay", "mac_move_burst", "mac_move_burst_interval", "preemption_delay")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                dest_macaddr: Annotated[str, Format["mac"]] | None = None
                """
                Destination MAC address for MAC move updates.
                The mac address should be multicast or broadcast.
                Example: 01:00:00:00:00:00
                """
                initial_mac_move_delay: Annotated[int, Max[65535]] | None = None
                """Initial MAC move delay in milliseconds."""
                mac_move_burst: Annotated[int, Max[65535]] | None = None
                """Size of MAC move bursts."""
                mac_move_burst_interval: Annotated[int, Max[65535]] | None = None
                """MAC move burst interval in milliseconds."""
                preemption_delay: Annotated[int, Max[65535]] | None = None
                """Preemption delay in milliseconds."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    dest_macaddr: Annotated[str, Format["mac"]] | None = None,
                    initial_mac_move_delay: Annotated[int, Max[65535]] | None = None,
                    mac_move_burst: Annotated[int, Max[65535]] | None = None,
                    mac_move_burst_interval: Annotated[int, Max[65535]] | None = None,
                    preemption_delay: Annotated[int, Max[65535]] | None = None,
                ) -> None:
                    """
                    Backup.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dest_macaddr:
                           Destination MAC address for MAC move updates.
                           The mac address should be multicast or broadcast.
                           Example: 01:00:00:00:00:00
                        initial_mac_move_delay: Initial MAC move delay in milliseconds.
                        mac_move_burst: Size of MAC move bursts.
                        mac_move_burst_interval: MAC move burst interval in milliseconds.
                        preemption_delay: Preemption delay in milliseconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PortSecurity(AvdBase):
                class MacAddressMaximum(AvdBase):
                    _fields = ("_custom_data", "disabled", "limit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    disabled: bool | None = None
                    """Disable port level check for port security (only in violation 'shutdown' mode)."""
                    limit: Annotated[int, Min[1], Max[1000]] | None = None
                    """MAC address limit."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        disabled: bool | None = None,
                        limit: Annotated[int, Min[1], Max[1000]] | None = None,
                    ) -> None:
                        """
                        MacAddressMaximum.

                        Args:
                        -----
                            _custom_data: _custom_data
                            disabled: Disable port level check for port security (only in violation 'shutdown' mode).
                            limit: MAC address limit.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Violation(AvdBase):
                    _fields = ("_custom_data", "mode", "protect_log")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    mode: Annotated[str, ValidValues["shutdown", "protect"]] | None = None
                    """Configure port security mode."""
                    protect_log: bool | None = None
                    """Log new addresses seen after limit is reached in protect mode."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        mode: Annotated[str, ValidValues["shutdown", "protect"]] | None = None,
                        protect_log: bool | None = None,
                    ) -> None:
                        """
                        Violation.

                        Args:
                        -----
                            _custom_data: _custom_data
                            mode: Configure port security mode.
                            protect_log: Log new addresses seen after limit is reached in protect mode.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class VlansItem(AvdBase):
                    _fields = ("_custom_data", "range", "mac_address_maximum")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    range: str = None
                    """
                    VLAN ID or range(s) of VLAN IDs, <1-4094>.
                    Example:
                      - 3
                      - 1,3
                      - 1-10
                    """
                    mac_address_maximum: int | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, range: str = None, mac_address_maximum: int | None = None) -> None:
                        """
                        VlansItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            range:
                               VLAN ID or range(s) of VLAN IDs, <1-4094>.

                        Example:
                                 - 3
                                 - 1,3
                                 - 1-10
                            mac_address_maximum: mac_address_maximum

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "enabled", "mac_address_maximum", "violation", "vlan_default_mac_address_maximum", "vlans")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                mac_address_maximum: MacAddressMaximum | None = None
                """Maximum number of MAC addresses allowed on the interface."""
                violation: Violation | None = None
                """Configure violation mode (shutdown or protect), EOS default is 'shutdown'."""
                vlan_default_mac_address_maximum: Annotated[int, Max[1000]] | None = None
                """Default maximum MAC addresses for all VLANs on this interface."""
                vlans: list[VlansItem] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    enabled: bool | None = None,
                    mac_address_maximum: MacAddressMaximum | None = None,
                    violation: Violation | None = None,
                    vlan_default_mac_address_maximum: Annotated[int, Max[1000]] | None = None,
                    vlans: list[VlansItem] | None = None,
                ) -> None:
                    """
                    PortSecurity.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        mac_address_maximum: Maximum number of MAC addresses allowed on the interface.
                        violation: Configure violation mode (shutdown or protect), EOS default is 'shutdown'.
                        vlan_default_mac_address_maximum: Default maximum MAC addresses for all VLANs on this interface.
                        vlans: vlans

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = (
                "_custom_data",
                "enabled",
                "mode",
                "access_vlan",
                "trunk",
                "phone",
                "pvlan_mapping",
                "dot1q",
                "source_interface",
                "vlan_translations",
                "vlan_forwarding_accept_all",
                "backup_link",
                "backup",
                "port_security",
            )
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool | None = None
            """Warning: This should not be combined with `ethernet_interfaces[].type = routed`."""
            mode: Annotated[str, ValidValues["access", "dot1q-tunnel", "trunk", "trunk phone"]] | None = None
            """Warning: This should not be combined with `ethernet_interfaces[].mode`."""
            access_vlan: Annotated[int, Min[1], Max[4094]] | None = None
            """
            Set VLAN when interface is in access mode.
            Warning: This should not be combined with
            `ethernet_interfaces[].mode = access/dot1q-tunnel` and `ethernet_interface[].vlans`.
            """
            trunk: Trunk | None = None
            phone: Phone | None = None
            """Warning: This should not be combined with `ethernet_interfaces[].phone`."""
            pvlan_mapping: str | None = None
            """
            Secondary VLAN IDs of the private VLAN mapping.
            Warning: This should not be combined with
            `ethernet_interfaces[].pvlan_mapping`.
            """
            dot1q: Dot1q | None = None
            source_interface: Annotated[str, ValidValues["tx", "tx multicast"]] | None = None
            """
            tx: Allow bridged traffic to go out of the source interface.
            tx multicast: Allow multicast traffic
            only to go out of the source interface.
            """
            vlan_translations: VlanTranslations | None = None
            """
            VLAN Translation mappings.
            Warning: This should not be combined with
            `ethernet_interfaces[].vlan_translations`.
            """
            vlan_forwarding_accept_all: bool | None = None
            backup_link: BackupLink | None = None
            backup: Backup | None = None
            """The `backup_link` is required for this setting."""
            port_security: PortSecurity | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enabled: bool | None = None,
                mode: Annotated[str, ValidValues["access", "dot1q-tunnel", "trunk", "trunk phone"]] | None = None,
                access_vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                trunk: Trunk | None = None,
                phone: Phone | None = None,
                pvlan_mapping: str | None = None,
                dot1q: Dot1q | None = None,
                source_interface: Annotated[str, ValidValues["tx", "tx multicast"]] | None = None,
                vlan_translations: VlanTranslations | None = None,
                vlan_forwarding_accept_all: bool | None = None,
                backup_link: BackupLink | None = None,
                backup: Backup | None = None,
                port_security: PortSecurity | None = None,
            ) -> None:
                """
                Switchport.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: Warning: This should not be combined with `ethernet_interfaces[].type = routed`.
                    mode: Warning: This should not be combined with `ethernet_interfaces[].mode`.
                    access_vlan:
                       Set VLAN when interface is in access mode.
                       Warning: This should not be combined with
                       `ethernet_interfaces[].mode = access/dot1q-tunnel` and `ethernet_interface[].vlans`.
                    trunk: trunk
                    phone: Warning: This should not be combined with `ethernet_interfaces[].phone`.
                    pvlan_mapping:
                       Secondary VLAN IDs of the private VLAN mapping.
                       Warning: This should not be combined with
                       `ethernet_interfaces[].pvlan_mapping`.
                    dot1q: dot1q
                    source_interface:
                       tx: Allow bridged traffic to go out of the source interface.
                       tx multicast: Allow multicast traffic
                       only to go out of the source interface.
                    vlan_translations:
                       VLAN Translation mappings.
                       Warning: This should not be combined with
                       `ethernet_interfaces[].vlan_translations`.
                    vlan_forwarding_accept_all: vlan_forwarding_accept_all
                    backup_link: backup_link
                    backup: The `backup_link` is required for this setting.
                    port_security: port_security

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "name",
            "description",
            "shutdown",
            "load_interval",
            "speed",
            "mtu",
            "l2_mtu",
            "l2_mru",
            "vlans",
            "native_vlan",
            "native_vlan_tag",
            "mode",
            "phone",
            "l2_protocol",
            "trunk_groups",
            "type",
            "snmp_trap_link_change",
            "address_locking",
            "flowcontrol",
            "vrf",
            "flow_tracker",
            "error_correction_encoding",
            "link_tracking_groups",
            "evpn_ethernet_segment",
            "encapsulation_dot1q_vlan",
            "encapsulation_dot1q",
            "encapsulation_vlan",
            "vlan_id",
            "ip_address",
            "ip_address_secondaries",
            "ip_verify_unicast_source_reachable_via",
            "dhcp_client_accept_default_route",
            "dhcp_server_ipv4",
            "dhcp_server_ipv6",
            "ip_helpers",
            "ip_nat",
            "ipv6_enable",
            "ipv6_address",
            "ipv6_address_link_local",
            "ipv6_nd_ra_disabled",
            "ipv6_nd_managed_config_flag",
            "ipv6_nd_prefixes",
            "ipv6_dhcp_relay_destinations",
            "access_group_in",
            "access_group_out",
            "ipv6_access_group_in",
            "ipv6_access_group_out",
            "mac_access_group_in",
            "mac_access_group_out",
            "multicast",
            "ospf_network_point_to_point",
            "ospf_area",
            "ospf_cost",
            "ospf_authentication",
            "ospf_authentication_key",
            "ospf_message_digest_keys",
            "pim",
            "mac_security",
            "tcp_mss_ceiling",
            "channel_group",
            "isis_enable",
            "isis_bfd",
            "isis_passive",
            "isis_metric",
            "isis_network_point_to_point",
            "isis_circuit_type",
            "isis_hello_padding",
            "isis_authentication_mode",
            "isis_authentication_key",
            "poe",
            "ptp",
            "profile",
            "storm_control",
            "logging",
            "lldp",
            "trunk_private_vlan_secondary",
            "pvlan_mapping",
            "vlan_translations",
            "dot1x",
            "service_profile",
            "shape",
            "qos",
            "spanning_tree_bpdufilter",
            "spanning_tree_bpduguard",
            "spanning_tree_guard",
            "spanning_tree_portfast",
            "vmtracer",
            "priority_flow_control",
            "bfd",
            "service_policy",
            "mpls",
            "lacp_timer",
            "lacp_port_priority",
            "transceiver",
            "ip_proxy_arp",
            "traffic_policy",
            "bgp",
            "ip_igmp_host_proxy",
            "peer",
            "peer_interface",
            "peer_type",
            "sflow",
            "sync_e",
            "port_profile",
            "uc_tx_queues",
            "tx_queues",
            "vrrp_ids",
            "validate_state",
            "switchport",
            "eos_cli",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        description: str | None = None
        shutdown: bool | None = None
        load_interval: Annotated[int, Max[600]] | None = None
        """Interval in seconds for updating interface counters."""
        speed: str | None = None
        """
        Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
        <interface_speed>`.
        """
        mtu: Annotated[int, Min[68], Max[65535]] | None = None
        l2_mtu: Annotated[int, Min[68], Max[65535]] | None = None
        """"l2_mtu" should only be defined for platforms supporting the "l2 mtu" CLI."""
        l2_mru: Annotated[int, Min[68], Max[65535]] | None = None
        """"l2_mru" should only be defined for platforms supporting the "l2 mru" CLI."""
        vlans: str | None = None
        """
        List of switchport vlans as string.
        For a trunk port this would be a range like "1-200,300".
        For an
        access port this would be a single vlan "123".
        """
        native_vlan: int | None = None
        native_vlan_tag: bool | None = None
        """If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence."""
        mode: Annotated[str, ValidValues["access", "dot1q-tunnel", "trunk", "trunk phone"]] | None = None
        phone: Phone | None = None
        l2_protocol: L2Protocol | None = None
        trunk_groups: list[str] | None = None
        type: Annotated[str, ValidValues["routed", "switched", "l3dot1q", "l2dot1q", "port-channel-member"]] | None = None
        """
        l3dot1q and l2dot1q are used for sub-interfaces. The parent interface should be defined as routed.
        The `type = switched/routed` should not be combined with `switchport`.
        """
        snmp_trap_link_change: bool | None = None
        address_locking: AddressLocking | None = None
        flowcontrol: Flowcontrol | None = None
        vrf: str | None = None
        """VRF name."""
        flow_tracker: FlowTracker | None = None
        error_correction_encoding: ErrorCorrectionEncoding | None = None
        link_tracking_groups: list[LinkTrackingGroupsItem] | None = None
        evpn_ethernet_segment: EvpnEthernetSegment | None = None
        encapsulation_dot1q_vlan: int | None = None
        """VLAN tag to configure on sub-interface."""
        encapsulation_dot1q: EncapsulationDot1q | None = None
        """
        Warning: `encapsulation_dot1q` should not be combined with `ethernet_interfaces[].type: l3dot1q` or
        `ethernet_interfaces[].type: l2dot1q`.
        """
        encapsulation_vlan: EncapsulationVlan | None = None
        """
        This setting can only be applied to sub-interfaces on EOS.
        Warning: `encapsulation_vlan` should not
        be combined with `ethernet_interfaces[].type: l3dot1q` or `ethernet_interfaces[].type: l2dot1q`.
        """
        vlan_id: Annotated[int, Min[1], Max[4094]] | None = None
        """
        This setting can only be applied to sub-interfaces on EOS.
        Warning: `vlan_id` should not be combined
        with `ethernet_interfaces[].type == l2dot1q`.
        """
        ip_address: str | None = None
        """IPv4 address/mask or "dhcp"."""
        ip_address_secondaries: list[str] | None = None
        ip_verify_unicast_source_reachable_via: Annotated[str, ValidValues["any", "rx"]] | None = None
        dhcp_client_accept_default_route: bool | None = None
        """Install default-route obtained via DHCP."""
        dhcp_server_ipv4: bool | None = None
        """Enable IPv4 DHCP server."""
        dhcp_server_ipv6: bool | None = None
        """Enable IPv6 DHCP server."""
        ip_helpers: list[IpHelpersItem] | None = None
        ip_nat: IpNat | None = None
        ipv6_enable: bool | None = None
        ipv6_address: str | None = None
        ipv6_address_link_local: str | None = None
        """Link local IPv6 address/mask."""
        ipv6_nd_ra_disabled: bool | None = None
        ipv6_nd_managed_config_flag: bool | None = None
        ipv6_nd_prefixes: list[Ipv6NdPrefixesItem] | None = None
        ipv6_dhcp_relay_destinations: list[Ipv6DhcpRelayDestinationsItem] | None = None
        access_group_in: str | None = None
        """Access list name."""
        access_group_out: str | None = None
        """Access list name."""
        ipv6_access_group_in: str | None = None
        """IPv6 access list name."""
        ipv6_access_group_out: str | None = None
        """IPv6 access list name."""
        mac_access_group_in: str | None = None
        """MAC access list name."""
        mac_access_group_out: str | None = None
        """MAC access list name."""
        multicast: Multicast | None = None
        """
        Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
        of both.
        """
        ospf_network_point_to_point: bool | None = None
        ospf_area: str | None = None
        ospf_cost: int | None = None
        ospf_authentication: Annotated[str, ValidValues["none", "simple", "message-digest"]] | None = None
        ospf_authentication_key: str | None = None
        """Encrypted password - only type 7 supported."""
        ospf_message_digest_keys: list[OspfMessageDigestKeysItem] | None = None
        pim: Pim | None = None
        mac_security: MacSecurity | None = None
        tcp_mss_ceiling: TcpMssCeiling | None = None
        """
        The TCP MSS clamping feature involves clamping the maximum segment size (MSS) in the TCP header
        of
        TCP SYN packets if it exceeds the configured MSS ceiling limit for the interface.
        """
        channel_group: ChannelGroup | None = None
        isis_enable: str | None = None
        """ISIS instance."""
        isis_bfd: bool | None = None
        """Enable BFD for ISIS."""
        isis_passive: bool | None = None
        isis_metric: int | None = None
        isis_network_point_to_point: bool | None = None
        isis_circuit_type: Annotated[str, ValidValues["level-1-2", "level-1", "level-2"]] | None = None
        isis_hello_padding: bool | None = None
        isis_authentication_mode: Annotated[str, ValidValues["text", "md5"]] | None = None
        isis_authentication_key: str | None = None
        """Type-7 encrypted password."""
        poe: Poe | None = None
        ptp: Ptp | None = None
        profile: str | None = None
        """Interface profile."""
        storm_control: StormControl | None = None
        logging: Logging | None = None
        lldp: Lldp | None = None
        trunk_private_vlan_secondary: bool | None = None
        pvlan_mapping: str | None = None
        """List of vlans as string."""
        vlan_translations: list[VlanTranslationsItem] | None = None
        dot1x: Dot1x | None = None
        service_profile: str | None = None
        """QOS profile."""
        shape: Shape | None = None
        qos: Qos | None = None
        spanning_tree_bpdufilter: Annotated[str, ValidValues["enabled", "disabled", "True", "False", "true", "false"]] | None = None
        spanning_tree_bpduguard: Annotated[str, ValidValues["enabled", "disabled", "True", "False", "true", "false"]] | None = None
        spanning_tree_guard: Annotated[str, ValidValues["loop", "root", "disabled"]] | None = None
        spanning_tree_portfast: Annotated[str, ValidValues["edge", "network"]] | None = None
        vmtracer: bool | None = None
        priority_flow_control: PriorityFlowControl | None = None
        bfd: Bfd | None = None
        service_policy: ServicePolicy | None = None
        mpls: Mpls | None = None
        lacp_timer: LacpTimer | None = None
        lacp_port_priority: Annotated[int, Max[65535]] | None = None
        transceiver: Transceiver | None = None
        ip_proxy_arp: bool | None = None
        traffic_policy: TrafficPolicy | None = None
        bgp: Bgp | None = None
        ip_igmp_host_proxy: IpIgmpHostProxy | None = None
        peer: str | None = None
        """Key only used for documentation or validation purposes."""
        peer_interface: str | None = None
        """Key only used for documentation or validation purposes."""
        peer_type: str | None = None
        """Key only used for documentation or validation purposes."""
        sflow: Sflow | None = None
        sync_e: SyncE | None = None
        port_profile: str | None = None
        """Key only used for documentation or validation purposes."""
        uc_tx_queues: list[UcTxQueuesItem] | None = None
        tx_queues: list[TxQueuesItem] | None = None
        vrrp_ids: list[VrrpIdsItem] | None = None
        """VRRP model."""
        validate_state: bool | None = None
        """Set to false to disable interface validation by the `eos_validate_state` role."""
        switchport: Switchport | None = None
        """This should not be combined with `ethernet_interfaces[].type = switched/routed`."""
        eos_cli: str | None = None
        """Multiline EOS CLI rendered directly on the ethernet interface in the final EOS configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str = None,
            description: str | None = None,
            shutdown: bool | None = None,
            load_interval: Annotated[int, Max[600]] | None = None,
            speed: str | None = None,
            mtu: Annotated[int, Min[68], Max[65535]] | None = None,
            l2_mtu: Annotated[int, Min[68], Max[65535]] | None = None,
            l2_mru: Annotated[int, Min[68], Max[65535]] | None = None,
            vlans: str | None = None,
            native_vlan: int | None = None,
            native_vlan_tag: bool | None = None,
            mode: Annotated[str, ValidValues["access", "dot1q-tunnel", "trunk", "trunk phone"]] | None = None,
            phone: Phone | None = None,
            l2_protocol: L2Protocol | None = None,
            trunk_groups: list[str] | None = None,
            type: Annotated[str, ValidValues["routed", "switched", "l3dot1q", "l2dot1q", "port-channel-member"]] | None = None,
            snmp_trap_link_change: bool | None = None,
            address_locking: AddressLocking | None = None,
            flowcontrol: Flowcontrol | None = None,
            vrf: str | None = None,
            flow_tracker: FlowTracker | None = None,
            error_correction_encoding: ErrorCorrectionEncoding | None = None,
            link_tracking_groups: list[LinkTrackingGroupsItem] | None = None,
            evpn_ethernet_segment: EvpnEthernetSegment | None = None,
            encapsulation_dot1q_vlan: int | None = None,
            encapsulation_dot1q: EncapsulationDot1q | None = None,
            encapsulation_vlan: EncapsulationVlan | None = None,
            vlan_id: Annotated[int, Min[1], Max[4094]] | None = None,
            ip_address: str | None = None,
            ip_address_secondaries: list[str] | None = None,
            ip_verify_unicast_source_reachable_via: Annotated[str, ValidValues["any", "rx"]] | None = None,
            dhcp_client_accept_default_route: bool | None = None,
            dhcp_server_ipv4: bool | None = None,
            dhcp_server_ipv6: bool | None = None,
            ip_helpers: list[IpHelpersItem] | None = None,
            ip_nat: IpNat | None = None,
            ipv6_enable: bool | None = None,
            ipv6_address: str | None = None,
            ipv6_address_link_local: str | None = None,
            ipv6_nd_ra_disabled: bool | None = None,
            ipv6_nd_managed_config_flag: bool | None = None,
            ipv6_nd_prefixes: list[Ipv6NdPrefixesItem] | None = None,
            ipv6_dhcp_relay_destinations: list[Ipv6DhcpRelayDestinationsItem] | None = None,
            access_group_in: str | None = None,
            access_group_out: str | None = None,
            ipv6_access_group_in: str | None = None,
            ipv6_access_group_out: str | None = None,
            mac_access_group_in: str | None = None,
            mac_access_group_out: str | None = None,
            multicast: Multicast | None = None,
            ospf_network_point_to_point: bool | None = None,
            ospf_area: str | None = None,
            ospf_cost: int | None = None,
            ospf_authentication: Annotated[str, ValidValues["none", "simple", "message-digest"]] | None = None,
            ospf_authentication_key: str | None = None,
            ospf_message_digest_keys: list[OspfMessageDigestKeysItem] | None = None,
            pim: Pim | None = None,
            mac_security: MacSecurity | None = None,
            tcp_mss_ceiling: TcpMssCeiling | None = None,
            channel_group: ChannelGroup | None = None,
            isis_enable: str | None = None,
            isis_bfd: bool | None = None,
            isis_passive: bool | None = None,
            isis_metric: int | None = None,
            isis_network_point_to_point: bool | None = None,
            isis_circuit_type: Annotated[str, ValidValues["level-1-2", "level-1", "level-2"]] | None = None,
            isis_hello_padding: bool | None = None,
            isis_authentication_mode: Annotated[str, ValidValues["text", "md5"]] | None = None,
            isis_authentication_key: str | None = None,
            poe: Poe | None = None,
            ptp: Ptp | None = None,
            profile: str | None = None,
            storm_control: StormControl | None = None,
            logging: Logging | None = None,
            lldp: Lldp | None = None,
            trunk_private_vlan_secondary: bool | None = None,
            pvlan_mapping: str | None = None,
            vlan_translations: list[VlanTranslationsItem] | None = None,
            dot1x: Dot1x | None = None,
            service_profile: str | None = None,
            shape: Shape | None = None,
            qos: Qos | None = None,
            spanning_tree_bpdufilter: Annotated[str, ValidValues["enabled", "disabled", "True", "False", "true", "false"]] | None = None,
            spanning_tree_bpduguard: Annotated[str, ValidValues["enabled", "disabled", "True", "False", "true", "false"]] | None = None,
            spanning_tree_guard: Annotated[str, ValidValues["loop", "root", "disabled"]] | None = None,
            spanning_tree_portfast: Annotated[str, ValidValues["edge", "network"]] | None = None,
            vmtracer: bool | None = None,
            priority_flow_control: PriorityFlowControl | None = None,
            bfd: Bfd | None = None,
            service_policy: ServicePolicy | None = None,
            mpls: Mpls | None = None,
            lacp_timer: LacpTimer | None = None,
            lacp_port_priority: Annotated[int, Max[65535]] | None = None,
            transceiver: Transceiver | None = None,
            ip_proxy_arp: bool | None = None,
            traffic_policy: TrafficPolicy | None = None,
            bgp: Bgp | None = None,
            ip_igmp_host_proxy: IpIgmpHostProxy | None = None,
            peer: str | None = None,
            peer_interface: str | None = None,
            peer_type: str | None = None,
            sflow: Sflow | None = None,
            sync_e: SyncE | None = None,
            port_profile: str | None = None,
            uc_tx_queues: list[UcTxQueuesItem] | None = None,
            tx_queues: list[TxQueuesItem] | None = None,
            vrrp_ids: list[VrrpIdsItem] | None = None,
            validate_state: bool | None = None,
            switchport: Switchport | None = None,
            eos_cli: str | None = None,
        ) -> None:
            """
            EthernetInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: name
                description: description
                shutdown: shutdown
                load_interval: Interval in seconds for updating interface counters.
                speed:
                   Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                   <interface_speed>`.
                mtu: mtu
                l2_mtu: "l2_mtu" should only be defined for platforms supporting the "l2 mtu" CLI.
                l2_mru: "l2_mru" should only be defined for platforms supporting the "l2 mru" CLI.
                vlans:
                   List of switchport vlans as string.
                   For a trunk port this would be a range like "1-200,300".
                   For an
                   access port this would be a single vlan "123".
                native_vlan: native_vlan
                native_vlan_tag: If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                mode: mode
                phone: phone
                l2_protocol: l2_protocol
                trunk_groups: trunk_groups
                type:
                   l3dot1q and l2dot1q are used for sub-interfaces. The parent interface should be defined as routed.
                   The `type = switched/routed` should not be combined with `switchport`.
                snmp_trap_link_change: snmp_trap_link_change
                address_locking: address_locking
                flowcontrol: flowcontrol
                vrf: VRF name.
                flow_tracker: flow_tracker
                error_correction_encoding: error_correction_encoding
                link_tracking_groups: link_tracking_groups
                evpn_ethernet_segment: evpn_ethernet_segment
                encapsulation_dot1q_vlan: VLAN tag to configure on sub-interface.
                encapsulation_dot1q:
                   Warning: `encapsulation_dot1q` should not be combined with `ethernet_interfaces[].type: l3dot1q` or
                   `ethernet_interfaces[].type: l2dot1q`.
                encapsulation_vlan:
                   This setting can only be applied to sub-interfaces on EOS.
                   Warning: `encapsulation_vlan` should not
                   be combined with `ethernet_interfaces[].type: l3dot1q` or `ethernet_interfaces[].type: l2dot1q`.
                vlan_id:
                   This setting can only be applied to sub-interfaces on EOS.
                   Warning: `vlan_id` should not be combined
                   with `ethernet_interfaces[].type == l2dot1q`.
                ip_address: IPv4 address/mask or "dhcp".
                ip_address_secondaries: ip_address_secondaries
                ip_verify_unicast_source_reachable_via: ip_verify_unicast_source_reachable_via
                dhcp_client_accept_default_route: Install default-route obtained via DHCP.
                dhcp_server_ipv4: Enable IPv4 DHCP server.
                dhcp_server_ipv6: Enable IPv6 DHCP server.
                ip_helpers: ip_helpers
                ip_nat: ip_nat
                ipv6_enable: ipv6_enable
                ipv6_address: ipv6_address
                ipv6_address_link_local: Link local IPv6 address/mask.
                ipv6_nd_ra_disabled: ipv6_nd_ra_disabled
                ipv6_nd_managed_config_flag: ipv6_nd_managed_config_flag
                ipv6_nd_prefixes: ipv6_nd_prefixes
                ipv6_dhcp_relay_destinations: ipv6_dhcp_relay_destinations
                access_group_in: Access list name.
                access_group_out: Access list name.
                ipv6_access_group_in: IPv6 access list name.
                ipv6_access_group_out: IPv6 access list name.
                mac_access_group_in: MAC access list name.
                mac_access_group_out: MAC access list name.
                multicast:
                   Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
                   of both.
                ospf_network_point_to_point: ospf_network_point_to_point
                ospf_area: ospf_area
                ospf_cost: ospf_cost
                ospf_authentication: ospf_authentication
                ospf_authentication_key: Encrypted password - only type 7 supported.
                ospf_message_digest_keys: ospf_message_digest_keys
                pim: pim
                mac_security: mac_security
                tcp_mss_ceiling:
                   The TCP MSS clamping feature involves clamping the maximum segment size (MSS) in the TCP header
                   of
                   TCP SYN packets if it exceeds the configured MSS ceiling limit for the interface.
                channel_group: channel_group
                isis_enable: ISIS instance.
                isis_bfd: Enable BFD for ISIS.
                isis_passive: isis_passive
                isis_metric: isis_metric
                isis_network_point_to_point: isis_network_point_to_point
                isis_circuit_type: isis_circuit_type
                isis_hello_padding: isis_hello_padding
                isis_authentication_mode: isis_authentication_mode
                isis_authentication_key: Type-7 encrypted password.
                poe: poe
                ptp: ptp
                profile: Interface profile.
                storm_control: storm_control
                logging: logging
                lldp: lldp
                trunk_private_vlan_secondary: trunk_private_vlan_secondary
                pvlan_mapping: List of vlans as string.
                vlan_translations: vlan_translations
                dot1x: dot1x
                service_profile: QOS profile.
                shape: shape
                qos: qos
                spanning_tree_bpdufilter: spanning_tree_bpdufilter
                spanning_tree_bpduguard: spanning_tree_bpduguard
                spanning_tree_guard: spanning_tree_guard
                spanning_tree_portfast: spanning_tree_portfast
                vmtracer: vmtracer
                priority_flow_control: priority_flow_control
                bfd: bfd
                service_policy: service_policy
                mpls: mpls
                lacp_timer: lacp_timer
                lacp_port_priority: lacp_port_priority
                transceiver: transceiver
                ip_proxy_arp: ip_proxy_arp
                traffic_policy: traffic_policy
                bgp: bgp
                ip_igmp_host_proxy: ip_igmp_host_proxy
                peer: Key only used for documentation or validation purposes.
                peer_interface: Key only used for documentation or validation purposes.
                peer_type: Key only used for documentation or validation purposes.
                sflow: sflow
                sync_e: sync_e
                port_profile: Key only used for documentation or validation purposes.
                uc_tx_queues: uc_tx_queues
                tx_queues: tx_queues
                vrrp_ids: VRRP model.
                validate_state: Set to false to disable interface validation by the `eos_validate_state` role.
                switchport: This should not be combined with `ethernet_interfaces[].type = switched/routed`.
                eos_cli: Multiline EOS CLI rendered directly on the ethernet interface in the final EOS configuration.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class EventHandlersItem(AvdBase):
        class Actions(AvdBase):
            _fields = ("_custom_data", "bash_command", "log", "increment_device_health_metric")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            bash_command: str | None = None
            """Define BASH command action. Command could be multiline also."""
            log: bool | None = None
            """Log a message when the event is triggered."""
            increment_device_health_metric: str | None = None
            """Name of device-health metric."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                bash_command: str | None = None,
                log: bool | None = None,
                increment_device_health_metric: str | None = None,
            ) -> None:
                """
                Actions.

                Args:
                -----
                    _custom_data: _custom_data
                    bash_command: Define BASH command action. Command could be multiline also.
                    log: Log a message when the event is triggered.
                    increment_device_health_metric: Name of device-health metric.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TriggerOnCounters(AvdBase):
            _fields = ("_custom_data", "condition", "granularity_per_source", "poll_interval")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            condition: str | None = None
            """Set the logical expression to evaluate."""
            granularity_per_source: bool | None = None
            """
            Set the granularity of event counting for a wildcarded condition.
            Example -
              condition (
            Arad*.IptCrcErrCnt.delta > 100 ) and ( Arad*.UcFifoFullDrop.delta > 100 )
              [* wildcard is used
            here]
            """
            poll_interval: Annotated[int, Min[1], Max[1000000]] | None = None
            """Set the polling interval in seconds."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                condition: str | None = None,
                granularity_per_source: bool | None = None,
                poll_interval: Annotated[int, Min[1], Max[1000000]] | None = None,
            ) -> None:
                """
                TriggerOnCounters.

                Args:
                -----
                    _custom_data: _custom_data
                    condition: Set the logical expression to evaluate.
                    granularity_per_source:
                       Set the granularity of event counting for a wildcarded condition.
                       Example -
                         condition (
                       Arad*.IptCrcErrCnt.delta > 100 ) and ( Arad*.UcFifoFullDrop.delta > 100 )
                         [* wildcard is used
                       here]
                    poll_interval: Set the polling interval in seconds.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TriggerOnLogging(AvdBase):
            _fields = ("_custom_data", "poll_interval", "regex")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            poll_interval: Annotated[int, Min[1], Max[1000000]] | None = None
            """Set the polling interval in seconds."""
            regex: str | None = None
            """Regular expression to use for searching log messages."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, poll_interval: Annotated[int, Min[1], Max[1000000]] | None = None, regex: str | None = None
            ) -> None:
                """
                TriggerOnLogging.

                Args:
                -----
                    _custom_data: _custom_data
                    poll_interval: Set the polling interval in seconds.
                    regex: Regular expression to use for searching log messages.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TriggerOnIntf(AvdBase):
            _fields = ("_custom_data", "interface", "ip", "ipv6", "operstatus")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            interface: str = None
            """
            Interface name.
            Example - Ethernet4
                      Loopback4-6
                      Port-channel4,7
            """
            ip: bool | None = None
            """Action is triggered upon changes to interface IP address assignment."""
            ipv6: bool | None = None
            """Action is triggered upon changes to interface ipv6 address assignment."""
            operstatus: bool | None = None
            """Action is triggered upon changes to interface operStatus."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                interface: str = None,
                ip: bool | None = None,
                ipv6: bool | None = None,
                operstatus: bool | None = None,
            ) -> None:
                """
                TriggerOnIntf.

                Args:
                -----
                    _custom_data: _custom_data
                    interface:
                       Interface name.
                       Example - Ethernet4
                                 Loopback4-6
                                 Port-channel4,7
                    ip: Action is triggered upon changes to interface IP address assignment.
                    ipv6: Action is triggered upon changes to interface ipv6 address assignment.
                    operstatus: Action is triggered upon changes to interface operStatus.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TriggerOnMaintenance(AvdBase):
            _fields = ("_custom_data", "operation", "bgp_peer", "action", "stage", "vrf", "interface", "unit")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            operation: Annotated[str, ValidValues["enter", "exit"]] = None
            bgp_peer: str | None = None
            """
            Ipv4/Ipv6 address or peer group name.
            Trigger condition occurs on maintenance operation of specified
            BGP peer.
            """
            action: Annotated[str, ValidValues["after", "before", "all", "begin", "end"]] = None
            """Action for maintenance operation."""
            stage: Annotated[str, ValidValues["bgp", "linkdown", "mlag", "ratemon"]] | None = None
            """Action is triggered after/before specified stage."""
            vrf: str | None = None
            """VRF name. VRF can be defined for "bgp_peer" only."""
            interface: str | None = None
            """Trigger condition occurs on maintenance operation of specified interface."""
            unit: str | None = None
            """Name of unit. Trigger condition occurs on maintenance operation of specified unit"""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                operation: Annotated[str, ValidValues["enter", "exit"]] = None,
                bgp_peer: str | None = None,
                action: Annotated[str, ValidValues["after", "before", "all", "begin", "end"]] = None,
                stage: Annotated[str, ValidValues["bgp", "linkdown", "mlag", "ratemon"]] | None = None,
                vrf: str | None = None,
                interface: str | None = None,
                unit: str | None = None,
            ) -> None:
                """
                TriggerOnMaintenance.

                Args:
                -----
                    _custom_data: _custom_data
                    operation: operation
                    bgp_peer:
                       Ipv4/Ipv6 address or peer group name.
                       Trigger condition occurs on maintenance operation of specified
                       BGP peer.
                    action: Action for maintenance operation.
                    stage: Action is triggered after/before specified stage.
                    vrf: VRF name. VRF can be defined for "bgp_peer" only.
                    interface: Trigger condition occurs on maintenance operation of specified interface.
                    unit: Name of unit. Trigger condition occurs on maintenance operation of specified unit

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "name",
            "actions",
            "delay",
            "trigger",
            "trigger_on_counters",
            "trigger_on_logging",
            "trigger_on_intf",
            "trigger_on_maintenance",
            "asynchronous",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Event Handler Name."""
        actions: Actions | None = None
        """Note: `bash_command` and `log` are mutually exclusive. `bash_command` takes precedence over `log`."""
        delay: int | None = None
        """Event-handler delay in seconds."""
        trigger: (
            Annotated[str, ValidValues["on-boot", "on-counters", "on-intf", "on-logging", "on-maintenance", "on-startup-config", "vm-tracer vm"]] | None
        ) = None
        """Configure event trigger condition."""
        trigger_on_counters: TriggerOnCounters | None = None
        trigger_on_logging: TriggerOnLogging | None = None
        trigger_on_intf: TriggerOnIntf | None = None
        """
        Trigger condition occurs on specified interface changes.
        Note: Any one of the `ip`, `ipv6` and
        `operstatus` key needs to be defined along with the `interface`.
        """
        trigger_on_maintenance: TriggerOnMaintenance | None = None
        """Settings required for trigger 'on-maintenance'."""
        asynchronous: bool | None = False
        """Set the action to be non-blocking."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str = None,
            actions: Actions | None = None,
            delay: int | None = None,
            trigger: Annotated[str, ValidValues["on-boot", "on-counters", "on-intf", "on-logging", "on-maintenance", "on-startup-config", "vm-tracer vm"]]
            | None = None,
            trigger_on_counters: TriggerOnCounters | None = None,
            trigger_on_logging: TriggerOnLogging | None = None,
            trigger_on_intf: TriggerOnIntf | None = None,
            trigger_on_maintenance: TriggerOnMaintenance | None = None,
            asynchronous: bool | None = False,
        ) -> None:
            """
            EventHandlersItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Event Handler Name.
                actions: Note: `bash_command` and `log` are mutually exclusive. `bash_command` takes precedence over `log`.
                delay: Event-handler delay in seconds.
                trigger: Configure event trigger condition.
                trigger_on_counters: trigger_on_counters
                trigger_on_logging: trigger_on_logging
                trigger_on_intf:
                   Trigger condition occurs on specified interface changes.
                   Note: Any one of the `ip`, `ipv6` and
                   `operstatus` key needs to be defined along with the `interface`.
                trigger_on_maintenance: Settings required for trigger 'on-maintenance'.
                asynchronous: Set the action to be non-blocking.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class EventMonitor(AvdBase):
        _fields = ("_custom_data", "enabled")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        enabled: bool | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None) -> None:
            """
            EventMonitor.

            Args:
            -----
                _custom_data: _custom_data
                enabled: enabled

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class FlowTracking(AvdBase):
        class Sampled(AvdBase):
            class Encapsulation(AvdBase):
                _fields = ("_custom_data", "ipv4_ipv6", "mpls")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ipv4_ipv6: bool | None = None
                mpls: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, ipv4_ipv6: bool | None = None, mpls: bool | None = None) -> None:
                    """
                    Encapsulation.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ipv4_ipv6: ipv4_ipv6
                        mpls: mpls

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class HardwareOffload(AvdBase):
                _fields = ("_custom_data", "ipv4", "ipv6", "threshold_minimum")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ipv4: bool | None = None
                """Configure hardware offload for IPv4 traffic."""
                ipv6: bool | None = None
                """Configure hardware offload for IPv6 traffic."""
                threshold_minimum: Annotated[int, Min[1], Max[4294967295]] | None = None
                """Minimum number of samples."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    ipv4: bool | None = None,
                    ipv6: bool | None = None,
                    threshold_minimum: Annotated[int, Min[1], Max[4294967295]] | None = None,
                ) -> None:
                    """
                    HardwareOffload.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ipv4: Configure hardware offload for IPv4 traffic.
                        ipv6: Configure hardware offload for IPv6 traffic.
                        threshold_minimum: Minimum number of samples.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class TrackersItem(AvdBase):
                class RecordExport(AvdBase):
                    _fields = ("_custom_data", "mpls", "on_inactive_timeout", "on_interval")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    mpls: bool | None = None
                    """Export MPLS forwarding information."""
                    on_inactive_timeout: Annotated[int, Min[3000], Max[900000]] | None = None
                    """Flow record inactive export timeout in milliseconds."""
                    on_interval: Annotated[int, Min[1000], Max[36000000]] | None = None
                    """Flow record export interval in milliseconds."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        mpls: bool | None = None,
                        on_inactive_timeout: Annotated[int, Min[3000], Max[900000]] | None = None,
                        on_interval: Annotated[int, Min[1000], Max[36000000]] | None = None,
                    ) -> None:
                        """
                        RecordExport.

                        Args:
                        -----
                            _custom_data: _custom_data
                            mpls: Export MPLS forwarding information.
                            on_inactive_timeout: Flow record inactive export timeout in milliseconds.
                            on_interval: Flow record export interval in milliseconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class ExportersItem(AvdBase):
                    class Collector(AvdBase):
                        _fields = ("_custom_data", "host", "port")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        host: str | None = None
                        """Collector IPv4 address or IPv6 address or fully qualified domain name."""
                        port: Annotated[int, Min[1], Max[65535]] | None = None
                        """Collector Port Number."""

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | None = None, host: str | None = None, port: Annotated[int, Min[1], Max[65535]] | None = None
                        ) -> None:
                            """
                            Collector.

                            Args:
                            -----
                                _custom_data: _custom_data
                                host: Collector IPv4 address or IPv6 address or fully qualified domain name.
                                port: Collector Port Number.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Format(AvdBase):
                        _fields = ("_custom_data", "ipfix_version")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        ipfix_version: int | None = None

                        def __init__(self, *, _custom_data: dict[str, Any] | None = None, ipfix_version: int | None = None) -> None:
                            """
                            Format.

                            Args:
                            -----
                                _custom_data: _custom_data
                                ipfix_version: ipfix_version

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "name", "collector", "format", "local_interface", "template_interval")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    name: str = None
                    """Exporter Name."""
                    collector: Collector | None = None
                    format: Format | None = None
                    local_interface: str | None = None
                    """Local Source Interface."""
                    template_interval: Annotated[int, Min[5000], Max[3600000]] | None = None
                    """Template interval in milliseconds."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        name: str = None,
                        collector: Collector | None = None,
                        format: Format | None = None,
                        local_interface: str | None = None,
                        template_interval: Annotated[int, Min[5000], Max[3600000]] | None = None,
                    ) -> None:
                        """
                        ExportersItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: Exporter Name.
                            collector: collector
                            format: format
                            local_interface: Local Source Interface.
                            template_interval: Template interval in milliseconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "table_size", "record_export", "name", "exporters")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                table_size: Annotated[int, Min[1], Max[614400]] | None = None
                """Maximum number of entries in flow table."""
                record_export: RecordExport | None = None
                name: str = None
                """Tracker Name."""
                exporters: list[ExportersItem] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    table_size: Annotated[int, Min[1], Max[614400]] | None = None,
                    record_export: RecordExport | None = None,
                    name: str = None,
                    exporters: list[ExportersItem] | None = None,
                ) -> None:
                    """
                    TrackersItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        table_size: Maximum number of entries in flow table.
                        record_export: record_export
                        name: Tracker Name.
                        exporters: exporters

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "encapsulation", "sample", "hardware_offload", "trackers", "shutdown")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            encapsulation: Encapsulation | None = None
            sample: Annotated[int, Min[1], Max[4294967295]] | None = None
            hardware_offload: HardwareOffload | None = None
            trackers: list[TrackersItem] | None = None
            shutdown: bool | None = False

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                encapsulation: Encapsulation | None = None,
                sample: Annotated[int, Min[1], Max[4294967295]] | None = None,
                hardware_offload: HardwareOffload | None = None,
                trackers: list[TrackersItem] | None = None,
                shutdown: bool | None = False,
            ) -> None:
                """
                Sampled.

                Args:
                -----
                    _custom_data: _custom_data
                    encapsulation: encapsulation
                    sample: sample
                    hardware_offload: hardware_offload
                    trackers: trackers
                    shutdown: shutdown

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Hardware(AvdBase):
            class Record(AvdBase):
                _fields = ("_custom_data", "format_ipfix_standard_timestamps_counters")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                format_ipfix_standard_timestamps_counters: bool | None = None
                """Enable software export of IPFIX data records."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, format_ipfix_standard_timestamps_counters: bool | None = None) -> None:
                    """
                    Record.

                    Args:
                    -----
                        _custom_data: _custom_data
                        format_ipfix_standard_timestamps_counters: Enable software export of IPFIX data records.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class TrackersItem(AvdBase):
                class RecordExport(AvdBase):
                    _fields = ("_custom_data", "on_inactive_timeout", "on_interval")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    on_inactive_timeout: Annotated[int, Min[3000], Max[900000]] | None = None
                    """Flow record inactive export timeout in milliseconds."""
                    on_interval: Annotated[int, Min[1000], Max[36000000]] | None = None
                    """Flow record export interval in milliseconds."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        on_inactive_timeout: Annotated[int, Min[3000], Max[900000]] | None = None,
                        on_interval: Annotated[int, Min[1000], Max[36000000]] | None = None,
                    ) -> None:
                        """
                        RecordExport.

                        Args:
                        -----
                            _custom_data: _custom_data
                            on_inactive_timeout: Flow record inactive export timeout in milliseconds.
                            on_interval: Flow record export interval in milliseconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class ExportersItem(AvdBase):
                    class Collector(AvdBase):
                        _fields = ("_custom_data", "host", "port")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        host: str | None = None
                        """Collector IPv4 address or IPv6 address or fully qualified domain name."""
                        port: Annotated[int, Min[1], Max[65535]] | None = None
                        """Collector Port Number."""

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | None = None, host: str | None = None, port: Annotated[int, Min[1], Max[65535]] | None = None
                        ) -> None:
                            """
                            Collector.

                            Args:
                            -----
                                _custom_data: _custom_data
                                host: Collector IPv4 address or IPv6 address or fully qualified domain name.
                                port: Collector Port Number.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Format(AvdBase):
                        _fields = ("_custom_data", "ipfix_version")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        ipfix_version: int | None = None

                        def __init__(self, *, _custom_data: dict[str, Any] | None = None, ipfix_version: int | None = None) -> None:
                            """
                            Format.

                            Args:
                            -----
                                _custom_data: _custom_data
                                ipfix_version: ipfix_version

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "name", "collector", "format", "local_interface", "template_interval")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    name: str = None
                    """Exporter Name."""
                    collector: Collector | None = None
                    format: Format | None = None
                    local_interface: str | None = None
                    """Local Source Interface."""
                    template_interval: Annotated[int, Min[5000], Max[3600000]] | None = None
                    """Template interval in milliseconds."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        name: str = None,
                        collector: Collector | None = None,
                        format: Format | None = None,
                        local_interface: str | None = None,
                        template_interval: Annotated[int, Min[5000], Max[3600000]] | None = None,
                    ) -> None:
                        """
                        ExportersItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: Exporter Name.
                            collector: collector
                            format: format
                            local_interface: Local Source Interface.
                            template_interval: Template interval in milliseconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "name", "record_export", "exporters")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Tracker Name."""
                record_export: RecordExport | None = None
                exporters: list[ExportersItem] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    record_export: RecordExport | None = None,
                    exporters: list[ExportersItem] | None = None,
                ) -> None:
                    """
                    TrackersItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Tracker Name.
                        record_export: record_export
                        exporters: exporters

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "record", "trackers", "shutdown")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            record: Record | None = None
            trackers: list[TrackersItem] | None = None
            shutdown: bool | None = False

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                record: Record | None = None,
                trackers: list[TrackersItem] | None = None,
                shutdown: bool | None = False,
            ) -> None:
                """
                Hardware.

                Args:
                -----
                    _custom_data: _custom_data
                    record: record
                    trackers: trackers
                    shutdown: shutdown

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "sampled", "hardware")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        sampled: Sampled | None = None
        hardware: Hardware | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, sampled: Sampled | None = None, hardware: Hardware | None = None) -> None:
            """
            FlowTracking.

            Args:
            -----
                _custom_data: _custom_data
                sampled: sampled
                hardware: hardware

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Hardware(AvdBase):
        class AccessList(AvdBase):
            _fields = ("_custom_data", "mechanism")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            mechanism: Annotated[str, ValidValues["algomatch", "none", "tcam"]] | None = None

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, mechanism: Annotated[str, ValidValues["algomatch", "none", "tcam"]] | None = None
            ) -> None:
                """
                AccessList.

                Args:
                -----
                    _custom_data: _custom_data
                    mechanism: mechanism

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SpeedGroupsItem(AvdBase):
            _fields = ("_custom_data", "speed_group", "serdes")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            speed_group: str = None
            serdes: str | None = None
            """Serdes speed like "10g" or "25g"."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, speed_group: str = None, serdes: str | None = None) -> None:
                """
                SpeedGroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    speed_group: speed_group
                    serdes: Serdes speed like "10g" or "25g".

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PortGroupsItem(AvdBase):
            _fields = ("_custom_data", "port_group", "select")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            port_group: str = None
            select: str | None = None
            """Select Ports to activate"""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, port_group: str = None, select: str | None = None) -> None:
                """
                PortGroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    port_group: port_group
                    select: Select Ports to activate

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "access_list", "speed_groups", "port_groups")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        access_list: AccessList | None = None
        speed_groups: list[SpeedGroupsItem] | None = None
        port_groups: list[PortGroupsItem] | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            access_list: AccessList | None = None,
            speed_groups: list[SpeedGroupsItem] | None = None,
            port_groups: list[PortGroupsItem] | None = None,
        ) -> None:
            """
            Hardware.

            Args:
            -----
                _custom_data: _custom_data
                access_list: access_list
                speed_groups: speed_groups
                port_groups: port_groups

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class HardwareCounters(AvdBase):
        class FeaturesItem(AvdBase):
            _fields = ("_custom_data", "name", "direction", "address_type", "layer3", "vrf", "prefix", "units_packets")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: Annotated[
                str,
                ValidValues[
                    "acl",
                    "decap-group",
                    "directflow",
                    "ecn",
                    "flow-spec",
                    "gre tunnel interface",
                    "ip",
                    "mpls interface",
                    "mpls lfib",
                    "mpls tunnel",
                    "multicast",
                    "nexthop",
                    "pbr",
                    "pdp",
                    "policing interface",
                    "qos",
                    "qos dual-rate-policer",
                    "route",
                    "routed-port",
                    "segment-security",
                    "subinterface",
                    "tapagg",
                    "traffic-class",
                    "traffic-policy",
                    "vlan",
                    "vlan-interface",
                    "vni decap",
                    "vni encap",
                    "vtep decap",
                    "vtep encap",
                ],
            ] = None
            direction: Annotated[str, ValidValues["in", "out", "cpu"]] | None = None
            """
            Most features support only 'in' and 'out'. Some like traffic-policy support 'cpu'.
            Some features DO
            NOT have any direction.
            This validation IS NOT made by the schemas.
            """
            address_type: Annotated[str, ValidValues["ipv4", "ipv6", "mac"]] | None = None
            """
            Supported only for the following features:
            - acl: [ipv4, ipv6, mac] if direction is 'out'
            -
            multicast: [ipv4, ipv6]
            - route: [ipv4, ipv6]
            This validation IS NOT made by the schemas.
            """
            layer3: bool | None = None
            """Supported only for the 'ip' feature."""
            vrf: str | None = None
            """
            Supported only for the 'route' feature.
            This validation IS NOT made by the schemas.
            """
            prefix: str | None = None
            """
            Supported only for the 'route' feature.
            Mandatory for the 'route' feature.
            This validation IS NOT
            made by the schemas.
            """
            units_packets: bool | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: Annotated[
                    str,
                    ValidValues[
                        "acl",
                        "decap-group",
                        "directflow",
                        "ecn",
                        "flow-spec",
                        "gre tunnel interface",
                        "ip",
                        "mpls interface",
                        "mpls lfib",
                        "mpls tunnel",
                        "multicast",
                        "nexthop",
                        "pbr",
                        "pdp",
                        "policing interface",
                        "qos",
                        "qos dual-rate-policer",
                        "route",
                        "routed-port",
                        "segment-security",
                        "subinterface",
                        "tapagg",
                        "traffic-class",
                        "traffic-policy",
                        "vlan",
                        "vlan-interface",
                        "vni decap",
                        "vni encap",
                        "vtep decap",
                        "vtep encap",
                    ],
                ] = None,
                direction: Annotated[str, ValidValues["in", "out", "cpu"]] | None = None,
                address_type: Annotated[str, ValidValues["ipv4", "ipv6", "mac"]] | None = None,
                layer3: bool | None = None,
                vrf: str | None = None,
                prefix: str | None = None,
                units_packets: bool | None = None,
            ) -> None:
                """
                FeaturesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    direction:
                       Most features support only 'in' and 'out'. Some like traffic-policy support 'cpu'.
                       Some features DO
                       NOT have any direction.
                       This validation IS NOT made by the schemas.
                    address_type:
                       Supported only for the following features:
                       - acl: [ipv4, ipv6, mac] if direction is 'out'
                       -
                       multicast: [ipv4, ipv6]
                       - route: [ipv4, ipv6]
                       This validation IS NOT made by the schemas.
                    layer3: Supported only for the 'ip' feature.
                    vrf:
                       Supported only for the 'route' feature.
                       This validation IS NOT made by the schemas.
                    prefix:
                       Supported only for the 'route' feature.
                       Mandatory for the 'route' feature.
                       This validation IS NOT
                       made by the schemas.
                    units_packets: units_packets

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "features")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        features: list[FeaturesItem] | None = None
        """
        This data model allows to configure the list of hardware counters feature
        available on Arista
        platforms.

        The `name` key accepts a list of valid_values which MUST be updated to support
        new
        feature as they are released in EOS.

        The available values of the different keys like 'direction' or
        'address_type'
        are feature and hardware dependent and this model DOES NOT validate that the
        combinations are valid. It is the responsibility of the user of this data model
        to make sure that
        the rendered CLI is accepted by the targeted device.

        Examples:

          * Use:
            ```yaml
        hardware_counters:
              features:
                - name: ip
                  direction: out
                  layer3:
        true
                  units_packets: true
            ```

            to render:
            ```eos
            hardware counter feature
        ip out layer3 units packets
            ```
          * Use:
            ```yaml
            hardware_counters:
              features:
        - name: route
                  address_type: ipv4
                  vrf: test
                  prefix: 192.168.0.0/24
        ```

            to render:
            ```eos
            hardware counter feature route ipv4 vrf test 192.168.0.0/24
        ```
        """

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, features: list[FeaturesItem] | None = None) -> None:
            """
            HardwareCounters.

            Args:
            -----
                _custom_data: _custom_data
                features:
                   This data model allows to configure the list of hardware counters feature
                   available on Arista
                   platforms.

                   The `name` key accepts a list of valid_values which MUST be updated to support
                   new
                   feature as they are released in EOS.

                   The available values of the different keys like 'direction' or
                   'address_type'
                   are feature and hardware dependent and this model DOES NOT validate that the
                   combinations are valid. It is the responsibility of the user of this data model
                   to make sure that
                   the rendered CLI is accepted by the targeted device.

            Examples:
                     * Use:
                       ```yaml
                   hardware_counters:
                         features:
                           - name: ip
                             direction: out
                             layer3:
                   true
                             units_packets: true
                       ```

                       to render:
                       ```eos
                       hardware counter feature
                   ip out layer3 units packets
                       ```
                     * Use:
                       ```yaml
                       hardware_counters:
                         features:
                   - name: route
                             address_type: ipv4
                             vrf: test
                             prefix: 192.168.0.0/24
                   ```

                       to render:
                       ```eos
                       hardware counter feature route ipv4 vrf test 192.168.0.0/24
                   ```

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class InterfaceDefaults(AvdBase):
        class Ethernet(AvdBase):
            _fields = ("_custom_data", "shutdown")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            shutdown: bool | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, shutdown: bool | None = None) -> None:
                """
                Ethernet.

                Args:
                -----
                    _custom_data: _custom_data
                    shutdown: shutdown

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "ethernet", "mtu")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        ethernet: Ethernet | None = None
        mtu: int | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, ethernet: Ethernet | None = None, mtu: int | None = None) -> None:
            """
            InterfaceDefaults.

            Args:
            -----
                _custom_data: _custom_data
                ethernet: ethernet
                mtu: mtu

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class InterfaceGroupsItem(AvdBase):
        _fields = ("_custom_data", "name", "interfaces", "bgp_maintenance_profiles", "interface_maintenance_profiles")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Interface-Group name."""
        interfaces: list[str] | None = None
        bgp_maintenance_profiles: list[str] | None = None
        interface_maintenance_profiles: list[str] | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str = None,
            interfaces: list[str] | None = None,
            bgp_maintenance_profiles: list[str] | None = None,
            interface_maintenance_profiles: list[str] | None = None,
        ) -> None:
            """
            InterfaceGroupsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Interface-Group name.
                interfaces: interfaces
                bgp_maintenance_profiles: bgp_maintenance_profiles
                interface_maintenance_profiles: interface_maintenance_profiles

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class InterfaceProfilesItem(AvdBase):
        _fields = ("_custom_data", "name", "commands")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Interface-Profile Name."""
        commands: list[str] = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, commands: list[str] = None) -> None:
            """
            InterfaceProfilesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Interface-Profile Name.
                commands: commands

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpAccessListsItem(AvdBase):
        class EntriesItem(AvdBase):
            _fields = (
                "_custom_data",
                "sequence",
                "remark",
                "action",
                "protocol",
                "source",
                "source_ports_match",
                "source_ports",
                "destination",
                "destination_ports_match",
                "destination_ports",
                "tcp_flags",
                "fragments",
                "log",
                "ttl",
                "ttl_match",
                "icmp_type",
                "icmp_code",
                "nexthop_group",
                "tracked",
                "dscp",
                "vlan_number",
                "vlan_inner",
                "vlan_mask",
            )
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            sequence: int | None = None
            """ACL entry sequence number."""
            remark: str | None = None
            """
            Comment up to 100 characters.
            If remark is defined, other keys in the ACL entry will be ignored.
            """
            action: Annotated[str, ValidValues["permit", "deny"]] | None = None
            """
            ACL action.
            Required except for remarks.
            """
            protocol: str | None = None
            """
            "ip", "tcp", "udp", "icmp" or other protocol name or number.
            Required except for remarks.
            """
            source: str | None = None
            """
            "any", "<ip>/<mask>" or "<ip>".
            "<ip>" without a mask means host.
            Required except for remarks.
            """
            source_ports_match: Annotated[str, ValidValues["eq", "gt", "lt", "neq", "range"]] | None = "eq"
            source_ports: list[str] | None = None
            destination: str | None = None
            """
            "any", "<ip>/<mask>" or "<ip>".
            "<ip>" without a mask means host.
            Required except for remarks.
            """
            destination_ports_match: Annotated[str, ValidValues["eq", "gt", "lt", "neq", "range"]] | None = "eq"
            destination_ports: list[str] | None = None
            tcp_flags: list[str] | None = None
            fragments: bool | None = None
            """Match non-head fragment packets."""
            log: bool | None = None
            """Log matches against this rule."""
            ttl: Annotated[int, Max[255]] | None = None
            """TTL value."""
            ttl_match: Annotated[str, ValidValues["eq", "gt", "lt", "neq"]] | None = "eq"
            icmp_type: str | None = None
            """Message type name/number for ICMP packets."""
            icmp_code: str | None = None
            """Message code for ICMP packets."""
            nexthop_group: str | None = None
            """nexthop-group name."""
            tracked: bool | None = None
            """Match packets in existing ICMP/UDP/TCP connections."""
            dscp: str | None = None
            """DSCP value or name."""
            vlan_number: int | None = None
            vlan_inner: bool | None = False
            vlan_mask: str | None = None
            """0x000-0xFFF VLAN mask."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                sequence: int | None = None,
                remark: str | None = None,
                action: Annotated[str, ValidValues["permit", "deny"]] | None = None,
                protocol: str | None = None,
                source: str | None = None,
                source_ports_match: Annotated[str, ValidValues["eq", "gt", "lt", "neq", "range"]] | None = "eq",
                source_ports: list[str] | None = None,
                destination: str | None = None,
                destination_ports_match: Annotated[str, ValidValues["eq", "gt", "lt", "neq", "range"]] | None = "eq",
                destination_ports: list[str] | None = None,
                tcp_flags: list[str] | None = None,
                fragments: bool | None = None,
                log: bool | None = None,
                ttl: Annotated[int, Max[255]] | None = None,
                ttl_match: Annotated[str, ValidValues["eq", "gt", "lt", "neq"]] | None = "eq",
                icmp_type: str | None = None,
                icmp_code: str | None = None,
                nexthop_group: str | None = None,
                tracked: bool | None = None,
                dscp: str | None = None,
                vlan_number: int | None = None,
                vlan_inner: bool | None = False,
                vlan_mask: str | None = None,
            ) -> None:
                """
                EntriesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: ACL entry sequence number.
                    remark:
                       Comment up to 100 characters.
                       If remark is defined, other keys in the ACL entry will be ignored.
                    action:
                       ACL action.
                       Required except for remarks.
                    protocol:
                       "ip", "tcp", "udp", "icmp" or other protocol name or number.
                       Required except for remarks.
                    source:
                       "any", "<ip>/<mask>" or "<ip>".
                       "<ip>" without a mask means host.
                       Required except for remarks.
                    source_ports_match: source_ports_match
                    source_ports: source_ports
                    destination:
                       "any", "<ip>/<mask>" or "<ip>".
                       "<ip>" without a mask means host.
                       Required except for remarks.
                    destination_ports_match: destination_ports_match
                    destination_ports: destination_ports
                    tcp_flags: tcp_flags
                    fragments: Match non-head fragment packets.
                    log: Log matches against this rule.
                    ttl: TTL value.
                    ttl_match: ttl_match
                    icmp_type: Message type name/number for ICMP packets.
                    icmp_code: Message code for ICMP packets.
                    nexthop_group: nexthop-group name.
                    tracked: Match packets in existing ICMP/UDP/TCP connections.
                    dscp: DSCP value or name.
                    vlan_number: vlan_number
                    vlan_inner: vlan_inner
                    vlan_mask: 0x000-0xFFF VLAN mask.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "name", "counters_per_entry", "entries")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Access-list Name."""
        counters_per_entry: bool | None = None
        entries: list[EntriesItem] | None = None
        """ACL Entries."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str = None,
            counters_per_entry: bool | None = None,
            entries: list[EntriesItem] | None = None,
        ) -> None:
            """
            IpAccessListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Access-list Name.
                counters_per_entry: counters_per_entry
                entries: ACL Entries.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpCommunityListsItem(AvdBase):
        class EntriesItem(AvdBase):
            _fields = ("_custom_data", "action", "communities", "regexp")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            action: Annotated[str, ValidValues["permit", "deny"]] = None
            communities: list[str] | None = None
            """
            If defined, a standard community-list will be configured.
            Supported community strings (case
            insensitive):
            - GSHUT
            - internet
            - local-as
            - no-advertise
            - no-export
            - <1-4294967040>
            - aa:nn
            """
            regexp: str | None = None
            """
            Regular Expression.
            If defined, a regex community-list will be configured.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                action: Annotated[str, ValidValues["permit", "deny"]] = None,
                communities: list[str] | None = None,
                regexp: str | None = None,
            ) -> None:
                """
                EntriesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    action: action
                    communities:
                       If defined, a standard community-list will be configured.
                       Supported community strings (case
                       insensitive):
                       - GSHUT
                       - internet
                       - local-as
                       - no-advertise
                       - no-export
                       - <1-4294967040>
                       - aa:nn
                    regexp:
                       Regular Expression.
                       If defined, a regex community-list will be configured.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "name", "entries")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """IP Community-list Name."""
        entries: list[EntriesItem] = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, entries: list[EntriesItem] = None) -> None:
            """
            IpCommunityListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: IP Community-list Name.
                entries: entries

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpDhcpRelay(AvdBase):
        _fields = ("_custom_data", "always_on", "all_subnets", "information_option")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        always_on: bool | None = None
        """DhcpRelay Agent will be in always-on mode."""
        all_subnets: bool | None = None
        """Allow forwarding requests with secondary IP addresses in the gateway address "giaddr" field."""
        information_option: bool | None = None
        """Insert Option-82 information."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            always_on: bool | None = None,
            all_subnets: bool | None = None,
            information_option: bool | None = None,
        ) -> None:
            """
            IpDhcpRelay.

            Args:
            -----
                _custom_data: _custom_data
                always_on: DhcpRelay Agent will be in always-on mode.
                all_subnets: Allow forwarding requests with secondary IP addresses in the gateway address "giaddr" field.
                information_option: Insert Option-82 information.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpDhcpSnooping(AvdBase):
        class InformationOption(AvdBase):
            _fields = ("_custom_data", "enabled", "circuit_id_type", "circuit_id_format")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool | None = None
            """Enable insertion of option-82 in DHCP request packets."""
            circuit_id_type: str | None = None
            """"none" or <0 - 255>."""
            circuit_id_format: Annotated[str, ValidValues["%h:%p", "%p:%v"]] | None = None
            """
            Required if `circuit_id_type` is set.
            - "%h:%p" Hostname and interface name
            - "%p:%v" Interface name
            and VLAN ID
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enabled: bool | None = None,
                circuit_id_type: str | None = None,
                circuit_id_format: Annotated[str, ValidValues["%h:%p", "%p:%v"]] | None = None,
            ) -> None:
                """
                InformationOption.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: Enable insertion of option-82 in DHCP request packets.
                    circuit_id_type: "none" or <0 - 255>.
                    circuit_id_format:
                       Required if `circuit_id_type` is set.
                       - "%h:%p" Hostname and interface name
                       - "%p:%v" Interface name
                       and VLAN ID

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "enabled", "bridging", "information_option", "vlan")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        enabled: bool | None = None
        bridging: bool | None = None
        information_option: InformationOption | None = None
        vlan: str | None = None
        """
        VLAN range as string.
        "< vlan_id >, < vlan_id >-< vlan_id >"
        Example: 15,16,17,18
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            enabled: bool | None = None,
            bridging: bool | None = None,
            information_option: InformationOption | None = None,
            vlan: str | None = None,
        ) -> None:
            """
            IpDhcpSnooping.

            Args:
            -----
                _custom_data: _custom_data
                enabled: enabled
                bridging: bridging
                information_option: information_option
                vlan:
                   VLAN range as string.
                   "< vlan_id >, < vlan_id >-< vlan_id >"
                   Example: 15,16,17,18

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpDomainLookup(AvdBase):
        class SourceInterfacesItem(AvdBase):
            _fields = ("_custom_data", "name", "vrf")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Source Interface."""
            vrf: str | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, vrf: str | None = None) -> None:
                """
                SourceInterfacesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Source Interface.
                    vrf: vrf

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "source_interfaces")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        source_interfaces: list[SourceInterfacesItem] | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, source_interfaces: list[SourceInterfacesItem] | None = None) -> None:
            """
            IpDomainLookup.

            Args:
            -----
                _custom_data: _custom_data
                source_interfaces: source_interfaces

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpExtcommunityListsItem(AvdBase):
        class EntriesItem(AvdBase):
            _fields = ("_custom_data", "type", "extcommunities")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            type: Annotated[str, ValidValues["permit", "deny"]] = None
            extcommunities: str = None
            """
            Communities as string.
            Example: "65000:65000"
            """

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, type: Annotated[str, ValidValues["permit", "deny"]] = None, extcommunities: str = None
            ) -> None:
                """
                EntriesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    type: type
                    extcommunities:
                       Communities as string.
                       Example: "65000:65000"

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "name", "entries")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Community-list Name."""
        entries: list[EntriesItem] = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, entries: list[EntriesItem] = None) -> None:
            """
            IpExtcommunityListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Community-list Name.
                entries: entries

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpExtcommunityListsRegexpItem(AvdBase):
        class EntriesItem(AvdBase):
            _fields = ("_custom_data", "type", "regexp")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            type: Annotated[str, ValidValues["permit", "deny"]] = None
            regexp: str = None
            """Regular Expression."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, type: Annotated[str, ValidValues["permit", "deny"]] = None, regexp: str = None
            ) -> None:
                """
                EntriesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    type: type
                    regexp: Regular Expression.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "name", "entries")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Community-list Name."""
        entries: list[EntriesItem] = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, entries: list[EntriesItem] = None) -> None:
            """
            IpExtcommunityListsRegexpItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Community-list Name.
                entries: entries

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpFtpClientSourceInterfacesItem(AvdBase):
        _fields = ("_custom_data", "name", "vrf")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Interface Name."""
        vrf: str | None = None
        """VRF Name."""

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, vrf: str | None = None) -> None:
            """
            IpFtpClientSourceInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Interface Name.
                vrf: VRF Name.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpHardware(AvdBase):
        class Fib(AvdBase):
            class Optimize(AvdBase):
                class Prefixes(AvdBase):
                    _fields = ("_custom_data", "profile")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    profile: Annotated[str, ValidValues["internet", "urpf-internet"]] | None = None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, profile: Annotated[str, ValidValues["internet", "urpf-internet"]] | None = None
                    ) -> None:
                        """
                        Prefixes.

                        Args:
                        -----
                            _custom_data: _custom_data
                            profile: profile

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "prefixes")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                prefixes: Prefixes | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, prefixes: Prefixes | None = None) -> None:
                    """
                    Optimize.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefixes: prefixes

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "optimize")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            optimize: Optimize | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, optimize: Optimize | None = None) -> None:
                """
                Fib.

                Args:
                -----
                    _custom_data: _custom_data
                    optimize: optimize

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "fib")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        fib: Fib | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, fib: Fib | None = None) -> None:
            """
            IpHardware.

            Args:
            -----
                _custom_data: _custom_data
                fib: fib

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpHttpClientSourceInterfacesItem(AvdBase):
        _fields = ("_custom_data", "name", "vrf")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str | None = None
        """Interface Name."""
        vrf: str | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, vrf: str | None = None) -> None:
            """
            IpHttpClientSourceInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Interface Name.
                vrf: vrf

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpIgmpSnooping(AvdBase):
        class Querier(AvdBase):
            _fields = (
                "_custom_data",
                "enabled",
                "address",
                "query_interval",
                "max_response_time",
                "last_member_query_interval",
                "last_member_query_count",
                "startup_query_interval",
                "startup_query_count",
                "version",
            )
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool | None = None
            address: str | None = None
            """IP Address."""
            query_interval: int | None = None
            max_response_time: int | None = None
            last_member_query_interval: int | None = None
            last_member_query_count: int | None = None
            startup_query_interval: int | None = None
            startup_query_count: int | None = None
            version: int | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enabled: bool | None = None,
                address: str | None = None,
                query_interval: int | None = None,
                max_response_time: int | None = None,
                last_member_query_interval: int | None = None,
                last_member_query_count: int | None = None,
                startup_query_interval: int | None = None,
                startup_query_count: int | None = None,
                version: int | None = None,
            ) -> None:
                """
                Querier.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    address: IP Address.
                    query_interval: query_interval
                    max_response_time: max_response_time
                    last_member_query_interval: last_member_query_interval
                    last_member_query_count: last_member_query_count
                    startup_query_interval: startup_query_interval
                    startup_query_count: startup_query_count
                    version: version

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VlansItem(AvdBase):
            class Querier(AvdBase):
                _fields = (
                    "_custom_data",
                    "enabled",
                    "address",
                    "query_interval",
                    "max_response_time",
                    "last_member_query_interval",
                    "last_member_query_count",
                    "startup_query_interval",
                    "startup_query_count",
                    "version",
                )
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                address: str | None = None
                """IP Address."""
                query_interval: int | None = None
                max_response_time: int | None = None
                last_member_query_interval: int | None = None
                last_member_query_count: int | None = None
                startup_query_interval: int | None = None
                startup_query_count: int | None = None
                version: int | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    enabled: bool | None = None,
                    address: str | None = None,
                    query_interval: int | None = None,
                    max_response_time: int | None = None,
                    last_member_query_interval: int | None = None,
                    last_member_query_count: int | None = None,
                    startup_query_interval: int | None = None,
                    startup_query_count: int | None = None,
                    version: int | None = None,
                ) -> None:
                    """
                    Querier.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        address: IP Address.
                        query_interval: query_interval
                        max_response_time: max_response_time
                        last_member_query_interval: last_member_query_interval
                        last_member_query_count: last_member_query_count
                        startup_query_interval: startup_query_interval
                        startup_query_count: startup_query_count
                        version: version

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "id", "enabled", "querier", "max_groups", "fast_leave", "proxy")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            id: int = None
            """VLAN ID."""
            enabled: bool | None = None
            querier: Querier | None = None
            max_groups: int | None = None
            fast_leave: bool | None = None
            proxy: bool | None = None
            """Global proxy settings should be enabled before enabling per-vlan."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                id: int = None,
                enabled: bool | None = None,
                querier: Querier | None = None,
                max_groups: int | None = None,
                fast_leave: bool | None = None,
                proxy: bool | None = None,
            ) -> None:
                """
                VlansItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: VLAN ID.
                    enabled: enabled
                    querier: querier
                    max_groups: max_groups
                    fast_leave: fast_leave
                    proxy: Global proxy settings should be enabled before enabling per-vlan.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "globally_enabled",
            "robustness_variable",
            "restart_query_interval",
            "interface_restart_query",
            "fast_leave",
            "querier",
            "proxy",
            "vlans",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        globally_enabled: bool | None = True
        """
        Activate or deactivate IGMP snooping for all vlans where `vlans` allows user to activate /
        deactivate IGMP snooping per vlan.
        """
        robustness_variable: int | None = None
        restart_query_interval: int | None = None
        interface_restart_query: int | None = None
        fast_leave: bool | None = None
        querier: Querier | None = None
        proxy: bool | None = None
        vlans: list[VlansItem] | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            globally_enabled: bool | None = True,
            robustness_variable: int | None = None,
            restart_query_interval: int | None = None,
            interface_restart_query: int | None = None,
            fast_leave: bool | None = None,
            querier: Querier | None = None,
            proxy: bool | None = None,
            vlans: list[VlansItem] | None = None,
        ) -> None:
            """
            IpIgmpSnooping.

            Args:
            -----
                _custom_data: _custom_data
                globally_enabled:
                   Activate or deactivate IGMP snooping for all vlans where `vlans` allows user to activate /
                   deactivate IGMP snooping per vlan.
                robustness_variable: robustness_variable
                restart_query_interval: restart_query_interval
                interface_restart_query: interface_restart_query
                fast_leave: fast_leave
                querier: querier
                proxy: proxy
                vlans: vlans

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpNameServersItem(AvdBase):
        _fields = ("_custom_data", "ip_address", "vrf", "priority")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        ip_address: str | None = None
        """IPv4 or IPv6 address for DNS server."""
        vrf: str | None = None
        """VRF Name."""
        priority: Annotated[int, Max[4]] | None = None
        """Priority value (lower is first)."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            ip_address: str | None = None,
            vrf: str | None = None,
            priority: Annotated[int, Max[4]] | None = None,
        ) -> None:
            """
            IpNameServersItem.

            Args:
            -----
                _custom_data: _custom_data
                ip_address: IPv4 or IPv6 address for DNS server.
                vrf: VRF Name.
                priority: Priority value (lower is first).

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpNat(AvdBase):
        class ProfilesItem(AvdBase):
            class Destination(AvdBase):
                class DynamicItem(AvdBase):
                    _fields = ("_custom_data", "access_list", "comment", "pool_name", "priority")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    access_list: str = None
                    comment: str | None = None
                    pool_name: str = None
                    priority: Annotated[int, Max[4294967295]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        access_list: str = None,
                        comment: str | None = None,
                        pool_name: str = None,
                        priority: Annotated[int, Max[4294967295]] | None = None,
                    ) -> None:
                        """
                        DynamicItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: access_list
                            comment: comment
                            pool_name: pool_name
                            priority: priority

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class StaticItem(AvdBase):
                    _fields = (
                        "_custom_data",
                        "access_list",
                        "comment",
                        "direction",
                        "group",
                        "original_ip",
                        "original_port",
                        "priority",
                        "protocol",
                        "translated_ip",
                        "translated_port",
                    )
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    access_list: str | None = None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None = None
                    direction: Annotated[str, ValidValues["egress", "ingress"]] | None = None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: Annotated[int, Min[1], Max[65535]] | None = None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None = None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: Annotated[int, Min[1], Max[65535]] | None = None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: Annotated[int, Max[4294967295]] | None = None
                    protocol: Annotated[str, ValidValues["udp", "tcp"]] | None = None
                    translated_ip: str = None
                    """IPv4 address."""
                    translated_port: Annotated[int, Min[1], Max[65535]] | None = None
                    """requires 'original_port'."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        access_list: str | None = None,
                        comment: str | None = None,
                        direction: Annotated[str, ValidValues["egress", "ingress"]] | None = None,
                        group: Annotated[int, Min[1], Max[65535]] | None = None,
                        original_ip: str | None = None,
                        original_port: Annotated[int, Min[1], Max[65535]] | None = None,
                        priority: Annotated[int, Max[4294967295]] | None = None,
                        protocol: Annotated[str, ValidValues["udp", "tcp"]] | None = None,
                        translated_ip: str = None,
                        translated_port: Annotated[int, Min[1], Max[65535]] | None = None,
                    ) -> None:
                        """
                        StaticItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: 'access_list' and 'group' are mutual exclusive.
                            comment: comment
                            direction:
                               Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                               platform.
                               EOS might remove this keyword in the configuration. So, check the configuration on
                               targeted HW/SW.
                            group: 'access_list' and 'group' are mutual exclusive.
                            original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                            original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                            priority: priority
                            protocol: protocol
                            translated_ip: IPv4 address.
                            translated_port: requires 'original_port'.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "dynamic", "static")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                dynamic: list[DynamicItem] | None = None
                static: list[StaticItem] | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, dynamic: list[DynamicItem] | None = None, static: list[StaticItem] | None = None
                ) -> None:
                    """
                    Destination.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dynamic: dynamic
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Source(AvdBase):
                class DynamicItem(AvdBase):
                    _fields = ("_custom_data", "access_list", "comment", "nat_type", "pool_name", "priority")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    access_list: str = None
                    comment: str | None = None
                    nat_type: Annotated[str, ValidValues["overload", "pool", "pool-address-only", "pool-full-cone"]] = None
                    pool_name: str | None = None
                    """
                    required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                    ignored if 'nat_type' is
                    overload.
                    """
                    priority: Annotated[int, Max[4294967295]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        access_list: str = None,
                        comment: str | None = None,
                        nat_type: Annotated[str, ValidValues["overload", "pool", "pool-address-only", "pool-full-cone"]] = None,
                        pool_name: str | None = None,
                        priority: Annotated[int, Max[4294967295]] | None = None,
                    ) -> None:
                        """
                        DynamicItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: access_list
                            comment: comment
                            nat_type: nat_type
                            pool_name:
                               required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                               ignored if 'nat_type' is
                               overload.
                            priority: priority

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class StaticItem(AvdBase):
                    _fields = (
                        "_custom_data",
                        "access_list",
                        "comment",
                        "direction",
                        "group",
                        "original_ip",
                        "original_port",
                        "priority",
                        "protocol",
                        "translated_ip",
                        "translated_port",
                    )
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    access_list: str | None = None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None = None
                    direction: Annotated[str, ValidValues["egress", "ingress"]] | None = None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: Annotated[int, Min[1], Max[65535]] | None = None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None = None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: Annotated[int, Min[1], Max[65535]] | None = None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: Annotated[int, Max[4294967295]] | None = None
                    protocol: Annotated[str, ValidValues["udp", "tcp"]] | None = None
                    translated_ip: str = None
                    """IPv4 address."""
                    translated_port: Annotated[int, Min[1], Max[65535]] | None = None
                    """requires 'original_port'."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        access_list: str | None = None,
                        comment: str | None = None,
                        direction: Annotated[str, ValidValues["egress", "ingress"]] | None = None,
                        group: Annotated[int, Min[1], Max[65535]] | None = None,
                        original_ip: str | None = None,
                        original_port: Annotated[int, Min[1], Max[65535]] | None = None,
                        priority: Annotated[int, Max[4294967295]] | None = None,
                        protocol: Annotated[str, ValidValues["udp", "tcp"]] | None = None,
                        translated_ip: str = None,
                        translated_port: Annotated[int, Min[1], Max[65535]] | None = None,
                    ) -> None:
                        """
                        StaticItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: 'access_list' and 'group' are mutual exclusive.
                            comment: comment
                            direction:
                               Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                               platform.
                               EOS might remove this keyword in the configuration. So, check the configuration on
                               targeted HW/SW.
                            group: 'access_list' and 'group' are mutual exclusive.
                            original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                            original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                            priority: priority
                            protocol: protocol
                            translated_ip: IPv4 address.
                            translated_port: requires 'original_port'.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "dynamic", "static")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                dynamic: list[DynamicItem] | None = None
                static: list[StaticItem] | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, dynamic: list[DynamicItem] | None = None, static: list[StaticItem] | None = None
                ) -> None:
                    """
                    Source.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dynamic: dynamic
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "vrf", "destination", "source")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            vrf: str | None = None
            """Specify VRF for NAT profile."""
            destination: Destination | None = None
            source: Source | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                vrf: str | None = None,
                destination: Destination | None = None,
                source: Source | None = None,
            ) -> None:
                """
                ProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    vrf: Specify VRF for NAT profile.
                    destination: destination
                    source: source

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PoolsItem(AvdBase):
            class RangesItem(AvdBase):
                _fields = ("_custom_data", "first_ip", "last_ip", "first_port", "last_port")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                first_ip: str | None = None
                """
                IPv4 address.
                Required when `type` is `ip-port` and ignored otherwise.
                """
                last_ip: str | None = None
                """
                IPv4 address.
                Required when `type` is `ip-port` and ignored otherwise.
                `first_ip` and `last_ip` ip
                addresses should lie in same subnet.
                """
                first_port: Annotated[int, Min[1], Max[65535]] | None = None
                last_port: Annotated[int, Min[1], Max[65535]] | None = None
                """
                Required when `first_port` is set.
                `last_port` must be greater than or equal to `first_port`.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    first_ip: str | None = None,
                    last_ip: str | None = None,
                    first_port: Annotated[int, Min[1], Max[65535]] | None = None,
                    last_port: Annotated[int, Min[1], Max[65535]] | None = None,
                ) -> None:
                    """
                    RangesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        first_ip:
                           IPv4 address.
                           Required when `type` is `ip-port` and ignored otherwise.
                        last_ip:
                           IPv4 address.
                           Required when `type` is `ip-port` and ignored otherwise.
                           `first_ip` and `last_ip` ip
                           addresses should lie in same subnet.
                        first_port: first_port
                        last_port:
                           Required when `first_port` is set.
                           `last_port` must be greater than or equal to `first_port`.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "type", "prefix_length", "ranges", "utilization_log_threshold")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            type: Annotated[str, ValidValues["ip-port", "port-only"]] | None = "ip-port"
            prefix_length: Annotated[int, Min[16], Max[32]] | None = None
            """It is only used and required when `type` is `ip-port`."""
            ranges: list[RangesItem] | None = None
            utilization_log_threshold: Annotated[int, Min[1], Max[100]] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                type: Annotated[str, ValidValues["ip-port", "port-only"]] | None = "ip-port",
                prefix_length: Annotated[int, Min[16], Max[32]] | None = None,
                ranges: list[RangesItem] | None = None,
                utilization_log_threshold: Annotated[int, Min[1], Max[100]] | None = None,
            ) -> None:
                """
                PoolsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    type: type
                    prefix_length: It is only used and required when `type` is `ip-port`.
                    ranges: ranges
                    utilization_log_threshold: utilization_log_threshold

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Synchronization(AvdBase):
            class PortRange(AvdBase):
                _fields = ("_custom_data", "first_port", "last_port", "split_disabled")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                first_port: Annotated[int, Min[1024], Max[65535]] | None = None
                last_port: Annotated[int, Min[1024], Max[65535]] | None = None
                """>= first_port."""
                split_disabled: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    first_port: Annotated[int, Min[1024], Max[65535]] | None = None,
                    last_port: Annotated[int, Min[1024], Max[65535]] | None = None,
                    split_disabled: bool | None = None,
                ) -> None:
                    """
                    PortRange.

                    Args:
                    -----
                        _custom_data: _custom_data
                        first_port: first_port
                        last_port: >= first_port.
                        split_disabled: split_disabled

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "description", "expiry_interval", "local_interface", "peer_address", "port_range", "shutdown")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            description: str | None = None
            expiry_interval: Annotated[int, Min[60], Max[3600]] | None = None
            """In seconds."""
            local_interface: str | None = None
            """EOS interface name."""
            peer_address: str | None = None
            """IPv4 address."""
            port_range: PortRange | None = None
            shutdown: bool | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                description: str | None = None,
                expiry_interval: Annotated[int, Min[60], Max[3600]] | None = None,
                local_interface: str | None = None,
                peer_address: str | None = None,
                port_range: PortRange | None = None,
                shutdown: bool | None = None,
            ) -> None:
                """
                Synchronization.

                Args:
                -----
                    _custom_data: _custom_data
                    description: description
                    expiry_interval: In seconds.
                    local_interface: EOS interface name.
                    peer_address: IPv4 address.
                    port_range: port_range
                    shutdown: shutdown

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Translation(AvdBase):
            class AddressSelection(AvdBase):
                _fields = ("_custom_data", "any", "hash_field_source_ip")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                any: bool | None = None
                hash_field_source_ip: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, any: bool | None = None, hash_field_source_ip: bool | None = None) -> None:
                    """
                    AddressSelection.

                    Args:
                    -----
                        _custom_data: _custom_data
                        any: any
                        hash_field_source_ip: hash_field_source_ip

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class LowMark(AvdBase):
                _fields = ("_custom_data", "percentage", "host_percentage")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                percentage: Annotated[int, Min[1], Max[99]] | None = None
                """Used to render 'ip nat translation low-mark <percentage>'."""
                host_percentage: Annotated[int, Min[1], Max[99]] | None = None
                """Used to render 'ip nat translation low-mark <host_percentage> host'."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    percentage: Annotated[int, Min[1], Max[99]] | None = None,
                    host_percentage: Annotated[int, Min[1], Max[99]] | None = None,
                ) -> None:
                    """
                    LowMark.

                    Args:
                    -----
                        _custom_data: _custom_data
                        percentage: Used to render 'ip nat translation low-mark <percentage>'.
                        host_percentage: Used to render 'ip nat translation low-mark <host_percentage> host'.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class MaxEntries(AvdBase):
                class IpLimitsItem(AvdBase):
                    _fields = ("_custom_data", "ip", "limit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    ip: str = None
                    """IPv4 address."""
                    limit: Annotated[int, Max[4294967295]] = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, ip: str = None, limit: Annotated[int, Max[4294967295]] = None) -> None:
                        """
                        IpLimitsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            ip: IPv4 address.
                            limit: limit

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "limit", "host_limit", "ip_limits")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                limit: Annotated[int, Max[4294967295]] | None = None
                host_limit: Annotated[int, Max[4294967295]] | None = None
                ip_limits: list[IpLimitsItem] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    limit: Annotated[int, Max[4294967295]] | None = None,
                    host_limit: Annotated[int, Max[4294967295]] | None = None,
                    ip_limits: list[IpLimitsItem] | None = None,
                ) -> None:
                    """
                    MaxEntries.

                    Args:
                    -----
                        _custom_data: _custom_data
                        limit: limit
                        host_limit: host_limit
                        ip_limits: ip_limits

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class TimeoutsItem(AvdBase):
                _fields = ("_custom_data", "protocol", "timeout")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                protocol: Annotated[str, ValidValues["tcp", "udp"]] = None
                timeout: Annotated[int, Max[4294967295]] = None
                """In seconds."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    protocol: Annotated[str, ValidValues["tcp", "udp"]] = None,
                    timeout: Annotated[int, Max[4294967295]] = None,
                ) -> None:
                    """
                    TimeoutsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        protocol: protocol
                        timeout: In seconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "address_selection", "counters", "low_mark", "max_entries", "timeouts")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            address_selection: AddressSelection | None = None
            counters: bool | None = None
            low_mark: LowMark | None = None
            max_entries: MaxEntries | None = None
            timeouts: list[TimeoutsItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                address_selection: AddressSelection | None = None,
                counters: bool | None = None,
                low_mark: LowMark | None = None,
                max_entries: MaxEntries | None = None,
                timeouts: list[TimeoutsItem] | None = None,
            ) -> None:
                """
                Translation.

                Args:
                -----
                    _custom_data: _custom_data
                    address_selection: address_selection
                    counters: counters
                    low_mark: low_mark
                    max_entries: max_entries
                    timeouts: timeouts

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "kernel_buffer_size", "profiles", "pools", "synchronization", "translation")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        kernel_buffer_size: Annotated[int, Min[1], Max[64]] | None = None
        """Buffer size in MB."""
        profiles: list[ProfilesItem] | None = None
        pools: list[PoolsItem] | None = None
        synchronization: Synchronization | None = None
        translation: Translation | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            kernel_buffer_size: Annotated[int, Min[1], Max[64]] | None = None,
            profiles: list[ProfilesItem] | None = None,
            pools: list[PoolsItem] | None = None,
            synchronization: Synchronization | None = None,
            translation: Translation | None = None,
        ) -> None:
            """
            IpNat.

            Args:
            -----
                _custom_data: _custom_data
                kernel_buffer_size: Buffer size in MB.
                profiles: profiles
                pools: pools
                synchronization: synchronization
                translation: translation

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpRadiusSourceInterfacesItem(AvdBase):
        _fields = ("_custom_data", "name", "vrf")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str | None = None
        """Interface Name."""
        vrf: str | None = None
        """VRF Name."""

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, vrf: str | None = None) -> None:
            """
            IpRadiusSourceInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Interface Name.
                vrf: VRF Name.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpSecurity(AvdBase):
        class IkePoliciesItem(AvdBase):
            _fields = ("_custom_data", "name", "local_id", "local_id_fqdn", "ike_lifetime", "encryption", "dh_group")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Policy name."""
            local_id: str | None = None
            """
            Local IKE identification.
            Can be an IPv4 or an IPv6 address.
            If both `local_id` and `local_id_fqdn`
            are set, `local_id_fqdn` takes precedence.
            """
            local_id_fqdn: str | None = None
            """
            Local FQDN or UFQDN IKE identification.
            If both `local_id` and `local_id_fqdn` are set,
            `local_id_fqdn` takes precedence.
            """
            ike_lifetime: Annotated[int, Min[1], Max[24]] | None = None
            """IKE lifetime in hours."""
            encryption: Annotated[str, ValidValues["3des", "aes128", "aes256"]] | None = None
            """IKE encryption algorithm."""
            dh_group: Annotated[int, ValidValues[1, 2, 5, 14, 15, 16, 17, 20, 21, 24]] | None = None
            """Diffie-Hellman group for the key exchange."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                local_id: str | None = None,
                local_id_fqdn: str | None = None,
                ike_lifetime: Annotated[int, Min[1], Max[24]] | None = None,
                encryption: Annotated[str, ValidValues["3des", "aes128", "aes256"]] | None = None,
                dh_group: Annotated[int, ValidValues[1, 2, 5, 14, 15, 16, 17, 20, 21, 24]] | None = None,
            ) -> None:
                """
                IkePoliciesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Policy name.
                    local_id:
                       Local IKE identification.
                       Can be an IPv4 or an IPv6 address.
                       If both `local_id` and `local_id_fqdn`
                       are set, `local_id_fqdn` takes precedence.
                    local_id_fqdn:
                       Local FQDN or UFQDN IKE identification.
                       If both `local_id` and `local_id_fqdn` are set,
                       `local_id_fqdn` takes precedence.
                    ike_lifetime: IKE lifetime in hours.
                    encryption: IKE encryption algorithm.
                    dh_group: Diffie-Hellman group for the key exchange.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SaPoliciesItem(AvdBase):
            class SaLifetime(AvdBase):
                _fields = ("_custom_data", "value", "unit")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                value: int | None = None
                """
                Lifetime value for this SA.
                Valid range depends on the unit.
                <1-24>       Lifetime in hours (
                default )
                <1-4000000>  Packet limit in thousands
                <1-6000>     Byte limit in GB ( 1024 MB )
                <1-6144000>  Byte limit in MB ( 1024 KB )
                """
                unit: Annotated[str, ValidValues["gigabytes", "hours", "megabytes", "thousand-packets"]] | None = "hours"

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    value: int | None = None,
                    unit: Annotated[str, ValidValues["gigabytes", "hours", "megabytes", "thousand-packets"]] | None = "hours",
                ) -> None:
                    """
                    SaLifetime.

                    Args:
                    -----
                        _custom_data: _custom_data
                        value:
                           Lifetime value for this SA.
                           Valid range depends on the unit.
                           <1-24>       Lifetime in hours (
                           default )
                           <1-4000000>  Packet limit in thousands
                           <1-6000>     Byte limit in GB ( 1024 MB )
                           <1-6144000>  Byte limit in MB ( 1024 KB )
                        unit: unit

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Esp(AvdBase):
                _fields = ("_custom_data", "integrity", "encryption")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                integrity: Annotated[str, ValidValues["disabled", "sha1", "sha256", "sha384", "sha512", "md5"]] | None = None
                encryption: Annotated[str, ValidValues["disabled", "aes128", "aes128gcm128", "aes128gcm64", "aes256", "aes256gcm128", "3des"]] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    integrity: Annotated[str, ValidValues["disabled", "sha1", "sha256", "sha384", "sha512", "md5"]] | None = None,
                    encryption: Annotated[str, ValidValues["disabled", "aes128", "aes128gcm128", "aes128gcm64", "aes256", "aes256gcm128", "3des"]]
                    | None = None,
                ) -> None:
                    """
                    Esp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        integrity: integrity
                        encryption: encryption

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "sa_lifetime", "esp", "pfs_dh_group")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Name of the SA policy."""
            sa_lifetime: SaLifetime | None = None
            esp: Esp | None = None
            pfs_dh_group: Annotated[int, ValidValues[1, 2, 5, 14, 15, 16, 17, 20, 21, 24]] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                sa_lifetime: SaLifetime | None = None,
                esp: Esp | None = None,
                pfs_dh_group: Annotated[int, ValidValues[1, 2, 5, 14, 15, 16, 17, 20, 21, 24]] | None = None,
            ) -> None:
                """
                SaPoliciesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Name of the SA policy.
                    sa_lifetime: sa_lifetime
                    esp: esp
                    pfs_dh_group: pfs_dh_group

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ProfilesItem(AvdBase):
            class Dpd(AvdBase):
                _fields = ("_custom_data", "interval", "time", "action")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                interval: Annotated[int, Min[2], Max[3600]] = None
                """Interval (in seconds) between keep-alive messages."""
                time: Annotated[int, Min[10], Max[3600]] = None
                """Time (in seconds) after which the action is applied."""
                action: Annotated[str, ValidValues["clear", "hold", "restart"]] = None
                """
                Action to apply.

                * 'clear': Delete all connections
                * 'hold': Re-negotiate connection on demand
                *
                'restart': Restart connection immediately
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    interval: Annotated[int, Min[2], Max[3600]] = None,
                    time: Annotated[int, Min[10], Max[3600]] = None,
                    action: Annotated[str, ValidValues["clear", "hold", "restart"]] = None,
                ) -> None:
                    """
                    Dpd.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interval: Interval (in seconds) between keep-alive messages.
                        time: Time (in seconds) after which the action is applied.
                        action:
                           Action to apply.

                           * 'clear': Delete all connections
                           * 'hold': Re-negotiate connection on demand
                           *
                           'restart': Restart connection immediately

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "ike_policy", "sa_policy", "connection", "shared_key", "dpd", "mode", "flow_parallelization_encapsulation_udp")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Name of the IPsec profile."""
            ike_policy: str | None = None
            """Name of the IKE policy to use in this profile."""
            sa_policy: str | None = None
            """Name of the Security Association to use in this profile."""
            connection: Annotated[str, ValidValues["add", "start", "route"]] | None = None
            """IPsec connection (Initiator/Responder/Dynamic)."""
            shared_key: str | None = None
            """Encrypted password - only type 7 supported."""
            dpd: Dpd | None = None
            """Dead Peer Detection."""
            mode: Annotated[str, ValidValues["transport", "tunnel"]] | None = None
            """Ipsec mode type."""
            flow_parallelization_encapsulation_udp: bool | None = None
            """
            Enable flow parallelization.
            When enabled, multiple cores are used to parallelize the IPsec
            encryption and decryption processing.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                ike_policy: str | None = None,
                sa_policy: str | None = None,
                connection: Annotated[str, ValidValues["add", "start", "route"]] | None = None,
                shared_key: str | None = None,
                dpd: Dpd | None = None,
                mode: Annotated[str, ValidValues["transport", "tunnel"]] | None = None,
                flow_parallelization_encapsulation_udp: bool | None = None,
            ) -> None:
                """
                ProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Name of the IPsec profile.
                    ike_policy: Name of the IKE policy to use in this profile.
                    sa_policy: Name of the Security Association to use in this profile.
                    connection: IPsec connection (Initiator/Responder/Dynamic).
                    shared_key: Encrypted password - only type 7 supported.
                    dpd: Dead Peer Detection.
                    mode: Ipsec mode type.
                    flow_parallelization_encapsulation_udp:
                       Enable flow parallelization.
                       When enabled, multiple cores are used to parallelize the IPsec
                       encryption and decryption processing.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class KeyController(AvdBase):
            _fields = ("_custom_data", "profile")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            profile: str | None = None
            """IPsec profile name to use."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, profile: str | None = None) -> None:
                """
                KeyController.

                Args:
                -----
                    _custom_data: _custom_data
                    profile: IPsec profile name to use.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "ike_policies", "sa_policies", "profiles", "key_controller", "hardware_encryption_disabled")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        ike_policies: list[IkePoliciesItem] | None = None
        """Internet Security Association and Key Mgmt Protocol."""
        sa_policies: list[SaPoliciesItem] | None = None
        """Security Association policies."""
        profiles: list[ProfilesItem] | None = None
        """IPSec profiles."""
        key_controller: KeyController | None = None
        hardware_encryption_disabled: bool | None = False
        """
        Disable hardware encryption.
        An SFE restart is needed for this change to take effect.
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            ike_policies: list[IkePoliciesItem] | None = None,
            sa_policies: list[SaPoliciesItem] | None = None,
            profiles: list[ProfilesItem] | None = None,
            key_controller: KeyController | None = None,
            hardware_encryption_disabled: bool | None = False,
        ) -> None:
            """
            IpSecurity.

            Args:
            -----
                _custom_data: _custom_data
                ike_policies: Internet Security Association and Key Mgmt Protocol.
                sa_policies: Security Association policies.
                profiles: IPSec profiles.
                key_controller: key_controller
                hardware_encryption_disabled:
                   Disable hardware encryption.
                   An SFE restart is needed for this change to take effect.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpSshClientSourceInterfacesItem(AvdBase):
        _fields = ("_custom_data", "name", "vrf")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str | None = None
        """Interface Name."""
        vrf: str | None = "default"

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, vrf: str | None = "default") -> None:
            """
            IpSshClientSourceInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Interface Name.
                vrf: vrf

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpTacacsSourceInterfacesItem(AvdBase):
        _fields = ("_custom_data", "name", "vrf")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str | None = None
        """Interface name."""
        vrf: str | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, vrf: str | None = None) -> None:
            """
            IpTacacsSourceInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Interface name.
                vrf: vrf

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpTelnetClientSourceInterfacesItem(AvdBase):
        _fields = ("_custom_data", "name", "vrf")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Interface Name."""
        vrf: str | None = None
        """VRF Name."""

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, vrf: str | None = None) -> None:
            """
            IpTelnetClientSourceInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Interface Name.
                vrf: VRF Name.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpTftpClientSourceInterfacesItem(AvdBase):
        _fields = ("_custom_data", "name", "vrf")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Interface Name."""
        vrf: str | None = None
        """VRF Name."""

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, vrf: str | None = None) -> None:
            """
            IpTftpClientSourceInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Interface Name.
                vrf: VRF Name.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Ipv6AccessListsItem(AvdBase):
        class SequenceNumbersItem(AvdBase):
            _fields = ("_custom_data", "sequence", "action")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            sequence: int = None
            """Sequence ID."""
            action: str = None
            """
            Action as string.
            Example: "deny ipv6 any any"
            """

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, sequence: int = None, action: str = None) -> None:
                """
                SequenceNumbersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: Sequence ID.
                    action:
                       Action as string.
                       Example: "deny ipv6 any any"

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "name", "counters_per_entry", "sequence_numbers")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """IPv6 Access-list Name."""
        counters_per_entry: bool | None = None
        sequence_numbers: list[SequenceNumbersItem] = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str = None,
            counters_per_entry: bool | None = None,
            sequence_numbers: list[SequenceNumbersItem] = None,
        ) -> None:
            """
            Ipv6AccessListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: IPv6 Access-list Name.
                counters_per_entry: counters_per_entry
                sequence_numbers: sequence_numbers

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Ipv6DhcpRelay(AvdBase):
        class Option(AvdBase):
            _fields = ("_custom_data", "link_layer_address", "remote_id_format")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            link_layer_address: bool | None = None
            """Add Option 79 (Link Layer Address Option)."""
            remote_id_format: Annotated[str, ValidValues["%m:%i", "%m:%p"]] | None = None
            """
            Add RemoteID option 37 in format MAC address and interface ID (`%m:%i`) or MAC address and interface
            name (`%m:%p`).
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                link_layer_address: bool | None = None,
                remote_id_format: Annotated[str, ValidValues["%m:%i", "%m:%p"]] | None = None,
            ) -> None:
                """
                Option.

                Args:
                -----
                    _custom_data: _custom_data
                    link_layer_address: Add Option 79 (Link Layer Address Option).
                    remote_id_format:
                       Add RemoteID option 37 in format MAC address and interface ID (`%m:%i`) or MAC address and interface
                       name (`%m:%p`).

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "always_on", "all_subnets", "option")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        always_on: bool | None = None
        """DhcpRelay Agent will be in always-on mode, off by default."""
        all_subnets: bool | None = None
        """Allow forwarding requests with additional IPv6 addresses in the gateway address "giaddr" field."""
        option: Option | None = None
        """Insert DHCP Option."""

        def __init__(
            self, *, _custom_data: dict[str, Any] | None = None, always_on: bool | None = None, all_subnets: bool | None = None, option: Option | None = None
        ) -> None:
            """
            Ipv6DhcpRelay.

            Args:
            -----
                _custom_data: _custom_data
                always_on: DhcpRelay Agent will be in always-on mode, off by default.
                all_subnets: Allow forwarding requests with additional IPv6 addresses in the gateway address "giaddr" field.
                option: Insert DHCP Option.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Ipv6Hardware(AvdBase):
        class Fib(AvdBase):
            class Optimize(AvdBase):
                class Prefixes(AvdBase):
                    _fields = ("_custom_data", "profile")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    profile: str | None = None
                    """Pre-defined profile 'internet' or user-defined profile name."""

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, profile: str | None = None) -> None:
                        """
                        Prefixes.

                        Args:
                        -----
                            _custom_data: _custom_data
                            profile: Pre-defined profile 'internet' or user-defined profile name.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "prefixes")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                prefixes: Prefixes | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, prefixes: Prefixes | None = None) -> None:
                    """
                    Optimize.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefixes: prefixes

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "optimize")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            optimize: Optimize | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, optimize: Optimize | None = None) -> None:
                """
                Fib.

                Args:
                -----
                    _custom_data: _custom_data
                    optimize: optimize

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "fib")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        fib: Fib | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, fib: Fib | None = None) -> None:
            """
            Ipv6Hardware.

            Args:
            -----
                _custom_data: _custom_data
                fib: fib

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Ipv6Neighbor(AvdBase):
        class StaticEntriesItem(AvdBase):
            _fields = ("_custom_data", "ipv6_address", "vrf", "interface", "mac_address")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv6_address: str = None
            """IPv6 address of neighbor."""
            vrf: str | None = None
            interface: str = None
            """Interface name."""
            mac_address: Annotated[str, Pattern[r"^([0-9a-f]{2}:){5}[0-9a-f]{2}$"]] = None
            """MAC address of neighbor like 'aa:af:12:34:bc:bf'"""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                ipv6_address: str = None,
                vrf: str | None = None,
                interface: str = None,
                mac_address: Annotated[str, Pattern[r"^([0-9a-f]{2}:){5}[0-9a-f]{2}$"]] = None,
            ) -> None:
                """
                StaticEntriesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv6_address: IPv6 address of neighbor.
                    vrf: vrf
                    interface: Interface name.
                    mac_address: MAC address of neighbor like 'aa:af:12:34:bc:bf'

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Persistent(AvdBase):
            _fields = ("_custom_data", "enabled", "refresh_delay")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool = None
            """Restore the IPv6 neighbor cache after reboot."""
            refresh_delay: Annotated[int, Min[600], Max[3600]] | None = None
            """
            Time to wait in seconds before refreshing the IPv6 neighbor cache after reboot (EOS default 600).
            It
            will require setting the `enabled` key to true.
            """

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, refresh_delay: Annotated[int, Min[600], Max[3600]] | None = None
            ) -> None:
                """
                Persistent.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: Restore the IPv6 neighbor cache after reboot.
                    refresh_delay:
                       Time to wait in seconds before refreshing the IPv6 neighbor cache after reboot (EOS default 600).
                       It
                       will require setting the `enabled` key to true.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "static_entries", "persistent")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        static_entries: list[StaticEntriesItem] | None = None
        """Static IPv6 neighbor entries."""
        persistent: Persistent | None = None

        def __init__(
            self, *, _custom_data: dict[str, Any] | None = None, static_entries: list[StaticEntriesItem] | None = None, persistent: Persistent | None = None
        ) -> None:
            """
            Ipv6Neighbor.

            Args:
            -----
                _custom_data: _custom_data
                static_entries: Static IPv6 neighbor entries.
                persistent: persistent

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Ipv6PrefixListsItem(AvdBase):
        class SequenceNumbersItem(AvdBase):
            _fields = ("_custom_data", "sequence", "action")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            sequence: int = None
            """Sequence ID."""
            action: str = None
            """
            Action as string.
            Example: "permit 1b11:3a00:22b0:0082::/64 eq 128"
            """

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, sequence: int = None, action: str = None) -> None:
                """
                SequenceNumbersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: Sequence ID.
                    action:
                       Action as string.
                       Example: "permit 1b11:3a00:22b0:0082::/64 eq 128"

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "name", "sequence_numbers")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Prefix-list Name."""
        sequence_numbers: list[SequenceNumbersItem] = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, sequence_numbers: list[SequenceNumbersItem] = None) -> None:
            """
            Ipv6PrefixListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Prefix-list Name.
                sequence_numbers: sequence_numbers

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Ipv6StandardAccessListsItem(AvdBase):
        class SequenceNumbersItem(AvdBase):
            _fields = ("_custom_data", "sequence", "action")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            sequence: int = None
            """Sequence ID."""
            action: str = None
            """
            Action as string.
            Example: "deny ipv6 any any"
            """

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, sequence: int = None, action: str = None) -> None:
                """
                SequenceNumbersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: Sequence ID.
                    action:
                       Action as string.
                       Example: "deny ipv6 any any"

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "name", "counters_per_entry", "sequence_numbers")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Access-list Name."""
        counters_per_entry: bool | None = None
        sequence_numbers: list[SequenceNumbersItem] = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str = None,
            counters_per_entry: bool | None = None,
            sequence_numbers: list[SequenceNumbersItem] = None,
        ) -> None:
            """
            Ipv6StandardAccessListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Access-list Name.
                counters_per_entry: counters_per_entry
                sequence_numbers: sequence_numbers

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Ipv6StaticRoutesItem(AvdBase):
        _fields = ("_custom_data", "vrf", "destination_address_prefix", "interface", "gateway", "track_bfd", "distance", "tag", "name", "metric")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        vrf: str | None = None
        destination_address_prefix: str | None = None
        """IPv6 Network/Mask."""
        interface: str | None = None
        gateway: str | None = None
        """IPv6 Address."""
        track_bfd: bool | None = None
        """Track next-hop using BFD."""
        distance: Annotated[int, Min[1], Max[255]] | None = None
        tag: Annotated[int, Max[4294967295]] | None = None
        name: str | None = None
        """Description."""
        metric: Annotated[int, Max[4294967295]] | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            vrf: str | None = None,
            destination_address_prefix: str | None = None,
            interface: str | None = None,
            gateway: str | None = None,
            track_bfd: bool | None = None,
            distance: Annotated[int, Min[1], Max[255]] | None = None,
            tag: Annotated[int, Max[4294967295]] | None = None,
            name: str | None = None,
            metric: Annotated[int, Max[4294967295]] | None = None,
        ) -> None:
            """
            Ipv6StaticRoutesItem.

            Args:
            -----
                _custom_data: _custom_data
                vrf: vrf
                destination_address_prefix: IPv6 Network/Mask.
                interface: interface
                gateway: IPv6 Address.
                track_bfd: Track next-hop using BFD.
                distance: distance
                tag: tag
                name: Description.
                metric: metric

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class L2Protocol(AvdBase):
        class ForwardingProfilesItem(AvdBase):
            class ProtocolsItem(AvdBase):
                _fields = ("_custom_data", "name", "forward", "tagged_forward", "untagged_forward")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: Annotated[str, ValidValues["bfd per-link rfc-7130", "e-lmi", "isis", "lacp", "lldp", "macsec", "pause", "stp"]] = None
                forward: bool | None = None
                tagged_forward: bool | None = None
                untagged_forward: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: Annotated[str, ValidValues["bfd per-link rfc-7130", "e-lmi", "isis", "lacp", "lldp", "macsec", "pause", "stp"]] = None,
                    forward: bool | None = None,
                    tagged_forward: bool | None = None,
                    untagged_forward: bool | None = None,
                ) -> None:
                    """
                    ProtocolsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        forward: forward
                        tagged_forward: tagged_forward
                        untagged_forward: untagged_forward

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "protocols")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            protocols: list[ProtocolsItem] | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, protocols: list[ProtocolsItem] | None = None) -> None:
                """
                ForwardingProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    protocols: protocols

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "forwarding_profiles")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        forwarding_profiles: list[ForwardingProfilesItem] | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, forwarding_profiles: list[ForwardingProfilesItem] | None = None) -> None:
            """
            L2Protocol.

            Args:
            -----
                _custom_data: _custom_data
                forwarding_profiles: forwarding_profiles

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Lacp(AvdBase):
        class PortId(AvdBase):
            class Range(AvdBase):
                _fields = ("_custom_data", "begin", "end")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                begin: int | None = None
                """Minimum LACP port-ID range."""
                end: int | None = None
                """Maximum LACP port-ID range."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, begin: int | None = None, end: int | None = None) -> None:
                    """
                    Range.

                    Args:
                    -----
                        _custom_data: _custom_data
                        begin: Minimum LACP port-ID range.
                        end: Maximum LACP port-ID range.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "range")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            range: Range | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, range: Range | None = None) -> None:
                """
                PortId.

                Args:
                -----
                    _custom_data: _custom_data
                    range: range

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class RateLimit(AvdBase):
            _fields = ("_custom_data", "default")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            default: bool | None = None
            """Enable LACPDU rate limiting by default on all ports."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, default: bool | None = None) -> None:
                """
                RateLimit.

                Args:
                -----
                    _custom_data: _custom_data
                    default: Enable LACPDU rate limiting by default on all ports.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "port_id", "rate_limit", "system_priority")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        port_id: PortId | None = None
        """LACP port-ID range configuration."""
        rate_limit: RateLimit | None = None
        """Set LACPDU rate limit options."""
        system_priority: Annotated[int, Max[65535]] | None = None
        """Set local system LACP priority."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            port_id: PortId | None = None,
            rate_limit: RateLimit | None = None,
            system_priority: Annotated[int, Max[65535]] | None = None,
        ) -> None:
            """
            Lacp.

            Args:
            -----
                _custom_data: _custom_data
                port_id: LACP port-ID range configuration.
                rate_limit: Set LACPDU rate limit options.
                system_priority: Set local system LACP priority.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class LinkTrackingGroupsItem(AvdBase):
        _fields = ("_custom_data", "name", "links_minimum", "recovery_delay")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        links_minimum: Annotated[int, Min[1], Max[100000]] | None = None
        recovery_delay: Annotated[int, Max[3600]] | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str = None,
            links_minimum: Annotated[int, Min[1], Max[100000]] | None = None,
            recovery_delay: Annotated[int, Max[3600]] | None = None,
        ) -> None:
            """
            LinkTrackingGroupsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: name
                links_minimum: links_minimum
                recovery_delay: recovery_delay

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Lldp(AvdBase):
        class TlvsItem(AvdBase):
            _fields = ("_custom_data", "name", "transmit")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: Annotated[
                str,
                ValidValues[
                    "link-aggregation",
                    "management-address",
                    "max-frame-size",
                    "med",
                    "port-description",
                    "port-vlan",
                    "power-via-mdi",
                    "system-capabilities",
                    "system-description",
                    "system-name",
                    "vlan-name",
                ],
            ] = None
            transmit: bool | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: Annotated[
                    str,
                    ValidValues[
                        "link-aggregation",
                        "management-address",
                        "max-frame-size",
                        "med",
                        "port-description",
                        "port-vlan",
                        "power-via-mdi",
                        "system-capabilities",
                        "system-description",
                        "system-name",
                        "vlan-name",
                    ],
                ] = None,
                transmit: bool | None = None,
            ) -> None:
                """
                TlvsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    transmit: transmit

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "timer", "timer_reinitialization", "holdtime", "management_address", "vrf", "receive_packet_tagged_drop", "tlvs", "run")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        timer: int | None = None
        timer_reinitialization: str | None = None
        holdtime: int | None = None
        management_address: str | None = None
        vrf: str | None = None
        receive_packet_tagged_drop: str | None = None
        tlvs: list[TlvsItem] | None = None
        run: bool | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            timer: int | None = None,
            timer_reinitialization: str | None = None,
            holdtime: int | None = None,
            management_address: str | None = None,
            vrf: str | None = None,
            receive_packet_tagged_drop: str | None = None,
            tlvs: list[TlvsItem] | None = None,
            run: bool | None = None,
        ) -> None:
            """
            Lldp.

            Args:
            -----
                _custom_data: _custom_data
                timer: timer
                timer_reinitialization: timer_reinitialization
                holdtime: holdtime
                management_address: management_address
                vrf: vrf
                receive_packet_tagged_drop: receive_packet_tagged_drop
                tlvs: tlvs
                run: run

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class LoadInterval(AvdBase):
        _fields = ("_custom_data", "default")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        default: int | None = None
        """Default load interval in seconds."""

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, default: int | None = None) -> None:
            """
            LoadInterval.

            Args:
            -----
                _custom_data: _custom_data
                default: Default load interval in seconds.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class LocalUsersItem(AvdBase):
        _fields = ("_custom_data", "name", "disabled", "privilege", "role", "sha512_password", "no_password", "ssh_key", "secondary_ssh_key", "shell")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Username."""
        disabled: bool | None = None
        """
        If true, the user will be removed and all other settings are ignored.
        Useful for removing the
        default "admin" user.
        """
        privilege: Annotated[int, Max[15]] | None = None
        """Initial privilege level with local EXEC authorization."""
        role: str | None = None
        """EOS RBAC Role to be assigned to the user such as "network-admin" or "network-operator"."""
        sha512_password: str | None = None
        """
        SHA512 Hash of Password.
        Must be the hash of the password. By default EOS salts the password with
        the username, so the simplest is to generate the hash on an EOS device using the same username.
        """
        no_password: bool | None = None
        """
        If set a password will not be configured for this user. "sha512_password" MUST not be defined for
        this user.
        """
        ssh_key: str | None = None
        secondary_ssh_key: str | None = None
        shell: Annotated[str, ValidValues["/bin/bash", "/bin/sh", "/sbin/nologin"]] | None = None
        """Specify shell for the user."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str = None,
            disabled: bool | None = None,
            privilege: Annotated[int, Max[15]] | None = None,
            role: str | None = None,
            sha512_password: str | None = None,
            no_password: bool | None = None,
            ssh_key: str | None = None,
            secondary_ssh_key: str | None = None,
            shell: Annotated[str, ValidValues["/bin/bash", "/bin/sh", "/sbin/nologin"]] | None = None,
        ) -> None:
            """
            LocalUsersItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Username.
                disabled:
                   If true, the user will be removed and all other settings are ignored.
                   Useful for removing the
                   default "admin" user.
                privilege: Initial privilege level with local EXEC authorization.
                role: EOS RBAC Role to be assigned to the user such as "network-admin" or "network-operator".
                sha512_password:
                   SHA512 Hash of Password.
                   Must be the hash of the password. By default EOS salts the password with
                   the username, so the simplest is to generate the hash on an EOS device using the same username.
                no_password:
                   If set a password will not be configured for this user. "sha512_password" MUST not be defined for
                   this user.
                ssh_key: ssh_key
                secondary_ssh_key: secondary_ssh_key
                shell: Specify shell for the user.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Logging(AvdBase):
        class Buffered(AvdBase):
            _fields = ("_custom_data", "size", "level")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            size: Annotated[int, Min[10], Max[2147483647]] | None = None
            level: (
                Annotated[
                    str, ValidValues["alerts", "critical", "debugging", "emergencies", "errors", "informational", "notifications", "warnings", "disabled"]
                ]
                | None
            ) = None
            """Buffer logging severity level."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                size: Annotated[int, Min[10], Max[2147483647]] | None = None,
                level: Annotated[
                    str, ValidValues["alerts", "critical", "debugging", "emergencies", "errors", "informational", "notifications", "warnings", "disabled"]
                ]
                | None = None,
            ) -> None:
                """
                Buffered.

                Args:
                -----
                    _custom_data: _custom_data
                    size: size
                    level: Buffer logging severity level.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Synchronous(AvdBase):
            _fields = ("_custom_data", "level")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            level: (
                Annotated[
                    str,
                    ValidValues["alerts", "all", "critical", "debugging", "emergencies", "errors", "informational", "notifications", "warnings", "disabled"],
                ]
                | None
            ) = "critical"
            """Synchronous logging severity level."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                level: Annotated[
                    str,
                    ValidValues["alerts", "all", "critical", "debugging", "emergencies", "errors", "informational", "notifications", "warnings", "disabled"],
                ]
                | None = "critical",
            ) -> None:
                """
                Synchronous.

                Args:
                -----
                    _custom_data: _custom_data
                    level: Synchronous logging severity level.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Format(AvdBase):
            _fields = ("_custom_data", "timestamp", "hostname", "sequence_numbers", "rfc5424")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            timestamp: (
                Annotated[
                    str,
                    ValidValues[
                        "high-resolution", "traditional", "traditional timezone", "traditional year", "traditional timezone year", "traditional year timezone"
                    ],
                ]
                | None
            ) = None
            """Timestamp format."""
            hostname: Annotated[str, ValidValues["fqdn", "ipv4"]] | None = None
            """Hostname format in syslogs. For hostname _only_, remove the line. (default EOS CLI behaviour)."""
            sequence_numbers: bool | None = None
            """Add sequence numbers to log messages."""
            rfc5424: bool | None = None
            """Forward logs in RFC5424 format."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                timestamp: Annotated[
                    str,
                    ValidValues[
                        "high-resolution", "traditional", "traditional timezone", "traditional year", "traditional timezone year", "traditional year timezone"
                    ],
                ]
                | None = None,
                hostname: Annotated[str, ValidValues["fqdn", "ipv4"]] | None = None,
                sequence_numbers: bool | None = None,
                rfc5424: bool | None = None,
            ) -> None:
                """
                Format.

                Args:
                -----
                    _custom_data: _custom_data
                    timestamp: Timestamp format.
                    hostname: Hostname format in syslogs. For hostname _only_, remove the line. (default EOS CLI behaviour).
                    sequence_numbers: Add sequence numbers to log messages.
                    rfc5424: Forward logs in RFC5424 format.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrfsItem(AvdBase):
            class HostsItem(AvdBase):
                _fields = ("_custom_data", "name", "protocol", "ports")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Syslog server name."""
                protocol: Annotated[str, ValidValues["tcp", "udp"]] | None = "udp"
                ports: list[int] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    protocol: Annotated[str, ValidValues["tcp", "udp"]] | None = "udp",
                    ports: list[int] | None = None,
                ) -> None:
                    """
                    HostsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Syslog server name.
                        protocol: protocol
                        ports: ports

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "source_interface", "hosts")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """VRF name."""
            source_interface: str | None = None
            """Source interface name."""
            hosts: list[HostsItem] | None = None

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, name: str = None, source_interface: str | None = None, hosts: list[HostsItem] | None = None
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF name.
                    source_interface: Source interface name.
                    hosts: hosts

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Policy(AvdBase):
            class Match(AvdBase):
                class MatchListsItem(AvdBase):
                    _fields = ("_custom_data", "name", "action")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    name: str = None
                    """Match list."""
                    action: Annotated[str, ValidValues["discard"]] | None = None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, name: str = None, action: Annotated[str, ValidValues["discard"]] | None = None
                    ) -> None:
                        """
                        MatchListsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: Match list.
                            action: action

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "match_lists")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                match_lists: list[MatchListsItem] | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, match_lists: list[MatchListsItem] | None = None) -> None:
                    """
                    Match.

                    Args:
                    -----
                        _custom_data: _custom_data
                        match_lists: match_lists

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "match")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            match: Match | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, match: Match | None = None) -> None:
                """
                Policy.

                Args:
                -----
                    _custom_data: _custom_data
                    match: match

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Event(AvdBase):
            class StormControl(AvdBase):
                class Discards(AvdBase):
                    _fields = ("_custom_data", "field_global", "interval")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    field_global: bool | None = None
                    interval: Annotated[int, Min[10], Max[65535]] | None = None
                    """Logging interval in seconds."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        field_global: bool | None = None,
                        interval: Annotated[int, Min[10], Max[65535]] | None = None,
                    ) -> None:
                        """
                        Discards.

                        Args:
                        -----
                            _custom_data: _custom_data
                            field_global: field_global
                            interval: Logging interval in seconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "discards")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                discards: Discards | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, discards: Discards | None = None) -> None:
                    """
                    StormControl.

                    Args:
                    -----
                        _custom_data: _custom_data
                        discards: discards

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "congestion_drops_interval", "global_link_status", "storm_control")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            congestion_drops_interval: Annotated[int, Min[1], Max[65535]] | None = None
            """Logging interval in seconds."""
            global_link_status: bool | None = None
            storm_control: StormControl | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                congestion_drops_interval: Annotated[int, Min[1], Max[65535]] | None = None,
                global_link_status: bool | None = None,
                storm_control: StormControl | None = None,
            ) -> None:
                """
                Event.

                Args:
                -----
                    _custom_data: _custom_data
                    congestion_drops_interval: Logging interval in seconds.
                    global_link_status: global_link_status
                    storm_control: storm_control

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class LevelItem(AvdBase):
            _fields = ("_custom_data", "facility", "severity")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            facility: str = None
            severity: (
                Annotated[
                    str,
                    ValidValues[
                        "alerts",
                        "critical",
                        "debugging",
                        "emergencies",
                        "errors",
                        "informational",
                        "notifications",
                        "warnings",
                        "0",
                        "1",
                        "2",
                        "3",
                        "4",
                        "5",
                        "6",
                        "7",
                    ],
                ]
                | None
            ) = None
            """
            Severity of facility. Below are the supported severities.
            emergencies    System is unusable
            (severity=0)
            alerts         Immediate action needed           (severity=1)
            critical       Critical
            conditions               (severity=2)
            errors         Error conditions                  (severity=3)
            warnings       Warning conditions                (severity=4)
            notifications  Normal but significant
            conditions (severity=5)
            informational  Informational messages            (severity=6)
            debugging
            Debugging messages                (severity=7)
            <0-7>          Severity level value
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                facility: str = None,
                severity: Annotated[
                    str,
                    ValidValues[
                        "alerts",
                        "critical",
                        "debugging",
                        "emergencies",
                        "errors",
                        "informational",
                        "notifications",
                        "warnings",
                        "0",
                        "1",
                        "2",
                        "3",
                        "4",
                        "5",
                        "6",
                        "7",
                    ],
                ]
                | None = None,
            ) -> None:
                """
                LevelItem.

                Args:
                -----
                    _custom_data: _custom_data
                    facility: facility
                    severity:
                       Severity of facility. Below are the supported severities.
                       emergencies    System is unusable
                       (severity=0)
                       alerts         Immediate action needed           (severity=1)
                       critical       Critical
                       conditions               (severity=2)
                       errors         Error conditions                  (severity=3)
                       warnings       Warning conditions                (severity=4)
                       notifications  Normal but significant
                       conditions (severity=5)
                       informational  Informational messages            (severity=6)
                       debugging
                       Debugging messages                (severity=7)
                       <0-7>          Severity level value

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "console",
            "monitor",
            "buffered",
            "repeat_messages",
            "trap",
            "synchronous",
            "format",
            "facility",
            "source_interface",
            "vrfs",
            "policy",
            "event",
            "level",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        console: (
            Annotated[str, ValidValues["debugging", "informational", "notifications", "warnings", "errors", "critical", "alerts", "emergencies", "disabled"]]
            | None
        ) = None
        """Console logging severity level."""
        monitor: (
            Annotated[str, ValidValues["debugging", "informational", "notifications", "warnings", "errors", "critical", "alerts", "emergencies", "disabled"]]
            | None
        ) = None
        """Monitor logging severity level."""
        buffered: Buffered | None = None
        repeat_messages: bool | None = None
        """Summarize concurrent repeat messages."""
        trap: (
            Annotated[
                str, ValidValues["alerts", "critical", "debugging", "emergencies", "errors", "informational", "notifications", "system", "warnings", "disabled"]
            ]
            | None
        ) = None
        """Trap logging severity level."""
        synchronous: Synchronous | None = None
        format: Format | None = None
        facility: (
            Annotated[
                str,
                ValidValues[
                    "auth",
                    "cron",
                    "daemon",
                    "kern",
                    "local0",
                    "local1",
                    "local2",
                    "local3",
                    "local4",
                    "local5",
                    "local6",
                    "local7",
                    "lpr",
                    "mail",
                    "news",
                    "sys9",
                    "sys10",
                    "sys11",
                    "sys12",
                    "sys13",
                    "sys14",
                    "syslog",
                    "user",
                    "uucp",
                ],
            ]
            | None
        ) = None
        source_interface: str | None = None
        """Source Interface Name."""
        vrfs: list[VrfsItem] | None = None
        policy: Policy | None = None
        event: Event | None = None
        level: list[LevelItem] | None = None
        """Configure logging severity."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            console: Annotated[
                str, ValidValues["debugging", "informational", "notifications", "warnings", "errors", "critical", "alerts", "emergencies", "disabled"]
            ]
            | None = None,
            monitor: Annotated[
                str, ValidValues["debugging", "informational", "notifications", "warnings", "errors", "critical", "alerts", "emergencies", "disabled"]
            ]
            | None = None,
            buffered: Buffered | None = None,
            repeat_messages: bool | None = None,
            trap: Annotated[
                str, ValidValues["alerts", "critical", "debugging", "emergencies", "errors", "informational", "notifications", "system", "warnings", "disabled"]
            ]
            | None = None,
            synchronous: Synchronous | None = None,
            format: Format | None = None,
            facility: Annotated[
                str,
                ValidValues[
                    "auth",
                    "cron",
                    "daemon",
                    "kern",
                    "local0",
                    "local1",
                    "local2",
                    "local3",
                    "local4",
                    "local5",
                    "local6",
                    "local7",
                    "lpr",
                    "mail",
                    "news",
                    "sys9",
                    "sys10",
                    "sys11",
                    "sys12",
                    "sys13",
                    "sys14",
                    "syslog",
                    "user",
                    "uucp",
                ],
            ]
            | None = None,
            source_interface: str | None = None,
            vrfs: list[VrfsItem] | None = None,
            policy: Policy | None = None,
            event: Event | None = None,
            level: list[LevelItem] | None = None,
        ) -> None:
            """
            Logging.

            Args:
            -----
                _custom_data: _custom_data
                console: Console logging severity level.
                monitor: Monitor logging severity level.
                buffered: buffered
                repeat_messages: Summarize concurrent repeat messages.
                trap: Trap logging severity level.
                synchronous: synchronous
                format: format
                facility: facility
                source_interface: Source Interface Name.
                vrfs: vrfs
                policy: policy
                event: event
                level: Configure logging severity.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class LoopbackInterfacesItem(AvdBase):
        class Mpls(AvdBase):
            class Ldp(AvdBase):
                _fields = ("_custom_data", "interface")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                interface: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, interface: bool | None = None) -> None:
                    """
                    Ldp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interface: interface

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "ldp")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ldp: Ldp | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, ldp: Ldp | None = None) -> None:
                """
                Mpls.

                Args:
                -----
                    _custom_data: _custom_data
                    ldp: ldp

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class NodeSegment(AvdBase):
            _fields = ("_custom_data", "ipv4_index", "ipv6_index")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv4_index: int | None = None
            ipv6_index: int | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, ipv4_index: int | None = None, ipv6_index: int | None = None) -> None:
                """
                NodeSegment.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4_index: ipv4_index
                    ipv6_index: ipv6_index

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "name",
            "description",
            "shutdown",
            "vrf",
            "ip_address",
            "ip_address_secondaries",
            "ipv6_enable",
            "ipv6_address",
            "ip_proxy_arp",
            "ospf_area",
            "mpls",
            "isis_enable",
            "isis_bfd",
            "isis_passive",
            "isis_metric",
            "isis_network_point_to_point",
            "node_segment",
            "eos_cli",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Loopback interface name e.g. "Loopback0"."""
        description: str | None = None
        shutdown: bool | None = None
        vrf: str | None = None
        """VRF name."""
        ip_address: str | None = None
        """IPv4_address/Mask."""
        ip_address_secondaries: list[str] | None = None
        ipv6_enable: bool | None = None
        ipv6_address: str | None = None
        """IPv6_address/Mask."""
        ip_proxy_arp: bool | None = None
        ospf_area: str | None = None
        mpls: Mpls | None = None
        isis_enable: str | None = None
        """ISIS instance name."""
        isis_bfd: bool | None = None
        """Enable BFD for ISIS."""
        isis_passive: bool | None = None
        isis_metric: int | None = None
        isis_network_point_to_point: bool | None = None
        node_segment: NodeSegment | None = None
        eos_cli: str | None = None
        """EOS CLI rendered directly on the loopback interface in the final EOS configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str = None,
            description: str | None = None,
            shutdown: bool | None = None,
            vrf: str | None = None,
            ip_address: str | None = None,
            ip_address_secondaries: list[str] | None = None,
            ipv6_enable: bool | None = None,
            ipv6_address: str | None = None,
            ip_proxy_arp: bool | None = None,
            ospf_area: str | None = None,
            mpls: Mpls | None = None,
            isis_enable: str | None = None,
            isis_bfd: bool | None = None,
            isis_passive: bool | None = None,
            isis_metric: int | None = None,
            isis_network_point_to_point: bool | None = None,
            node_segment: NodeSegment | None = None,
            eos_cli: str | None = None,
        ) -> None:
            """
            LoopbackInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Loopback interface name e.g. "Loopback0".
                description: description
                shutdown: shutdown
                vrf: VRF name.
                ip_address: IPv4_address/Mask.
                ip_address_secondaries: ip_address_secondaries
                ipv6_enable: ipv6_enable
                ipv6_address: IPv6_address/Mask.
                ip_proxy_arp: ip_proxy_arp
                ospf_area: ospf_area
                mpls: mpls
                isis_enable: ISIS instance name.
                isis_bfd: Enable BFD for ISIS.
                isis_passive: isis_passive
                isis_metric: isis_metric
                isis_network_point_to_point: isis_network_point_to_point
                node_segment: node_segment
                eos_cli: EOS CLI rendered directly on the loopback interface in the final EOS configuration.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MacAccessListsItem(AvdBase):
        class EntriesItem(AvdBase):
            _fields = ("_custom_data", "sequence", "action")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            sequence: int | None = None
            action: str | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, sequence: int | None = None, action: str | None = None) -> None:
                """
                EntriesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: sequence
                    action: action

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "name", "counters_per_entry", "entries")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """MAC Access-list Name."""
        counters_per_entry: bool | None = None
        entries: list[EntriesItem] | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str = None,
            counters_per_entry: bool | None = None,
            entries: list[EntriesItem] | None = None,
        ) -> None:
            """
            MacAccessListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: MAC Access-list Name.
                counters_per_entry: counters_per_entry
                entries: entries

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MacAddressTable(AvdBase):
        class NotificationHostFlap(AvdBase):
            class Detection(AvdBase):
                _fields = ("_custom_data", "window", "moves")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                window: Annotated[int, Min[2], Max[300]] | None = None
                moves: Annotated[int, Min[2], Max[10]] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    window: Annotated[int, Min[2], Max[300]] | None = None,
                    moves: Annotated[int, Min[2], Max[10]] | None = None,
                ) -> None:
                    """
                    Detection.

                    Args:
                    -----
                        _custom_data: _custom_data
                        window: window
                        moves: moves

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "logging", "detection")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            logging: bool | None = None
            detection: Detection | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, logging: bool | None = None, detection: Detection | None = None) -> None:
                """
                NotificationHostFlap.

                Args:
                -----
                    _custom_data: _custom_data
                    logging: logging
                    detection: detection

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "aging_time", "notification_host_flap")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        aging_time: int | None = None
        """Aging time in seconds."""
        notification_host_flap: NotificationHostFlap | None = None

        def __init__(
            self, *, _custom_data: dict[str, Any] | None = None, aging_time: int | None = None, notification_host_flap: NotificationHostFlap | None = None
        ) -> None:
            """
            MacAddressTable.

            Args:
            -----
                _custom_data: _custom_data
                aging_time: Aging time in seconds.
                notification_host_flap: notification_host_flap

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MacSecurity(AvdBase):
        class License(AvdBase):
            _fields = ("_custom_data", "license_name", "license_key")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            license_name: str = None
            license_key: str = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, license_name: str = None, license_key: str = None) -> None:
                """
                License.

                Args:
                -----
                    _custom_data: _custom_data
                    license_name: license_name
                    license_key: license_key

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ProfilesItem(AvdBase):
            class ConnectionKeysItem(AvdBase):
                _fields = ("_custom_data", "id", "encrypted_key", "fallback")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                id: str = None
                encrypted_key: str | None = None
                fallback: bool | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, id: str = None, encrypted_key: str | None = None, fallback: bool | None = None
                ) -> None:
                    """
                    ConnectionKeysItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        id: id
                        encrypted_key: encrypted_key
                        fallback: fallback

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Mka(AvdBase):
                class Session(AvdBase):
                    _fields = ("_custom_data", "rekey_period")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    rekey_period: Annotated[int, Min[30], Max[100000]] | None = None
                    """Rekey period in seconds."""

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, rekey_period: Annotated[int, Min[30], Max[100000]] | None = None) -> None:
                        """
                        Session.

                        Args:
                        -----
                            _custom_data: _custom_data
                            rekey_period: Rekey period in seconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "key_server_priority", "session")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                key_server_priority: Annotated[int, Max[255]] | None = None
                session: Session | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    key_server_priority: Annotated[int, Max[255]] | None = None,
                    session: Session | None = None,
                ) -> None:
                    """
                    Mka.

                    Args:
                    -----
                        _custom_data: _custom_data
                        key_server_priority: key_server_priority
                        session: session

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class L2Protocols(AvdBase):
                class EthernetFlowControl(AvdBase):
                    _fields = ("_custom_data", "mode")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    mode: Annotated[str, ValidValues["encrypt", "bypass"]] = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, mode: Annotated[str, ValidValues["encrypt", "bypass"]] = None) -> None:
                        """
                        EthernetFlowControl.

                        Args:
                        -----
                            _custom_data: _custom_data
                            mode: mode

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Lldp(AvdBase):
                    _fields = ("_custom_data", "mode")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    mode: Annotated[str, ValidValues["bypass", "bypass unauthorized"]] = None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, mode: Annotated[str, ValidValues["bypass", "bypass unauthorized"]] = None
                    ) -> None:
                        """
                        Lldp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            mode: mode

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "ethernet_flow_control", "lldp")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ethernet_flow_control: EthernetFlowControl | None = None
                lldp: Lldp | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, ethernet_flow_control: EthernetFlowControl | None = None, lldp: Lldp | None = None
                ) -> None:
                    """
                    L2Protocols.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ethernet_flow_control: ethernet_flow_control
                        lldp: lldp

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class TrafficUnprotected(AvdBase):
                _fields = ("_custom_data", "action", "allow_active_sak")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                action: Annotated[str, ValidValues["allow", "drop"]] = None
                """Allow/drop the transmit/receive of unprotected traffic."""
                allow_active_sak: bool | None = None
                """Allow transmit/receive of encrypted traffic using operational SAK and block otherwise."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    action: Annotated[str, ValidValues["allow", "drop"]] = None,
                    allow_active_sak: bool | None = None,
                ) -> None:
                    """
                    TrafficUnprotected.

                    Args:
                    -----
                        _custom_data: _custom_data
                        action: Allow/drop the transmit/receive of unprotected traffic.
                        allow_active_sak: Allow transmit/receive of encrypted traffic using operational SAK and block otherwise.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "cipher", "connection_keys", "mka", "sci", "l2_protocols", "traffic_unprotected")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Profile-Name."""
            cipher: Annotated[str, ValidValues["aes128-gcm", "aes128-gcm-xpn", "aes256-gcm", "aes256-gcm-xpn"]] | None = None
            connection_keys: list[ConnectionKeysItem] | None = None
            mka: Mka | None = None
            sci: bool | None = None
            l2_protocols: L2Protocols | None = None
            traffic_unprotected: TrafficUnprotected | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                cipher: Annotated[str, ValidValues["aes128-gcm", "aes128-gcm-xpn", "aes256-gcm", "aes256-gcm-xpn"]] | None = None,
                connection_keys: list[ConnectionKeysItem] | None = None,
                mka: Mka | None = None,
                sci: bool | None = None,
                l2_protocols: L2Protocols | None = None,
                traffic_unprotected: TrafficUnprotected | None = None,
            ) -> None:
                """
                ProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Profile-Name.
                    cipher: cipher
                    connection_keys: connection_keys
                    mka: mka
                    sci: sci
                    l2_protocols: l2_protocols
                    traffic_unprotected: traffic_unprotected

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "license", "fips_restrictions", "profiles")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        license: License | None = None
        fips_restrictions: bool | None = None
        profiles: list[ProfilesItem] | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            license: License | None = None,
            fips_restrictions: bool | None = None,
            profiles: list[ProfilesItem] | None = None,
        ) -> None:
            """
            MacSecurity.

            Args:
            -----
                _custom_data: _custom_data
                license: license
                fips_restrictions: fips_restrictions
                profiles: profiles

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Maintenance(AvdBase):
        class InterfaceProfilesItem(AvdBase):
            class RateMonitoring(AvdBase):
                _fields = ("_custom_data", "load_interval", "threshold")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                load_interval: int | None = None
                """Load Interval in Seconds."""
                threshold: int | None = None
                """Threshold in kbps."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, load_interval: int | None = None, threshold: int | None = None) -> None:
                    """
                    RateMonitoring.

                    Args:
                    -----
                        _custom_data: _custom_data
                        load_interval: Load Interval in Seconds.
                        threshold: Threshold in kbps.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Shutdown(AvdBase):
                _fields = ("_custom_data", "max_delay")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                max_delay: int | None = None
                """Max delay in seconds."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, max_delay: int | None = None) -> None:
                    """
                    Shutdown.

                    Args:
                    -----
                        _custom_data: _custom_data
                        max_delay: Max delay in seconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "rate_monitoring", "shutdown")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            rate_monitoring: RateMonitoring | None = None
            shutdown: Shutdown | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                rate_monitoring: RateMonitoring | None = None,
                shutdown: Shutdown | None = None,
            ) -> None:
                """
                InterfaceProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    rate_monitoring: rate_monitoring
                    shutdown: shutdown

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class BgpProfilesItem(AvdBase):
            class Initiator(AvdBase):
                _fields = ("_custom_data", "route_map_inout")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                route_map_inout: str | None = None
                """Route Map."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, route_map_inout: str | None = None) -> None:
                    """
                    Initiator.

                    Args:
                    -----
                        _custom_data: _custom_data
                        route_map_inout: Route Map.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "initiator")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """BGP Profile Name."""
            initiator: Initiator | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, initiator: Initiator | None = None) -> None:
                """
                BgpProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: BGP Profile Name.
                    initiator: initiator

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class UnitProfilesItem(AvdBase):
            class OnBoot(AvdBase):
                _fields = ("_custom_data", "duration")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                duration: Annotated[int, Min[300], Max[3600]] | None = None
                """On-boot in seconds."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, duration: Annotated[int, Min[300], Max[3600]] | None = None) -> None:
                    """
                    OnBoot.

                    Args:
                    -----
                        _custom_data: _custom_data
                        duration: On-boot in seconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "on_boot")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Unit Profile Name."""
            on_boot: OnBoot | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, on_boot: OnBoot | None = None) -> None:
                """
                UnitProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Unit Profile Name.
                    on_boot: on_boot

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class UnitsItem(AvdBase):
            class Groups(AvdBase):
                _fields = ("_custom_data", "bgp_groups", "interface_groups")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                bgp_groups: list[str] | None = None
                interface_groups: list[str] | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, bgp_groups: list[str] | None = None, interface_groups: list[str] | None = None
                ) -> None:
                    """
                    Groups.

                    Args:
                    -----
                        _custom_data: _custom_data
                        bgp_groups: bgp_groups
                        interface_groups: interface_groups

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "quiesce", "profile", "groups")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Unit Name."""
            quiesce: bool | None = None
            profile: str | None = None
            """Name of Unit Profile."""
            groups: Groups | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                quiesce: bool | None = None,
                profile: str | None = None,
                groups: Groups | None = None,
            ) -> None:
                """
                UnitsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Unit Name.
                    quiesce: quiesce
                    profile: Name of Unit Profile.
                    groups: groups

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "default_interface_profile",
            "default_bgp_profile",
            "default_unit_profile",
            "interface_profiles",
            "bgp_profiles",
            "unit_profiles",
            "units",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        default_interface_profile: str | None = None
        """Name of default Interface Profile."""
        default_bgp_profile: str | None = None
        """Name of default BGP Profile."""
        default_unit_profile: str | None = None
        """Name of default Unit Profile."""
        interface_profiles: list[InterfaceProfilesItem] | None = None
        bgp_profiles: list[BgpProfilesItem] | None = None
        unit_profiles: list[UnitProfilesItem] | None = None
        units: list[UnitsItem] | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            default_interface_profile: str | None = None,
            default_bgp_profile: str | None = None,
            default_unit_profile: str | None = None,
            interface_profiles: list[InterfaceProfilesItem] | None = None,
            bgp_profiles: list[BgpProfilesItem] | None = None,
            unit_profiles: list[UnitProfilesItem] | None = None,
            units: list[UnitsItem] | None = None,
        ) -> None:
            """
            Maintenance.

            Args:
            -----
                _custom_data: _custom_data
                default_interface_profile: Name of default Interface Profile.
                default_bgp_profile: Name of default BGP Profile.
                default_unit_profile: Name of default Unit Profile.
                interface_profiles: interface_profiles
                bgp_profiles: bgp_profiles
                unit_profiles: unit_profiles
                units: units

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementAccounts(AvdBase):
        class Password(AvdBase):
            _fields = ("_custom_data", "policy")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            policy: str | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, policy: str | None = None) -> None:
                """
                Password.

                Args:
                -----
                    _custom_data: _custom_data
                    policy: policy

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "password")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        password: Password | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, password: Password | None = None) -> None:
            """
            ManagementAccounts.

            Args:
            -----
                _custom_data: _custom_data
                password: password

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementApiGnmi(AvdBase):
        class Transport(AvdBase):
            class GrpcItem(AvdBase):
                _fields = ("_custom_data", "name", "ssl_profile", "vrf", "notification_timestamp", "ip_access_group", "port")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str | None = None
                """Transport name."""
                ssl_profile: str | None = None
                """SSL profile name."""
                vrf: str | None = None
                """VRF name is optional."""
                notification_timestamp: Annotated[str, ValidValues["send-time", "last-change-time"]] | None = None
                """
                Per the gNMI specification, the default timestamp field of a notification message is set to be
                the
                time at which the value of the underlying data source changes or when the reported event takes
                place.
                In order to facilitate integration in legacy environments oriented around polling style
                operations,
                an option to support overriding the timestamp field to the send-time is available from
                EOS 4.27.0F.
                """
                ip_access_group: str | None = None
                """ACL name."""
                port: int | None = None
                """
                GNMI port.
                Make sure to update the control-plane ACL accordingly in order for the service to be
                reachable by external applications.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str | None = None,
                    ssl_profile: str | None = None,
                    vrf: str | None = None,
                    notification_timestamp: Annotated[str, ValidValues["send-time", "last-change-time"]] | None = None,
                    ip_access_group: str | None = None,
                    port: int | None = None,
                ) -> None:
                    """
                    GrpcItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Transport name.
                        ssl_profile: SSL profile name.
                        vrf: VRF name is optional.
                        notification_timestamp:
                           Per the gNMI specification, the default timestamp field of a notification message is set to be
                           the
                           time at which the value of the underlying data source changes or when the reported event takes
                           place.
                           In order to facilitate integration in legacy environments oriented around polling style
                           operations,
                           an option to support overriding the timestamp field to the send-time is available from
                           EOS 4.27.0F.
                        ip_access_group: ACL name.
                        port:
                           GNMI port.
                           Make sure to update the control-plane ACL accordingly in order for the service to be
                           reachable by external applications.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class GrpcTunnelsItem(AvdBase):
                class Destination(AvdBase):
                    _fields = ("_custom_data", "address", "port")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    address: str = None
                    """IP address or hostname."""
                    port: Annotated[int, Min[1], Max[65535]] = None
                    """TCP Port."""

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, address: str = None, port: Annotated[int, Min[1], Max[65535]] = None
                    ) -> None:
                        """
                        Destination.

                        Args:
                        -----
                            _custom_data: _custom_data
                            address: IP address or hostname.
                            port: TCP Port.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class LocalInterface(AvdBase):
                    _fields = ("_custom_data", "name", "port")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    name: str = None
                    """Interface name."""
                    port: Annotated[int, Min[1], Max[65535]] = None
                    """TCP Port."""

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, name: str = None, port: Annotated[int, Min[1], Max[65535]] = None
                    ) -> None:
                        """
                        LocalInterface.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: Interface name.
                            port: TCP Port.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Target(AvdBase):
                    _fields = ("_custom_data", "use_serial_number", "target_ids")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    use_serial_number: bool | None = None
                    """Use serial number as the Target ID."""
                    target_ids: list[str] | None = None
                    """Target IDs as a list."""

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, use_serial_number: bool | None = None, target_ids: list[str] | None = None
                    ) -> None:
                        """
                        Target.

                        Args:
                        -----
                            _custom_data: _custom_data
                            use_serial_number: Use serial number as the Target ID.
                            target_ids: Target IDs as a list.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "name", "shutdown", "tunnel_ssl_profile", "gnmi_ssl_profile", "vrf", "destination", "local_interface", "target")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Transport name."""
                shutdown: bool | None = None
                """Operational status of the gRPC tunnel."""
                tunnel_ssl_profile: str | None = None
                """Tunnel SSL profile name."""
                gnmi_ssl_profile: str | None = None
                """gNMI SSL profile name."""
                vrf: str | None = None
                """VRF name."""
                destination: Destination | None = None
                local_interface: LocalInterface | None = None
                target: Target | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    shutdown: bool | None = None,
                    tunnel_ssl_profile: str | None = None,
                    gnmi_ssl_profile: str | None = None,
                    vrf: str | None = None,
                    destination: Destination | None = None,
                    local_interface: LocalInterface | None = None,
                    target: Target | None = None,
                ) -> None:
                    """
                    GrpcTunnelsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Transport name.
                        shutdown: Operational status of the gRPC tunnel.
                        tunnel_ssl_profile: Tunnel SSL profile name.
                        gnmi_ssl_profile: gNMI SSL profile name.
                        vrf: VRF name.
                        destination: destination
                        local_interface: local_interface
                        target: target

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "grpc", "grpc_tunnels")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            grpc: list[GrpcItem] | None = None
            grpc_tunnels: list[GrpcTunnelsItem] | None = None

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, grpc: list[GrpcItem] | None = None, grpc_tunnels: list[GrpcTunnelsItem] | None = None
            ) -> None:
                """
                Transport.

                Args:
                -----
                    _custom_data: _custom_data
                    grpc: grpc
                    grpc_tunnels: grpc_tunnels

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "provider", "transport")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        provider: str | None = "eos-native"
        transport: Transport | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, provider: str | None = "eos-native", transport: Transport | None = None) -> None:
            """
            ManagementApiGnmi.

            Args:
            -----
                _custom_data: _custom_data
                provider: provider
                transport: transport

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementApiHttp(AvdBase):
        class EnableVrfsItem(AvdBase):
            _fields = ("_custom_data", "name", "access_group", "ipv6_access_group")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """VRF Name."""
            access_group: str | None = None
            """Standard IPv4 ACL name."""
            ipv6_access_group: str | None = None
            """Standard IPv6 ACL name."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, name: str = None, access_group: str | None = None, ipv6_access_group: str | None = None
            ) -> None:
                """
                EnableVrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF Name.
                    access_group: Standard IPv4 ACL name.
                    ipv6_access_group: Standard IPv6 ACL name.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ProtocolHttpsCertificate(AvdBase):
            _fields = ("_custom_data", "certificate", "private_key")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            certificate: str | None = None
            """Name of certificate; private key must also be specified."""
            private_key: str | None = None
            """Name of private key; certificate must also be specified."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, certificate: str | None = None, private_key: str | None = None) -> None:
                """
                ProtocolHttpsCertificate.

                Args:
                -----
                    _custom_data: _custom_data
                    certificate: Name of certificate; private key must also be specified.
                    private_key: Name of private key; certificate must also be specified.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "enable_http", "enable_https", "https_ssl_profile", "default_services", "enable_vrfs", "protocol_https_certificate")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        enable_http: bool | None = None
        enable_https: bool | None = None
        https_ssl_profile: str | None = None
        """SSL Profile Name."""
        default_services: bool | None = None
        """Enable default services: capi-doc and tapagg."""
        enable_vrfs: list[EnableVrfsItem] | None = None
        protocol_https_certificate: ProtocolHttpsCertificate | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            enable_http: bool | None = None,
            enable_https: bool | None = None,
            https_ssl_profile: str | None = None,
            default_services: bool | None = None,
            enable_vrfs: list[EnableVrfsItem] | None = None,
            protocol_https_certificate: ProtocolHttpsCertificate | None = None,
        ) -> None:
            """
            ManagementApiHttp.

            Args:
            -----
                _custom_data: _custom_data
                enable_http: enable_http
                enable_https: enable_https
                https_ssl_profile: SSL Profile Name.
                default_services: Enable default services: capi-doc and tapagg.
                enable_vrfs: enable_vrfs
                protocol_https_certificate: protocol_https_certificate

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementApiModels(AvdBase):
        class ProvidersItem(AvdBase):
            class PathsItem(AvdBase):
                _fields = ("_custom_data", "path", "disabled")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                path: str | None = None
                disabled: bool | None = False

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, path: str | None = None, disabled: bool | None = False) -> None:
                    """
                    PathsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        path: path
                        disabled: disabled

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "paths")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: Annotated[str, ValidValues["sysdb", "smash"]] | None = None
            paths: list[PathsItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: Annotated[str, ValidValues["sysdb", "smash"]] | None = None,
                paths: list[PathsItem] | None = None,
            ) -> None:
                """
                ProvidersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    paths: paths

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "providers")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        providers: list[ProvidersItem] | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, providers: list[ProvidersItem] | None = None) -> None:
            """
            ManagementApiModels.

            Args:
            -----
                _custom_data: _custom_data
                providers: providers

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementConsole(AvdBase):
        _fields = ("_custom_data", "idle_timeout")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        idle_timeout: Annotated[int, Max[86400]] | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, idle_timeout: Annotated[int, Max[86400]] | None = None) -> None:
            """
            ManagementConsole.

            Args:
            -----
                _custom_data: _custom_data
                idle_timeout: idle_timeout

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementCvx(AvdBase):
        _fields = ("_custom_data", "shutdown", "server_hosts", "source_interface", "vrf")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        shutdown: bool | None = None
        server_hosts: list[str] | None = None
        source_interface: str | None = None
        """Interface name."""
        vrf: str | None = None
        """VRF Name."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            shutdown: bool | None = None,
            server_hosts: list[str] | None = None,
            source_interface: str | None = None,
            vrf: str | None = None,
        ) -> None:
            """
            ManagementCvx.

            Args:
            -----
                _custom_data: _custom_data
                shutdown: shutdown
                server_hosts: server_hosts
                source_interface: Interface name.
                vrf: VRF Name.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementDefaults(AvdBase):
        class Secret(AvdBase):
            _fields = ("_custom_data", "hash")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            hash: Annotated[str, ValidValues["md5", "sha512"]] | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, hash: Annotated[str, ValidValues["md5", "sha512"]] | None = None) -> None:
                """
                Secret.

                Args:
                -----
                    _custom_data: _custom_data
                    hash: hash

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "secret")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        secret: Secret | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, secret: Secret | None = None) -> None:
            """
            ManagementDefaults.

            Args:
            -----
                _custom_data: _custom_data
                secret: secret

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementInterfacesItem(AvdBase):
        class Lldp(AvdBase):
            _fields = ("_custom_data", "transmit", "receive", "ztp_vlan")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            transmit: bool | None = None
            receive: bool | None = None
            ztp_vlan: int | None = None
            """ZTP vlan number."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, transmit: bool | None = None, receive: bool | None = None, ztp_vlan: int | None = None
            ) -> None:
                """
                Lldp.

                Args:
                -----
                    _custom_data: _custom_data
                    transmit: transmit
                    receive: receive
                    ztp_vlan: ZTP vlan number.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "name",
            "description",
            "shutdown",
            "speed",
            "mtu",
            "vrf",
            "ip_address",
            "ipv6_enable",
            "ipv6_address",
            "type",
            "gateway",
            "ipv6_gateway",
            "mac_address",
            "lldp",
            "eos_cli",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Management Interface Name."""
        description: str | None = None
        shutdown: bool | None = None
        speed: str | None = None
        """
        Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
        <interface_speed>`.
        """
        mtu: int | None = None
        vrf: str | None = None
        """VRF Name."""
        ip_address: str | None = None
        """IPv4_address/Mask."""
        ipv6_enable: bool | None = None
        ipv6_address: str | None = None
        """IPv6_address/Mask."""
        type: Annotated[str, ValidValues["oob", "inband"]] | None = "oob"
        """For documentation purposes only."""
        gateway: str | None = None
        """IPv4 address of default gateway in management VRF."""
        ipv6_gateway: str | None = None
        """IPv6 address of default gateway in management VRF."""
        mac_address: str | None = None
        """MAC address."""
        lldp: Lldp | None = None
        eos_cli: str | None = None
        """Multiline EOS CLI rendered directly on the management interface in the final EOS configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str = None,
            description: str | None = None,
            shutdown: bool | None = None,
            speed: str | None = None,
            mtu: int | None = None,
            vrf: str | None = None,
            ip_address: str | None = None,
            ipv6_enable: bool | None = None,
            ipv6_address: str | None = None,
            type: Annotated[str, ValidValues["oob", "inband"]] | None = "oob",
            gateway: str | None = None,
            ipv6_gateway: str | None = None,
            mac_address: str | None = None,
            lldp: Lldp | None = None,
            eos_cli: str | None = None,
        ) -> None:
            """
            ManagementInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Management Interface Name.
                description: description
                shutdown: shutdown
                speed:
                   Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                   <interface_speed>`.
                mtu: mtu
                vrf: VRF Name.
                ip_address: IPv4_address/Mask.
                ipv6_enable: ipv6_enable
                ipv6_address: IPv6_address/Mask.
                type: For documentation purposes only.
                gateway: IPv4 address of default gateway in management VRF.
                ipv6_gateway: IPv6 address of default gateway in management VRF.
                mac_address: MAC address.
                lldp: lldp
                eos_cli: Multiline EOS CLI rendered directly on the management interface in the final EOS configuration.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementSecurity(AvdBase):
        class EntropySources(AvdBase):
            _fields = ("_custom_data", "hardware", "haveged", "cpu_jitter", "hardware_exclusive")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            hardware: bool | None = None
            """Use a hardware based source."""
            haveged: bool | None = None
            """Use the HAVEGE algorithm."""
            cpu_jitter: bool | None = None
            """Use the Jitter RNG algorithm of a CPU based source."""
            hardware_exclusive: bool | None = None
            """Only use entropy from the hardware source."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                hardware: bool | None = None,
                haveged: bool | None = None,
                cpu_jitter: bool | None = None,
                hardware_exclusive: bool | None = None,
            ) -> None:
                """
                EntropySources.

                Args:
                -----
                    _custom_data: _custom_data
                    hardware: Use a hardware based source.
                    haveged: Use the HAVEGE algorithm.
                    cpu_jitter: Use the Jitter RNG algorithm of a CPU based source.
                    hardware_exclusive: Only use entropy from the hardware source.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Password(AvdBase):
            class PoliciesItem(AvdBase):
                class Minimum(AvdBase):
                    _fields = ("_custom_data", "digits", "length", "lower", "special", "upper")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    digits: Annotated[int, Min[1], Max[65535]] | None = None
                    length: Annotated[int, Min[1], Max[65535]] | None = None
                    lower: Annotated[int, Min[1], Max[65535]] | None = None
                    special: Annotated[int, Min[1], Max[65535]] | None = None
                    upper: Annotated[int, Min[1], Max[65535]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        digits: Annotated[int, Min[1], Max[65535]] | None = None,
                        length: Annotated[int, Min[1], Max[65535]] | None = None,
                        lower: Annotated[int, Min[1], Max[65535]] | None = None,
                        special: Annotated[int, Min[1], Max[65535]] | None = None,
                        upper: Annotated[int, Min[1], Max[65535]] | None = None,
                    ) -> None:
                        """
                        Minimum.

                        Args:
                        -----
                            _custom_data: _custom_data
                            digits: digits
                            length: length
                            lower: lower
                            special: special
                            upper: upper

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Maximum(AvdBase):
                    _fields = ("_custom_data", "repetitive", "sequential")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    repetitive: Annotated[int, Min[1], Max[65535]] | None = None
                    sequential: Annotated[int, Min[1], Max[65535]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        repetitive: Annotated[int, Min[1], Max[65535]] | None = None,
                        sequential: Annotated[int, Min[1], Max[65535]] | None = None,
                    ) -> None:
                        """
                        Maximum.

                        Args:
                        -----
                            _custom_data: _custom_data
                            repetitive: repetitive
                            sequential: sequential

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "name", "minimum", "maximum")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                minimum: Minimum | None = None
                maximum: Maximum | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, name: str = None, minimum: Minimum | None = None, maximum: Maximum | None = None
                ) -> None:
                    """
                    PoliciesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        minimum: minimum
                        maximum: maximum

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "minimum_length", "encryption_key_common", "encryption_reversible", "policies")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            minimum_length: Annotated[int, Min[1], Max[32]] | None = None
            encryption_key_common: bool | None = None
            encryption_reversible: str | None = None
            policies: list[PoliciesItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                minimum_length: Annotated[int, Min[1], Max[32]] | None = None,
                encryption_key_common: bool | None = None,
                encryption_reversible: str | None = None,
                policies: list[PoliciesItem] | None = None,
            ) -> None:
                """
                Password.

                Args:
                -----
                    _custom_data: _custom_data
                    minimum_length: minimum_length
                    encryption_key_common: encryption_key_common
                    encryption_reversible: encryption_reversible
                    policies: policies

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SslProfilesItem(AvdBase):
            class TrustCertificate(AvdBase):
                class Requirement(AvdBase):
                    _fields = ("_custom_data", "basic_constraint_ca", "hostname_fqdn")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    basic_constraint_ca: bool | None = None
                    hostname_fqdn: bool | None = None
                    """Enforce hostname to be FQDN without wildcard."""

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, basic_constraint_ca: bool | None = None, hostname_fqdn: bool | None = None
                    ) -> None:
                        """
                        Requirement.

                        Args:
                        -----
                            _custom_data: _custom_data
                            basic_constraint_ca: basic_constraint_ca
                            hostname_fqdn: Enforce hostname to be FQDN without wildcard.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "certificates", "requirement", "policy_expiry_date_ignore", "system")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                certificates: list[str] | None = None
                """
                List of trust certificate names.
                Examples:
                  - test1.crt
                  - test2.crt
                """
                requirement: Requirement | None = None
                policy_expiry_date_ignore: bool | None = None
                system: bool | None = None
                """Use system-supplied trust certificates."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    certificates: list[str] | None = None,
                    requirement: Requirement | None = None,
                    policy_expiry_date_ignore: bool | None = None,
                    system: bool | None = None,
                ) -> None:
                    """
                    TrustCertificate.

                    Args:
                    -----
                        _custom_data: _custom_data
                        certificates:
                           List of trust certificate names.

                    Examples:
                             - test1.crt
                             - test2.crt
                        requirement: requirement
                        policy_expiry_date_ignore: policy_expiry_date_ignore
                        system: Use system-supplied trust certificates.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class ChainCertificate(AvdBase):
                class Requirement(AvdBase):
                    _fields = ("_custom_data", "basic_constraint_ca", "include_root_ca")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    basic_constraint_ca: bool | None = None
                    include_root_ca: bool | None = None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, basic_constraint_ca: bool | None = None, include_root_ca: bool | None = None
                    ) -> None:
                        """
                        Requirement.

                        Args:
                        -----
                            _custom_data: _custom_data
                            basic_constraint_ca: basic_constraint_ca
                            include_root_ca: include_root_ca

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "certificates", "requirement")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                certificates: list[str] | None = None
                """
                List of chain certificate names.
                Examples:
                  - chain1.crt
                  - chain2.crt
                """
                requirement: Requirement | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, certificates: list[str] | None = None, requirement: Requirement | None = None
                ) -> None:
                    """
                    ChainCertificate.

                    Args:
                    -----
                        _custom_data: _custom_data
                        certificates:
                           List of chain certificate names.

                    Examples:
                             - chain1.crt
                             - chain2.crt
                        requirement: requirement

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Certificate(AvdBase):
                _fields = ("_custom_data", "file", "key")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                file: str | None = None
                key: str | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, file: str | None = None, key: str | None = None) -> None:
                    """
                    Certificate.

                    Args:
                    -----
                        _custom_data: _custom_data
                        file: file
                        key: key

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = (
                "_custom_data",
                "name",
                "tls_versions",
                "cipher_list",
                "trust_certificate",
                "chain_certificate",
                "certificate",
                "certificate_revocation_lists",
            )
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str | None = None
            tls_versions: str | None = None
            """
            List of allowed TLS versions as string.
            Examples:
              - "1.0"
              - "1.0 1.1"
            """
            cipher_list: str | None = None
            """
            cipher_list syntax follows the openssl cipher strings format.
            Colon (:) separated list of allowed
            ciphers as a string.
            """
            trust_certificate: TrustCertificate | None = None
            chain_certificate: ChainCertificate | None = None
            certificate: Certificate | None = None
            certificate_revocation_lists: list[str] | None = None
            """
            List of CRLs (Certificate Revocation List).
            If specified, one CRL needs to be provided for every
            certificate in the chain, even if the revocation list in the CRL is empty.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str | None = None,
                tls_versions: str | None = None,
                cipher_list: str | None = None,
                trust_certificate: TrustCertificate | None = None,
                chain_certificate: ChainCertificate | None = None,
                certificate: Certificate | None = None,
                certificate_revocation_lists: list[str] | None = None,
            ) -> None:
                """
                SslProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    tls_versions:
                       List of allowed TLS versions as string.

                Examples:
                         - "1.0"
                         - "1.0 1.1"
                    cipher_list:
                       cipher_list syntax follows the openssl cipher strings format.
                       Colon (:) separated list of allowed
                       ciphers as a string.
                    trust_certificate: trust_certificate
                    chain_certificate: chain_certificate
                    certificate: certificate
                    certificate_revocation_lists:
                       List of CRLs (Certificate Revocation List).
                       If specified, one CRL needs to be provided for every
                       certificate in the chain, even if the revocation list in the CRL is empty.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SharedSecretProfilesItem(AvdBase):
            class SecretsItem(AvdBase):
                class ReceiveLifetime(AvdBase):
                    _fields = ("_custom_data", "infinite", "start_date_time", "end_date_time")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    infinite: bool | None = None
                    start_date_time: str | None = None
                    """
                    Start date and time of lifetime of the secret. End date should be greater than start date.
                    Formats
                    supported:
                    1. mm/dd/yyyy hh:mm:ss
                    2. yyyy-mm-dd hh:mm:ss
                    e.g 2024-12-20 10:00:00
                    """
                    end_date_time: str | None = None
                    """
                    End date and time of lifetime of the secret. End date should be greater than start date.
                    Formats
                    supported:
                    1. mm/dd/yyyy hh:mm:ss
                    2. yyyy-mm-dd hh:mm:ss
                    e.g 2024-12-20 10:00:00
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        infinite: bool | None = None,
                        start_date_time: str | None = None,
                        end_date_time: str | None = None,
                    ) -> None:
                        """
                        ReceiveLifetime.

                        Args:
                        -----
                            _custom_data: _custom_data
                            infinite: infinite
                            start_date_time:
                               Start date and time of lifetime of the secret. End date should be greater than start date.
                               Formats
                               supported:
                               1. mm/dd/yyyy hh:mm:ss
                               2. yyyy-mm-dd hh:mm:ss
                               e.g 2024-12-20 10:00:00
                            end_date_time:
                               End date and time of lifetime of the secret. End date should be greater than start date.
                               Formats
                               supported:
                               1. mm/dd/yyyy hh:mm:ss
                               2. yyyy-mm-dd hh:mm:ss
                               e.g 2024-12-20 10:00:00

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class TransmitLifetime(AvdBase):
                    _fields = ("_custom_data", "infinite", "start_date_time", "end_date_time")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    infinite: bool | None = None
                    start_date_time: str | None = None
                    """
                    Start date and time of lifetime of the secret. End date should be greater than start date.
                    Formats
                    supported:
                    1. mm/dd/yyyy hh:mm:ss
                    2. yyyy-mm-dd hh:mm:ss
                    e.g 2024-12-20 10:00:00
                    """
                    end_date_time: str | None = None
                    """
                    End date and time of lifetime of the secret. End date should be greater than start date.
                    Formats
                    supported:
                    1. mm/dd/yyyy hh:mm:ss
                    2. yyyy-mm-dd hh:mm:ss
                    e.g 2024-12-20 10:00:00
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        infinite: bool | None = None,
                        start_date_time: str | None = None,
                        end_date_time: str | None = None,
                    ) -> None:
                        """
                        TransmitLifetime.

                        Args:
                        -----
                            _custom_data: _custom_data
                            infinite: infinite
                            start_date_time:
                               Start date and time of lifetime of the secret. End date should be greater than start date.
                               Formats
                               supported:
                               1. mm/dd/yyyy hh:mm:ss
                               2. yyyy-mm-dd hh:mm:ss
                               e.g 2024-12-20 10:00:00
                            end_date_time:
                               End date and time of lifetime of the secret. End date should be greater than start date.
                               Formats
                               supported:
                               1. mm/dd/yyyy hh:mm:ss
                               2. yyyy-mm-dd hh:mm:ss
                               e.g 2024-12-20 10:00:00

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "name", "secret", "secret_type", "receive_lifetime", "transmit_lifetime", "local_time")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                secret: str = None
                secret_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = "7"
                receive_lifetime: ReceiveLifetime = None
                transmit_lifetime: TransmitLifetime = None
                local_time: bool | None = None
                """Configuring secret using the local timezone from system clock. Default is UTC."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    secret: str = None,
                    secret_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = "7",
                    receive_lifetime: ReceiveLifetime = None,
                    transmit_lifetime: TransmitLifetime = None,
                    local_time: bool | None = None,
                ) -> None:
                    """
                    SecretsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        secret: secret
                        secret_type: secret_type
                        receive_lifetime: receive_lifetime
                        transmit_lifetime: transmit_lifetime
                        local_time: Configuring secret using the local timezone from system clock. Default is UTC.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "profile", "secrets")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            profile: str = None
            secrets: list[SecretsItem] | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, profile: str = None, secrets: list[SecretsItem] | None = None) -> None:
                """
                SharedSecretProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    profile: profile
                    secrets: secrets

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "entropy_sources", "password", "ssl_profiles", "shared_secret_profiles")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        entropy_sources: EntropySources | None = None
        """Source of entropy."""
        password: Password | None = None
        ssl_profiles: list[SslProfilesItem] | None = None
        shared_secret_profiles: list[SharedSecretProfilesItem] | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            entropy_sources: EntropySources | None = None,
            password: Password | None = None,
            ssl_profiles: list[SslProfilesItem] | None = None,
            shared_secret_profiles: list[SharedSecretProfilesItem] | None = None,
        ) -> None:
            """
            ManagementSecurity.

            Args:
            -----
                _custom_data: _custom_data
                entropy_sources: Source of entropy.
                password: password
                ssl_profiles: ssl_profiles
                shared_secret_profiles: shared_secret_profiles

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementSsh(AvdBase):
        class Authentication(AvdBase):
            _fields = ("_custom_data", "empty_passwords", "protocols")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            empty_passwords: Annotated[str, ValidValues["auto", "deny", "permit"]] | None = None
            """Permit or deny empty passwords for SSH authentication."""
            protocols: list[Annotated[str, ValidValues["keyboard-interactive", "password", "public-key"]]] | None = None
            """Allowed SSH authentication methods."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                empty_passwords: Annotated[str, ValidValues["auto", "deny", "permit"]] | None = None,
                protocols: list[Annotated[str, ValidValues["keyboard-interactive", "password", "public-key"]]] | None = None,
            ) -> None:
                """
                Authentication.

                Args:
                -----
                    _custom_data: _custom_data
                    empty_passwords: Permit or deny empty passwords for SSH authentication.
                    protocols: Allowed SSH authentication methods.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AccessGroupsItem(AvdBase):
            _fields = ("_custom_data", "name", "vrf")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str | None = None
            """Standard ACL Name."""
            vrf: str | None = None
            """VRF Name."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, vrf: str | None = None) -> None:
                """
                AccessGroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Standard ACL Name.
                    vrf: VRF Name.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6AccessGroupsItem(AvdBase):
            _fields = ("_custom_data", "name", "vrf")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str | None = None
            """Standard ACL Name."""
            vrf: str | None = None
            """VRF Name."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, vrf: str | None = None) -> None:
                """
                Ipv6AccessGroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Standard ACL Name.
                    vrf: VRF Name.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Hostkey(AvdBase):
            _fields = ("_custom_data", "server", "server_cert", "client_strict_checking")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            server: list[str] | None = None
            """SSH host key settings."""
            server_cert: str | None = None
            """Configure switch's hostkey cert file."""
            client_strict_checking: bool | None = None
            """Enforce strict host key checking."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                server: list[str] | None = None,
                server_cert: str | None = None,
                client_strict_checking: bool | None = None,
            ) -> None:
                """
                Hostkey.

                Args:
                -----
                    _custom_data: _custom_data
                    server: SSH host key settings.
                    server_cert: Configure switch's hostkey cert file.
                    client_strict_checking: Enforce strict host key checking.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Connection(AvdBase):
            _fields = ("_custom_data", "limit", "per_host")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            limit: Annotated[int, Min[1], Max[100]] | None = None
            """Maximum total number of SSH sessions to device."""
            per_host: Annotated[int, Min[1], Max[20]] | None = None
            """Maximum number of SSH sessions to device from a single host."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                limit: Annotated[int, Min[1], Max[100]] | None = None,
                per_host: Annotated[int, Min[1], Max[20]] | None = None,
            ) -> None:
                """
                Connection.

                Args:
                -----
                    _custom_data: _custom_data
                    limit: Maximum total number of SSH sessions to device.
                    per_host: Maximum number of SSH sessions to device from a single host.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrfsItem(AvdBase):
            _fields = ("_custom_data", "name", "enable")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """VRF Name."""
            enable: bool | None = None
            """Enable SSH in VRF."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, enable: bool | None = None) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF Name.
                    enable: Enable SSH in VRF.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ClientAlive(AvdBase):
            _fields = ("_custom_data", "count_max", "interval")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            count_max: Annotated[int, Min[1], Max[1000]] | None = None
            """
            Number of keep-alive packets that can be sent without a response before the connection is assumed
            dead.
            """
            interval: Annotated[int, Min[1], Max[1000]] | None = None
            """Time period (in seconds) to send SSH keep-alive packets."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                count_max: Annotated[int, Min[1], Max[1000]] | None = None,
                interval: Annotated[int, Min[1], Max[1000]] | None = None,
            ) -> None:
                """
                ClientAlive.

                Args:
                -----
                    _custom_data: _custom_data
                    count_max:
                       Number of keep-alive packets that can be sent without a response before the connection is assumed
                       dead.
                    interval: Time period (in seconds) to send SSH keep-alive packets.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "authentication",
            "access_groups",
            "ipv6_access_groups",
            "idle_timeout",
            "cipher",
            "key_exchange",
            "mac",
            "fips_restrictions",
            "hostkey",
            "enable",
            "connection",
            "vrfs",
            "log_level",
            "client_alive",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        authentication: Authentication | None = None
        access_groups: list[AccessGroupsItem] | None = None
        ipv6_access_groups: list[Ipv6AccessGroupsItem] | None = None
        idle_timeout: Annotated[int, Max[86400]] | None = None
        """Idle timeout in minutes."""
        cipher: list[str] | None = None
        """Cryptographic ciphers for SSH to use."""
        key_exchange: list[str] | None = None
        """Cryptographic key exchange methods for SSH to use."""
        mac: list[str] | None = None
        """Cryptographic MAC algorithms for SSH to use."""
        fips_restrictions: bool | None = None
        """Use FIPS compliant algorithms."""
        hostkey: Hostkey | None = None
        enable: bool | None = None
        """Enable SSH daemon."""
        connection: Connection | None = None
        vrfs: list[VrfsItem] | None = None
        log_level: str | None = None
        """SSH daemon log level."""
        client_alive: ClientAlive | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            authentication: Authentication | None = None,
            access_groups: list[AccessGroupsItem] | None = None,
            ipv6_access_groups: list[Ipv6AccessGroupsItem] | None = None,
            idle_timeout: Annotated[int, Max[86400]] | None = None,
            cipher: list[str] | None = None,
            key_exchange: list[str] | None = None,
            mac: list[str] | None = None,
            fips_restrictions: bool | None = None,
            hostkey: Hostkey | None = None,
            enable: bool | None = None,
            connection: Connection | None = None,
            vrfs: list[VrfsItem] | None = None,
            log_level: str | None = None,
            client_alive: ClientAlive | None = None,
        ) -> None:
            """
            ManagementSsh.

            Args:
            -----
                _custom_data: _custom_data
                authentication: authentication
                access_groups: access_groups
                ipv6_access_groups: ipv6_access_groups
                idle_timeout: Idle timeout in minutes.
                cipher: Cryptographic ciphers for SSH to use.
                key_exchange: Cryptographic key exchange methods for SSH to use.
                mac: Cryptographic MAC algorithms for SSH to use.
                fips_restrictions: Use FIPS compliant algorithms.
                hostkey: hostkey
                enable: Enable SSH daemon.
                connection: connection
                vrfs: vrfs
                log_level: SSH daemon log level.
                client_alive: client_alive

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementTechSupport(AvdBase):
        class PolicyShowTechSupport(AvdBase):
            class ExcludeCommandsItem(AvdBase):
                _fields = ("_custom_data", "command", "type")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                command: str | None = None
                """Command to exclude from tech-support."""
                type: Annotated[str, ValidValues["text", "json"]] | None = "text"
                """The supported values for type are platform dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    command: str | None = None,
                    type: Annotated[str, ValidValues["text", "json"]] | None = "text",
                ) -> None:
                    """
                    ExcludeCommandsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        command: Command to exclude from tech-support.
                        type: The supported values for type are platform dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class IncludeCommandsItem(AvdBase):
                _fields = ("_custom_data", "command")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                command: str | None = None
                """Command to include in tech-support."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, command: str | None = None) -> None:
                    """
                    IncludeCommandsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        command: Command to include in tech-support.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "exclude_commands", "include_commands")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            exclude_commands: list[ExcludeCommandsItem] | None = None
            include_commands: list[IncludeCommandsItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                exclude_commands: list[ExcludeCommandsItem] | None = None,
                include_commands: list[IncludeCommandsItem] | None = None,
            ) -> None:
                """
                PolicyShowTechSupport.

                Args:
                -----
                    _custom_data: _custom_data
                    exclude_commands: exclude_commands
                    include_commands: include_commands

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "policy_show_tech_support")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        policy_show_tech_support: PolicyShowTechSupport | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, policy_show_tech_support: PolicyShowTechSupport | None = None) -> None:
            """
            ManagementTechSupport.

            Args:
            -----
                _custom_data: _custom_data
                policy_show_tech_support: policy_show_tech_support

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MatchListInput(AvdBase):
        class PrefixIpv4Item(AvdBase):
            _fields = ("_custom_data", "name", "prefixes")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Prefix-List Name."""
            prefixes: list[str] = None
            """List of IPv4 prefixes (with the subnet mask e.g. 192.0.2.0/24)."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, prefixes: list[str] = None) -> None:
                """
                PrefixIpv4Item.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Prefix-List Name.
                    prefixes: List of IPv4 prefixes (with the subnet mask e.g. 192.0.2.0/24).

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PrefixIpv6Item(AvdBase):
            _fields = ("_custom_data", "name", "prefixes")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Prefix-List Name."""
            prefixes: list[str] = None
            """List of IPv6 prefixes (with the subnet mask e.g. 2001:db8:abcd:0013::/64)."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, prefixes: list[str] = None) -> None:
                """
                PrefixIpv6Item.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Prefix-List Name.
                    prefixes: List of IPv6 prefixes (with the subnet mask e.g. 2001:db8:abcd:0013::/64).

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class StringItem(AvdBase):
            class SequenceNumbersItem(AvdBase):
                _fields = ("_custom_data", "sequence", "match_regex")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                sequence: int = None
                """Sequence ID."""
                match_regex: str = None
                """Regular Expression."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, sequence: int = None, match_regex: str = None) -> None:
                    """
                    SequenceNumbersItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        sequence: Sequence ID.
                        match_regex: Regular Expression.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "sequence_numbers")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Match-list Name."""
            sequence_numbers: list[SequenceNumbersItem] = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, sequence_numbers: list[SequenceNumbersItem] = None) -> None:
                """
                StringItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Match-list Name.
                    sequence_numbers: sequence_numbers

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "prefix_ipv4", "prefix_ipv6", "string")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        prefix_ipv4: list[PrefixIpv4Item] | None = None
        prefix_ipv6: list[PrefixIpv6Item] | None = None
        string: list[StringItem] | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            prefix_ipv4: list[PrefixIpv4Item] | None = None,
            prefix_ipv6: list[PrefixIpv6Item] | None = None,
            string: list[StringItem] | None = None,
        ) -> None:
            """
            MatchListInput.

            Args:
            -----
                _custom_data: _custom_data
                prefix_ipv4: prefix_ipv4
                prefix_ipv6: prefix_ipv6
                string: string

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class McsClient(AvdBase):
        class CvxSecondary(AvdBase):
            _fields = ("_custom_data", "name", "shutdown", "server_hosts")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str | None = None
            shutdown: bool | None = None
            server_hosts: list[str] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str | None = None,
                shutdown: bool | None = None,
                server_hosts: list[str] | None = None,
            ) -> None:
                """
                CvxSecondary.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    shutdown: shutdown
                    server_hosts: server_hosts

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "shutdown", "cvx_secondary")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        shutdown: bool | None = None
        cvx_secondary: CvxSecondary | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, shutdown: bool | None = None, cvx_secondary: CvxSecondary | None = None) -> None:
            """
            McsClient.

            Args:
            -----
                _custom_data: _custom_data
                shutdown: shutdown
                cvx_secondary: cvx_secondary

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Metadata(AvdBase):
        class CvTags(AvdBase):
            class DeviceTagsItem(AvdBase):
                _fields = ("_custom_data", "name", "value")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                value: str = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, value: str = None) -> None:
                    """
                    DeviceTagsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        value: value

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class InterfaceTagsItem(AvdBase):
                class TagsItem(AvdBase):
                    _fields = ("_custom_data", "name", "value")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    name: str = None
                    value: str = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, value: str = None) -> None:
                        """
                        TagsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: name
                            value: value

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "interface", "tags")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                interface: str = None
                tags: list[TagsItem] | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, interface: str = None, tags: list[TagsItem] | None = None) -> None:
                    """
                    InterfaceTagsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interface: interface
                        tags: tags

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "device_tags", "interface_tags")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            device_tags: list[DeviceTagsItem] | None = None
            interface_tags: list[InterfaceTagsItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                device_tags: list[DeviceTagsItem] | None = None,
                interface_tags: list[InterfaceTagsItem] | None = None,
            ) -> None:
                """
                CvTags.

                Args:
                -----
                    _custom_data: _custom_data
                    device_tags: device_tags
                    interface_tags: interface_tags

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class CvPathfinder(AvdBase):
            class PathfindersItem(AvdBase):
                _fields = ("_custom_data", "vtep_ip")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                vtep_ip: str = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, vtep_ip: str = None) -> None:
                    """
                    PathfindersItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        vtep_ip: vtep_ip

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class InterfacesItem(AvdBase):
                _fields = ("_custom_data", "name", "carrier", "circuit_id", "pathgroup", "public_ip")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str | None = None
                carrier: str | None = None
                circuit_id: str | None = None
                pathgroup: str | None = None
                public_ip: str | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str | None = None,
                    carrier: str | None = None,
                    circuit_id: str | None = None,
                    pathgroup: str | None = None,
                    public_ip: str | None = None,
                ) -> None:
                    """
                    InterfacesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        carrier: carrier
                        circuit_id: circuit_id
                        pathgroup: pathgroup
                        public_ip: public_ip

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PathgroupsItem(AvdBase):
                class CarriersItem(AvdBase):
                    _fields = ("_custom_data", "name")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    name: str | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None) -> None:
                        """
                        CarriersItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: name

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class ImportedCarriersItem(AvdBase):
                    _fields = ("_custom_data", "name")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    name: str | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None) -> None:
                        """
                        ImportedCarriersItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: name

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "name", "carriers", "imported_carriers")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                carriers: list[CarriersItem] | None = None
                imported_carriers: list[ImportedCarriersItem] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    carriers: list[CarriersItem] | None = None,
                    imported_carriers: list[ImportedCarriersItem] | None = None,
                ) -> None:
                    """
                    PathgroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        carriers: carriers
                        imported_carriers: imported_carriers

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RegionsItem(AvdBase):
                class ZonesItem(AvdBase):
                    class SitesItem(AvdBase):
                        class Location(AvdBase):
                            _fields = ("_custom_data", "address")
                            _required_fields = ()
                            _custom_data: dict[str, Any] | None = None
                            address: str | None = None

                            def __init__(self, *, _custom_data: dict[str, Any] | None = None, address: str | None = None) -> None:
                                """
                                Location.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    address: address

                                """
                                for arg, arg_value in locals().items():
                                    if arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields = ("_custom_data", "id", "name", "location")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        id: int | None = None
                        name: str | None = None
                        location: Location | None = None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            id: int | None = None,
                            name: str | None = None,
                            location: Location | None = None,
                        ) -> None:
                            """
                            SitesItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                id: id
                                name: name
                                location: location

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "id", "name", "sites")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    id: int | None = None
                    name: str | None = None
                    sites: list[SitesItem] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        id: int | None = None,
                        name: str | None = None,
                        sites: list[SitesItem] | None = None,
                    ) -> None:
                        """
                        ZonesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: id
                            name: name
                            sites: sites

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "id", "name", "zones")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                id: int | None = None
                name: str | None = None
                zones: list[ZonesItem] | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, id: int | None = None, name: str | None = None, zones: list[ZonesItem] | None = None
                ) -> None:
                    """
                    RegionsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        id: id
                        name: name
                        zones: zones

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class VrfsItem(AvdBase):
                class AvtsItem(AvdBase):
                    class Constraints(AvdBase):
                        _fields = ("_custom_data", "jitter", "latency", "lossrate", "hop_count")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        jitter: int | None = None
                        latency: int | None = None
                        lossrate: str | None = None
                        hop_count: str | None = None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            jitter: int | None = None,
                            latency: int | None = None,
                            lossrate: str | None = None,
                            hop_count: str | None = None,
                        ) -> None:
                            """
                            Constraints.

                            Args:
                            -----
                                _custom_data: _custom_data
                                jitter: jitter
                                latency: latency
                                lossrate: lossrate
                                hop_count: hop_count

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class PathgroupsItem(AvdBase):
                        _fields = ("_custom_data", "name", "preference")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        name: str | None = None
                        preference: str | None = None

                        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, preference: str | None = None) -> None:
                            """
                            PathgroupsItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                name: name
                                preference: preference

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "constraints", "description", "id", "name", "pathgroups", "application_profiles")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    constraints: Constraints | None = None
                    description: str | None = None
                    id: int | None = None
                    name: str | None = None
                    pathgroups: list[PathgroupsItem] | None = None
                    application_profiles: list[str] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        constraints: Constraints | None = None,
                        description: str | None = None,
                        id: int | None = None,
                        name: str | None = None,
                        pathgroups: list[PathgroupsItem] | None = None,
                        application_profiles: list[str] | None = None,
                    ) -> None:
                        """
                        AvtsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            constraints: constraints
                            description: description
                            id: id
                            name: name
                            pathgroups: pathgroups
                            application_profiles: application_profiles

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "name", "vni", "avts")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str | None = None
                vni: int | None = None
                avts: list[AvtsItem] | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, vni: int | None = None, avts: list[AvtsItem] | None = None
                ) -> None:
                    """
                    VrfsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        vni: vni
                        avts: avts

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class InternetExitPoliciesItem(AvdBase):
                class VpnCredentialsItem(AvdBase):
                    _fields = ("_custom_data", "fqdn", "vpn_type", "pre_shared_key")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    fqdn: str = None
                    vpn_type: str = None
                    pre_shared_key: str = None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, fqdn: str = None, vpn_type: str = None, pre_shared_key: str = None
                    ) -> None:
                        """
                        VpnCredentialsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            fqdn: fqdn
                            vpn_type: vpn_type
                            pre_shared_key: pre_shared_key

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class TunnelsItem(AvdBase):
                    _fields = ("_custom_data", "name", "preference")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    name: str = None
                    preference: str = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, preference: str = None) -> None:
                        """
                        TunnelsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: name
                            preference: preference

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = (
                    "_custom_data",
                    "name",
                    "type",
                    "city",
                    "country",
                    "upload_bandwidth",
                    "download_bandwidth",
                    "firewall",
                    "ips_control",
                    "acceptable_use_policy",
                    "vpn_credentials",
                    "tunnels",
                )
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                type: str = None
                city: str = None
                country: str = None
                upload_bandwidth: int | None = None
                download_bandwidth: int | None = None
                firewall: bool = None
                ips_control: bool = None
                acceptable_use_policy: bool = None
                vpn_credentials: list[VpnCredentialsItem] = None
                tunnels: list[TunnelsItem] = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    type: str = None,
                    city: str = None,
                    country: str = None,
                    upload_bandwidth: int | None = None,
                    download_bandwidth: int | None = None,
                    firewall: bool = None,
                    ips_control: bool = None,
                    acceptable_use_policy: bool = None,
                    vpn_credentials: list[VpnCredentialsItem] = None,
                    tunnels: list[TunnelsItem] = None,
                ) -> None:
                    """
                    InternetExitPoliciesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        type: type
                        city: city
                        country: country
                        upload_bandwidth: upload_bandwidth
                        download_bandwidth: download_bandwidth
                        firewall: firewall
                        ips_control: ips_control
                        acceptable_use_policy: acceptable_use_policy
                        vpn_credentials: vpn_credentials
                        tunnels: tunnels

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Applications(AvdBase):
                class ProfilesItem(AvdBase):
                    class BuiltinApplicationsItem(AvdBase):
                        _fields = ("_custom_data", "name", "services")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        name: str | None = None
                        services: list[str] | None = None

                        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, services: list[str] | None = None) -> None:
                            """
                            BuiltinApplicationsItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                name: name
                                services: services

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class UserDefinedApplicationsItem(AvdBase):
                        _fields = ("_custom_data", "name")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        name: str | None = None

                        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None) -> None:
                            """
                            UserDefinedApplicationsItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                name: name

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class CategoriesItem(AvdBase):
                        _fields = ("_custom_data", "category", "services")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        category: str | None = None
                        services: list[str] | None = None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | None = None, category: str | None = None, services: list[str] | None = None
                        ) -> None:
                            """
                            CategoriesItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                category: category
                                services: services

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "name", "builtin_applications", "user_defined_applications", "categories", "transport_protocols")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    name: str | None = None
                    builtin_applications: list[BuiltinApplicationsItem] | None = None
                    user_defined_applications: list[UserDefinedApplicationsItem] | None = None
                    categories: list[CategoriesItem] | None = None
                    transport_protocols: list[str] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        name: str | None = None,
                        builtin_applications: list[BuiltinApplicationsItem] | None = None,
                        user_defined_applications: list[UserDefinedApplicationsItem] | None = None,
                        categories: list[CategoriesItem] | None = None,
                        transport_protocols: list[str] | None = None,
                    ) -> None:
                        """
                        ProfilesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: name
                            builtin_applications: builtin_applications
                            user_defined_applications: user_defined_applications
                            categories: categories
                            transport_protocols: transport_protocols

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Categories(AvdBase):
                    class BuiltinApplicationsItem(AvdBase):
                        _fields = ("_custom_data", "name", "category", "services")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        name: str | None = None
                        category: str | None = None
                        services: list[str] | None = None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            name: str | None = None,
                            category: str | None = None,
                            services: list[str] | None = None,
                        ) -> None:
                            """
                            BuiltinApplicationsItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                name: name
                                category: category
                                services: services

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class UserDefinedApplicationsItem(AvdBase):
                        _fields = ("_custom_data", "name", "category")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        name: str | None = None
                        category: str | None = None

                        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, category: str | None = None) -> None:
                            """
                            UserDefinedApplicationsItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                name: name
                                category: category

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "builtin_applications", "user_defined_applications")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    builtin_applications: list[BuiltinApplicationsItem] | None = None
                    user_defined_applications: list[UserDefinedApplicationsItem] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        builtin_applications: list[BuiltinApplicationsItem] | None = None,
                        user_defined_applications: list[UserDefinedApplicationsItem] | None = None,
                    ) -> None:
                        """
                        Categories.

                        Args:
                        -----
                            _custom_data: _custom_data
                            builtin_applications: builtin_applications
                            user_defined_applications: user_defined_applications

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "profiles", "categories")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                profiles: list[ProfilesItem] | None = None
                categories: Categories | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, profiles: list[ProfilesItem] | None = None, categories: Categories | None = None
                ) -> None:
                    """
                    Applications.

                    Args:
                    -----
                        _custom_data: _custom_data
                        profiles: profiles
                        categories: categories

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = (
                "_custom_data",
                "role",
                "region",
                "zone",
                "site",
                "vtep_ip",
                "ssl_profile",
                "address",
                "pathfinders",
                "interfaces",
                "pathgroups",
                "regions",
                "vrfs",
                "internet_exit_policies",
                "applications",
            )
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            role: str | None = None
            region: str | None = None
            zone: str | None = None
            site: str | None = None
            vtep_ip: str | None = None
            ssl_profile: str | None = None
            address: str | None = None
            pathfinders: list[PathfindersItem] | None = None
            interfaces: list[InterfacesItem] | None = None
            pathgroups: list[PathgroupsItem] | None = None
            regions: list[RegionsItem] | None = None
            vrfs: list[VrfsItem] | None = None
            internet_exit_policies: list[InternetExitPoliciesItem] | None = None
            applications: Applications | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                role: str | None = None,
                region: str | None = None,
                zone: str | None = None,
                site: str | None = None,
                vtep_ip: str | None = None,
                ssl_profile: str | None = None,
                address: str | None = None,
                pathfinders: list[PathfindersItem] | None = None,
                interfaces: list[InterfacesItem] | None = None,
                pathgroups: list[PathgroupsItem] | None = None,
                regions: list[RegionsItem] | None = None,
                vrfs: list[VrfsItem] | None = None,
                internet_exit_policies: list[InternetExitPoliciesItem] | None = None,
                applications: Applications | None = None,
            ) -> None:
                """
                CvPathfinder.

                Args:
                -----
                    _custom_data: _custom_data
                    role: role
                    region: region
                    zone: zone
                    site: site
                    vtep_ip: vtep_ip
                    ssl_profile: ssl_profile
                    address: address
                    pathfinders: pathfinders
                    interfaces: interfaces
                    pathgroups: pathgroups
                    regions: regions
                    vrfs: vrfs
                    internet_exit_policies: internet_exit_policies
                    applications: applications

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "platform", "system_mac_address", "cv_tags", "cv_pathfinder")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        platform: str | None = None
        system_mac_address: str | None = None
        cv_tags: CvTags | None = None
        cv_pathfinder: CvPathfinder | None = None
        """Metadata used for CV Pathfinder visualization on CloudVision."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            platform: str | None = None,
            system_mac_address: str | None = None,
            cv_tags: CvTags | None = None,
            cv_pathfinder: CvPathfinder | None = None,
        ) -> None:
            """
            Metadata.

            Args:
            -----
                _custom_data: _custom_data
                platform: platform
                system_mac_address: system_mac_address
                cv_tags: cv_tags
                cv_pathfinder: Metadata used for CV Pathfinder visualization on CloudVision.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MlagConfiguration(AvdBase):
        class PeerAddressHeartbeat(AvdBase):
            _fields = ("_custom_data", "peer_ip", "vrf")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            peer_ip: str | None = None
            """IPv4 or IPv6 Address."""
            vrf: str | None = None
            """VRF Name."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, peer_ip: str | None = None, vrf: str | None = None) -> None:
                """
                PeerAddressHeartbeat.

                Args:
                -----
                    _custom_data: _custom_data
                    peer_ip: IPv4 or IPv6 Address.
                    vrf: VRF Name.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "domain_id",
            "heartbeat_interval",
            "local_interface",
            "peer_address",
            "peer_address_heartbeat",
            "dual_primary_detection_delay",
            "dual_primary_recovery_delay_mlag",
            "dual_primary_recovery_delay_non_mlag",
            "peer_link",
            "reload_delay_mlag",
            "reload_delay_non_mlag",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        domain_id: str | None = None
        heartbeat_interval: int | None = None
        """Heartbeat interval in milliseconds."""
        local_interface: str | None = None
        """Local Interface Name."""
        peer_address: str | None = None
        """IPv4 or IPv6 Address."""
        peer_address_heartbeat: PeerAddressHeartbeat | None = None
        dual_primary_detection_delay: Annotated[int, Max[86400]] | None = None
        """Delay in seconds."""
        dual_primary_recovery_delay_mlag: Annotated[int, Max[86400]] | None = None
        """Delay in seconds."""
        dual_primary_recovery_delay_non_mlag: Annotated[int, Max[86400]] | None = None
        """Delay in seconds."""
        peer_link: str | None = None
        """Port-Channel interface name."""
        reload_delay_mlag: str | None = None
        """Delay in seconds <0-86400> or 'infinity'."""
        reload_delay_non_mlag: str | None = None
        """Delay in seconds <0-86400> or 'infinity'."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            domain_id: str | None = None,
            heartbeat_interval: int | None = None,
            local_interface: str | None = None,
            peer_address: str | None = None,
            peer_address_heartbeat: PeerAddressHeartbeat | None = None,
            dual_primary_detection_delay: Annotated[int, Max[86400]] | None = None,
            dual_primary_recovery_delay_mlag: Annotated[int, Max[86400]] | None = None,
            dual_primary_recovery_delay_non_mlag: Annotated[int, Max[86400]] | None = None,
            peer_link: str | None = None,
            reload_delay_mlag: str | None = None,
            reload_delay_non_mlag: str | None = None,
        ) -> None:
            """
            MlagConfiguration.

            Args:
            -----
                _custom_data: _custom_data
                domain_id: domain_id
                heartbeat_interval: Heartbeat interval in milliseconds.
                local_interface: Local Interface Name.
                peer_address: IPv4 or IPv6 Address.
                peer_address_heartbeat: peer_address_heartbeat
                dual_primary_detection_delay: Delay in seconds.
                dual_primary_recovery_delay_mlag: Delay in seconds.
                dual_primary_recovery_delay_non_mlag: Delay in seconds.
                peer_link: Port-Channel interface name.
                reload_delay_mlag: Delay in seconds <0-86400> or 'infinity'.
                reload_delay_non_mlag: Delay in seconds <0-86400> or 'infinity'.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MonitorConnectivity(AvdBase):
        class InterfaceSetsItem(AvdBase):
            _fields = ("_custom_data", "name", "interfaces")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str | None = None
            interfaces: str | None = None
            """
            Interface range(s) should be of same type, Ethernet, Loopback, Management etc.
            Multiple interface
            ranges can be specified separated by ",".
            """

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, interfaces: str | None = None) -> None:
                """
                InterfaceSetsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    interfaces:
                       Interface range(s) should be of same type, Ethernet, Loopback, Management etc.
                       Multiple interface
                       ranges can be specified separated by ",".

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class HostsItem(AvdBase):
            _fields = ("_custom_data", "name", "description", "ip", "local_interfaces", "address_only", "url")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Host Name."""
            description: str | None = None
            ip: str | None = None
            local_interfaces: str | None = None
            address_only: bool | None = True
            """
            When address-only is configured, the source IP of the packet is set to the interface
            IP but the
            packet may exit the device via a different interface.
            When set to `false`, the probe uses the
            interface to exit the device.
            """
            url: str | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                description: str | None = None,
                ip: str | None = None,
                local_interfaces: str | None = None,
                address_only: bool | None = True,
                url: str | None = None,
            ) -> None:
                """
                HostsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Host Name.
                    description: description
                    ip: ip
                    local_interfaces: local_interfaces
                    address_only:
                       When address-only is configured, the source IP of the packet is set to the interface
                       IP but the
                       packet may exit the device via a different interface.
                       When set to `false`, the probe uses the
                       interface to exit the device.
                    url: url

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrfsItem(AvdBase):
            class InterfaceSetsItem(AvdBase):
                _fields = ("_custom_data", "name", "interfaces")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str | None = None
                interfaces: str | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, interfaces: str | None = None) -> None:
                    """
                    InterfaceSetsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        interfaces: interfaces

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class HostsItem(AvdBase):
                _fields = ("_custom_data", "name", "description", "ip", "local_interfaces", "address_only", "url")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Host name."""
                description: str | None = None
                ip: str | None = None
                local_interfaces: str | None = None
                address_only: bool | None = True
                """
                When address-only is configured, the source IP of the packet is set to the interface
                IP but the
                packet may exit the device via a different interface.
                When set to `false`, the probe uses the
                interface to exit the device.
                """
                url: str | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    description: str | None = None,
                    ip: str | None = None,
                    local_interfaces: str | None = None,
                    address_only: bool | None = True,
                    url: str | None = None,
                ) -> None:
                    """
                    HostsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Host name.
                        description: description
                        ip: ip
                        local_interfaces: local_interfaces
                        address_only:
                           When address-only is configured, the source IP of the packet is set to the interface
                           IP but the
                           packet may exit the device via a different interface.
                           When set to `false`, the probe uses the
                           interface to exit the device.
                        url: url

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "description", "interface_sets", "local_interfaces", "address_only", "hosts")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """VRF Name."""
            description: str | None = None
            interface_sets: list[InterfaceSetsItem] | None = None
            local_interfaces: str | None = None
            address_only: bool | None = True
            """
            When address-only is configured, the source IP of the packet is set to the interface
            IP but the
            packet may exit the device via a different interface.
            When set to `false`, the probe uses the
            interface to exit the device.
            """
            hosts: list[HostsItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                description: str | None = None,
                interface_sets: list[InterfaceSetsItem] | None = None,
                local_interfaces: str | None = None,
                address_only: bool | None = True,
                hosts: list[HostsItem] | None = None,
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF Name.
                    description: description
                    interface_sets: interface_sets
                    local_interfaces: local_interfaces
                    address_only:
                       When address-only is configured, the source IP of the packet is set to the interface
                       IP but the
                       packet may exit the device via a different interface.
                       When set to `false`, the probe uses the
                       interface to exit the device.
                    hosts: hosts

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "shutdown", "interval", "interface_sets", "local_interfaces", "address_only", "hosts", "vrfs")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        shutdown: bool | None = None
        interval: int | None = None
        interface_sets: list[InterfaceSetsItem] | None = None
        local_interfaces: str | None = None
        address_only: bool | None = True
        """
        When address-only is configured, the source IP of the packet is set to the interface
        IP but the
        packet may exit the device via a different interface.
        When set to `false`, the probe uses the
        interface to exit the device.
        """
        hosts: list[HostsItem] | None = None
        vrfs: list[VrfsItem] | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            shutdown: bool | None = None,
            interval: int | None = None,
            interface_sets: list[InterfaceSetsItem] | None = None,
            local_interfaces: str | None = None,
            address_only: bool | None = True,
            hosts: list[HostsItem] | None = None,
            vrfs: list[VrfsItem] | None = None,
        ) -> None:
            """
            MonitorConnectivity.

            Args:
            -----
                _custom_data: _custom_data
                shutdown: shutdown
                interval: interval
                interface_sets: interface_sets
                local_interfaces: local_interfaces
                address_only:
                   When address-only is configured, the source IP of the packet is set to the interface
                   IP but the
                   packet may exit the device via a different interface.
                   When set to `false`, the probe uses the
                   interface to exit the device.
                hosts: hosts
                vrfs: vrfs

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MonitorLayer1(AvdBase):
        class LoggingTransceiver(AvdBase):
            _fields = ("_custom_data", "dom", "communication", "enabled")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            dom: bool | None = None
            """Enable transceiver Digital Optical Monitoring (DOM) logging."""
            communication: bool | None = None
            """Enable transceiver SMBus fail and reset logging."""
            enabled: bool | None = None
            """
            Some platforms support only the `logging transceiver` command. `enabled` key configures this
            command.
            """

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, dom: bool | None = None, communication: bool | None = None, enabled: bool | None = None
            ) -> None:
                """
                LoggingTransceiver.

                Args:
                -----
                    _custom_data: _custom_data
                    dom: Enable transceiver Digital Optical Monitoring (DOM) logging.
                    communication: Enable transceiver SMBus fail and reset logging.
                    enabled:
                       Some platforms support only the `logging transceiver` command. `enabled` key configures this
                       command.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "enabled", "logging_mac_fault", "logging_transceiver")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        enabled: bool = None
        """Enable monitor layer1."""
        logging_mac_fault: bool | None = None
        """Enable MAC fault logging."""
        logging_transceiver: LoggingTransceiver | None = None
        """Configure transceiver monitoring logging."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            enabled: bool = None,
            logging_mac_fault: bool | None = None,
            logging_transceiver: LoggingTransceiver | None = None,
        ) -> None:
            """
            MonitorLayer1.

            Args:
            -----
                _custom_data: _custom_data
                enabled: Enable monitor layer1.
                logging_mac_fault: Enable MAC fault logging.
                logging_transceiver: Configure transceiver monitoring logging.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MonitorSessionDefaultEncapsulationGre(AvdBase):
        _fields = ("_custom_data", "payload")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        payload: Annotated[str, ValidValues["full-packet", "inner-packet"]] | None = None
        """Mirroring GRE payload type configuration commands."""

        def __init__(
            self, *, _custom_data: dict[str, Any] | None = None, payload: Annotated[str, ValidValues["full-packet", "inner-packet"]] | None = None
        ) -> None:
            """
            MonitorSessionDefaultEncapsulationGre.

            Args:
            -----
                _custom_data: _custom_data
                payload: Mirroring GRE payload type configuration commands.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MonitorSessionsItem(AvdBase):
        class SourcesItem(AvdBase):
            class AccessGroup(AvdBase):
                _fields = ("_custom_data", "type", "name", "priority")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                type: Annotated[str, ValidValues["ip", "ipv6", "mac"]] | None = None
                name: str | None = None
                """ACL Name."""
                priority: int | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    type: Annotated[str, ValidValues["ip", "ipv6", "mac"]] | None = None,
                    name: str | None = None,
                    priority: int | None = None,
                ) -> None:
                    """
                    AccessGroup.

                    Args:
                    -----
                        _custom_data: _custom_data
                        type: type
                        name: ACL Name.
                        priority: priority

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "direction", "access_group")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str | None = None
            """Interface name, range or comma separated list."""
            direction: Annotated[str, ValidValues["rx", "tx", "both"]] | None = None
            access_group: AccessGroup | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str | None = None,
                direction: Annotated[str, ValidValues["rx", "tx", "both"]] | None = None,
                access_group: AccessGroup | None = None,
            ) -> None:
                """
                SourcesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Interface name, range or comma separated list.
                    direction: direction
                    access_group: access_group

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AccessGroup(AvdBase):
            _fields = ("_custom_data", "type", "name")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            type: Annotated[str, ValidValues["ip", "ipv6", "mac"]] | None = None
            name: str | None = None
            """ACL Name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                type: Annotated[str, ValidValues["ip", "ipv6", "mac"]] | None = None,
                name: str | None = None,
            ) -> None:
                """
                AccessGroup.

                Args:
                -----
                    _custom_data: _custom_data
                    type: type
                    name: ACL Name.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Truncate(AvdBase):
            _fields = ("_custom_data", "enabled", "size")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool | None = None
            size: int | None = None
            """Size in bytes."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, size: int | None = None) -> None:
                """
                Truncate.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    size: Size in bytes.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "name",
            "sources",
            "destinations",
            "encapsulation_gre_metadata_tx",
            "header_remove_size",
            "access_group",
            "rate_limit_per_ingress_chip",
            "rate_limit_per_egress_chip",
            "sample",
            "truncate",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Session Name."""
        sources: list[SourcesItem] | None = None
        destinations: list[str] | None = None
        encapsulation_gre_metadata_tx: bool | None = None
        header_remove_size: int | None = None
        """Number of bytes to remove from header."""
        access_group: AccessGroup | None = None
        rate_limit_per_ingress_chip: str | None = None
        """
        Ratelimit and unit as string.
        Examples:
          "100000 bps"
          "100 kbps"
          "10 mbps"
        """
        rate_limit_per_egress_chip: str | None = None
        """
        Ratelimit and unit as string.
        Examples:
          "100000 bps"
          "100 kbps"
          "10 mbps"
        """
        sample: int | None = None
        truncate: Truncate | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str = None,
            sources: list[SourcesItem] | None = None,
            destinations: list[str] | None = None,
            encapsulation_gre_metadata_tx: bool | None = None,
            header_remove_size: int | None = None,
            access_group: AccessGroup | None = None,
            rate_limit_per_ingress_chip: str | None = None,
            rate_limit_per_egress_chip: str | None = None,
            sample: int | None = None,
            truncate: Truncate | None = None,
        ) -> None:
            """
            MonitorSessionsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Session Name.
                sources: sources
                destinations: destinations
                encapsulation_gre_metadata_tx: encapsulation_gre_metadata_tx
                header_remove_size: Number of bytes to remove from header.
                access_group: access_group
                rate_limit_per_ingress_chip:
                   Ratelimit and unit as string.

            Examples:
                     "100000 bps"
                     "100 kbps"
                     "10 mbps"
                rate_limit_per_egress_chip:
                   Ratelimit and unit as string.

            Examples:
                     "100000 bps"
                     "100 kbps"
                     "10 mbps"
                sample: sample
                truncate: truncate

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MonitorTelemetryInflux(AvdBase):
        class DestinationsItem(AvdBase):
            _fields = ("_custom_data", "name", "database", "data_retention_policy", "url", "username", "password", "password_type")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """InfluxDB connection name."""
            database: str | None = None
            """Set name of the database."""
            data_retention_policy: str | None = None
            url: Annotated[str, Pattern[r"(http(s)?|udp|unix)://.+"]] | None = None
            """It only accepts http(s), udp and unix domain destination URL."""
            username: str | None = None
            password: str | None = None
            password_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = "7"

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                database: str | None = None,
                data_retention_policy: str | None = None,
                url: Annotated[str, Pattern[r"(http(s)?|udp|unix)://.+"]] | None = None,
                username: str | None = None,
                password: str | None = None,
                password_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = "7",
            ) -> None:
                """
                DestinationsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: InfluxDB connection name.
                    database: Set name of the database.
                    data_retention_policy: data_retention_policy
                    url: It only accepts http(s), udp and unix domain destination URL.
                    username: username
                    password: password
                    password_type: password_type

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SourceSocketsItem(AvdBase):
            _fields = ("_custom_data", "name", "connection_limit", "url")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Label of the socket connection."""
            connection_limit: Annotated[int, Max[4294967295]] | None = None
            url: Annotated[str, Pattern[r"(http(s)?|udp|unix)://.+"]] | None = None
            """It only accepts http(s), udp and unix domain socket URL."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                connection_limit: Annotated[int, Max[4294967295]] | None = None,
                url: Annotated[str, Pattern[r"(http(s)?|udp|unix)://.+"]] | None = None,
            ) -> None:
                """
                SourceSocketsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Label of the socket connection.
                    connection_limit: connection_limit
                    url: It only accepts http(s), udp and unix domain socket URL.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TagsItem(AvdBase):
            _fields = ("_custom_data", "name", "value")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Key of the global tag pair."""
            value: str = None
            """Value of the global tag pair."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, value: str = None) -> None:
                """
                TagsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Key of the global tag pair.
                    value: Value of the global tag pair.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "vrf", "destinations", "source_group_standard_disabled", "source_sockets", "tags")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        vrf: str | None = None
        destinations: list[DestinationsItem] | None = None
        """Configure telemetry output destinations."""
        source_group_standard_disabled: bool | None = None
        """Disable standard set of telemetry."""
        source_sockets: list[SourceSocketsItem] | None = None
        tags: list[TagsItem] | None = None
        """Extra tags added to the telemetry output."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            vrf: str | None = None,
            destinations: list[DestinationsItem] | None = None,
            source_group_standard_disabled: bool | None = None,
            source_sockets: list[SourceSocketsItem] | None = None,
            tags: list[TagsItem] | None = None,
        ) -> None:
            """
            MonitorTelemetryInflux.

            Args:
            -----
                _custom_data: _custom_data
                vrf: vrf
                destinations: Configure telemetry output destinations.
                source_group_standard_disabled: Disable standard set of telemetry.
                source_sockets: source_sockets
                tags: Extra tags added to the telemetry output.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MonitorTelemetryPostcardPolicy(AvdBase):
        class Ingress(AvdBase):
            class Collection(AvdBase):
                _fields = ("_custom_data", "source", "destination", "version")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                source: str | None = None
                """Source IP address of GRE tunnel."""
                destination: str | None = None
                """Destination IP address of GRE tunnel."""
                version: Annotated[int, ValidValues[1, 2]] | None = None
                """Postcard version."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    source: str | None = None,
                    destination: str | None = None,
                    version: Annotated[int, ValidValues[1, 2]] | None = None,
                ) -> None:
                    """
                    Collection.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source: Source IP address of GRE tunnel.
                        destination: Destination IP address of GRE tunnel.
                        version: Postcard version.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Sample(AvdBase):
                class TcpUdpChecksum(AvdBase):
                    _fields = ("_custom_data", "value", "mask")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    value: Annotated[int, Max[65535]] | None = None
                    """TCP/UDP checksum or IP ID value."""
                    mask: str | None = None
                    """16 bit hexadecimal mask for TCP/UDP or IP ID with at most 2 unset bits."""

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, value: Annotated[int, Max[65535]] | None = None, mask: str | None = None
                    ) -> None:
                        """
                        TcpUdpChecksum.

                        Args:
                        -----
                            _custom_data: _custom_data
                            value: TCP/UDP checksum or IP ID value.
                            mask: 16 bit hexadecimal mask for TCP/UDP or IP ID with at most 2 unset bits.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "rate", "tcp_udp_checksum")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                rate: Annotated[int, ValidValues[16384, 32768, 65536]] | None = None
                """Sampling rate. `rate` is preferred when both `rate` and `tcp_udp_checksum` are defined."""
                tcp_udp_checksum: TcpUdpChecksum | None = None
                """TCP/UDP parameters."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    rate: Annotated[int, ValidValues[16384, 32768, 65536]] | None = None,
                    tcp_udp_checksum: TcpUdpChecksum | None = None,
                ) -> None:
                    """
                    Sample.

                    Args:
                    -----
                        _custom_data: _custom_data
                        rate: Sampling rate. `rate` is preferred when both `rate` and `tcp_udp_checksum` are defined.
                        tcp_udp_checksum: TCP/UDP parameters.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "collection", "sample")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            collection: Collection | None = None
            """Collector configuration."""
            sample: Sample | None = None
            """Sampling parameters."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, collection: Collection | None = None, sample: Sample | None = None) -> None:
                """
                Ingress.

                Args:
                -----
                    _custom_data: _custom_data
                    collection: Collector configuration.
                    sample: Sampling parameters.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class MarkerVxlan(AvdBase):
            _fields = ("_custom_data", "enabled", "header_word_zero_bit")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool | None = None
            """Enable vxlan marking using default bit 0."""
            header_word_zero_bit: Annotated[int, Min[1], Max[31]] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enabled: bool | None = None,
                header_word_zero_bit: Annotated[int, Min[1], Max[31]] | None = None,
            ) -> None:
                """
                MarkerVxlan.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: Enable vxlan marking using default bit 0.
                    header_word_zero_bit: header_word_zero_bit

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ProfilesItem(AvdBase):
            _fields = ("_custom_data", "name", "ingress_sample_policy")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Profile name."""
            ingress_sample_policy: str | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, ingress_sample_policy: str | None = None) -> None:
                """
                ProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Profile name.
                    ingress_sample_policy: ingress_sample_policy

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SamplePoliciesItem(AvdBase):
            class MatchRulesItem(AvdBase):
                class ProtocolsItem(AvdBase):
                    _fields = ("_custom_data", "protocol", "source_ports", "destination_ports")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    protocol: Annotated[str, ValidValues["tcp", "udp"]] = None
                    source_ports: list[str] | None = None
                    """
                    A list of port numbers or port range or port name. Combination of port numbers or range and port
                    name is not supported on EOS. The port numbers should be in range of 0-65535.
                    e.g.
                      [ "12", "14-20"
                    ]
                      [ "www" ]
                    """
                    destination_ports: list[str] | None = None
                    """
                    A list of port numbers or port range or port name. Combination of port numbers or range and port
                    name is not supported on EOS. The port numbers should be in range of 0-65535.
                    e.g.
                      [ "12",
                    "14-20", "80" ]
                      [ "https" ]
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        protocol: Annotated[str, ValidValues["tcp", "udp"]] = None,
                        source_ports: list[str] | None = None,
                        destination_ports: list[str] | None = None,
                    ) -> None:
                        """
                        ProtocolsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            protocol: protocol
                            source_ports:
                               A list of port numbers or port range or port name. Combination of port numbers or range and port
                               name is not supported on EOS. The port numbers should be in range of 0-65535.
                               e.g.
                                 [ "12", "14-20"
                               ]
                                 [ "www" ]
                            destination_ports:
                               A list of port numbers or port range or port name. Combination of port numbers or range and port
                               name is not supported on EOS. The port numbers should be in range of 0-65535.
                               e.g.
                                 [ "12",
                               "14-20", "80" ]
                                 [ "https" ]

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "name", "type", "destination_prefix", "source_prefix", "protocols")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                type: Annotated[str, ValidValues["ipv4", "ipv6"]] = None
                """IP address version."""
                destination_prefix: str | None = None
                """
                IPv4 Network/Mask or IPv6 Network/Mask. Host part of prefix must be zero.
                eg. 10.3.3.0/24
                """
                source_prefix: str | None = None
                """
                IPv4 Network/Mask or IPv6 Network/Mask. Host part of prefix must be zero.
                eg. 10.3.3.0/24
                """
                protocols: list[ProtocolsItem] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    type: Annotated[str, ValidValues["ipv4", "ipv6"]] = None,
                    destination_prefix: str | None = None,
                    source_prefix: str | None = None,
                    protocols: list[ProtocolsItem] | None = None,
                ) -> None:
                    """
                    MatchRulesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        type: IP address version.
                        destination_prefix:
                           IPv4 Network/Mask or IPv6 Network/Mask. Host part of prefix must be zero.
                           eg. 10.3.3.0/24
                        source_prefix:
                           IPv4 Network/Mask or IPv6 Network/Mask. Host part of prefix must be zero.
                           eg. 10.3.3.0/24
                        protocols: protocols

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "match_rules")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            match_rules: list[MatchRulesItem] | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, match_rules: list[MatchRulesItem] | None = None) -> None:
                """
                SamplePoliciesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    match_rules: match_rules

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "disabled", "ingress", "marker_vxlan", "profiles", "sample_policies")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        disabled: bool | None = True
        """Enable or disable the postcard telemetry feature."""
        ingress: Ingress | None = None
        marker_vxlan: MarkerVxlan | None = None
        profiles: list[ProfilesItem] | None = None
        """Postcard telemetry profiles."""
        sample_policies: list[SamplePoliciesItem] | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            disabled: bool | None = True,
            ingress: Ingress | None = None,
            marker_vxlan: MarkerVxlan | None = None,
            profiles: list[ProfilesItem] | None = None,
            sample_policies: list[SamplePoliciesItem] | None = None,
        ) -> None:
            """
            MonitorTelemetryPostcardPolicy.

            Args:
            -----
                _custom_data: _custom_data
                disabled: Enable or disable the postcard telemetry feature.
                ingress: ingress
                marker_vxlan: marker_vxlan
                profiles: Postcard telemetry profiles.
                sample_policies: sample_policies

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Mpls(AvdBase):
        class Ldp(AvdBase):
            _fields = ("_custom_data", "interface_disabled_default", "router_id", "shutdown", "transport_address_interface")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            interface_disabled_default: bool | None = None
            router_id: str | None = None
            shutdown: bool | None = None
            transport_address_interface: str | None = None
            """Interface Name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                interface_disabled_default: bool | None = None,
                router_id: str | None = None,
                shutdown: bool | None = None,
                transport_address_interface: str | None = None,
            ) -> None:
                """
                Ldp.

                Args:
                -----
                    _custom_data: _custom_data
                    interface_disabled_default: interface_disabled_default
                    router_id: router_id
                    shutdown: shutdown
                    transport_address_interface: Interface Name.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Icmp(AvdBase):
            _fields = ("_custom_data", "fragmentation_needed_tunneling", "ttl_exceeded_tunneling")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            fragmentation_needed_tunneling: bool | None = None
            """Enables the MPLS tunneling of MTU exceeded ICMP replies (fragmentation needed, packet too big)."""
            ttl_exceeded_tunneling: bool | None = None
            """Enables the MPLS tunneling of TTL exceeded ICMP replies."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                fragmentation_needed_tunneling: bool | None = None,
                ttl_exceeded_tunneling: bool | None = None,
            ) -> None:
                """
                Icmp.

                Args:
                -----
                    _custom_data: _custom_data
                    fragmentation_needed_tunneling: Enables the MPLS tunneling of MTU exceeded ICMP replies (fragmentation needed, packet too big).
                    ttl_exceeded_tunneling: Enables the MPLS tunneling of TTL exceeded ICMP replies.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "ip", "ldp", "icmp")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        ip: bool | None = None
        ldp: Ldp | None = None
        icmp: Icmp | None = None
        """Enables the LSRs to generate ICMP reply messages and deliver them to the originating host."""

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, ip: bool | None = None, ldp: Ldp | None = None, icmp: Icmp | None = None) -> None:
            """
            Mpls.

            Args:
            -----
                _custom_data: _custom_data
                ip: ip
                ldp: ldp
                icmp: Enables the LSRs to generate ICMP reply messages and deliver them to the originating host.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Ntp(AvdBase):
        class LocalInterface(AvdBase):
            _fields = ("_custom_data", "name", "vrf")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str | None = None
            """Source interface."""
            vrf: str | None = None
            """VRF name."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, vrf: str | None = None) -> None:
                """
                LocalInterface.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Source interface.
                    vrf: VRF name.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ServersItem(AvdBase):
            _fields = ("_custom_data", "name", "burst", "iburst", "key", "local_interface", "maxpoll", "minpoll", "preferred", "version", "vrf")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str | None = None
            """IP or hostname e.g., 2.2.2.55, 2001:db8::55, ie.pool.ntp.org."""
            burst: bool | None = None
            iburst: bool | None = None
            key: Annotated[int, Min[1], Max[65535]] | None = None
            local_interface: str | None = None
            """Source interface."""
            maxpoll: Annotated[int, Min[3], Max[17]] | None = None
            """Value of maxpoll between 3 - 17 (Logarithmic)."""
            minpoll: Annotated[int, Min[3], Max[17]] | None = None
            """Value of minpoll between 3 - 17 (Logarithmic)."""
            preferred: bool | None = None
            version: Annotated[int, Min[1], Max[4]] | None = None
            vrf: str | None = None
            """VRF name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str | None = None,
                burst: bool | None = None,
                iburst: bool | None = None,
                key: Annotated[int, Min[1], Max[65535]] | None = None,
                local_interface: str | None = None,
                maxpoll: Annotated[int, Min[3], Max[17]] | None = None,
                minpoll: Annotated[int, Min[3], Max[17]] | None = None,
                preferred: bool | None = None,
                version: Annotated[int, Min[1], Max[4]] | None = None,
                vrf: str | None = None,
            ) -> None:
                """
                ServersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: IP or hostname e.g., 2.2.2.55, 2001:db8::55, ie.pool.ntp.org.
                    burst: burst
                    iburst: iburst
                    key: key
                    local_interface: Source interface.
                    maxpoll: Value of maxpoll between 3 - 17 (Logarithmic).
                    minpoll: Value of minpoll between 3 - 17 (Logarithmic).
                    preferred: preferred
                    version: version
                    vrf: VRF name.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AuthenticationKeysItem(AvdBase):
            _fields = ("_custom_data", "id", "hash_algorithm", "key", "key_type")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            id: Annotated[int, Min[1], Max[65534]] = None
            """Key identifier."""
            hash_algorithm: Annotated[str, ValidValues["md5", "sha1"]] | None = None
            key: str | None = None
            """Obfuscated key."""
            key_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                id: Annotated[int, Min[1], Max[65534]] = None,
                hash_algorithm: Annotated[str, ValidValues["md5", "sha1"]] | None = None,
                key: str | None = None,
                key_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = None,
            ) -> None:
                """
                AuthenticationKeysItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: Key identifier.
                    hash_algorithm: hash_algorithm
                    key: Obfuscated key.
                    key_type: key_type

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "local_interface", "servers", "authenticate", "authenticate_servers_only", "authentication_keys", "trusted_keys")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        local_interface: LocalInterface | None = None
        servers: list[ServersItem] | None = None
        authenticate: bool | None = None
        authenticate_servers_only: bool | None = None
        authentication_keys: list[AuthenticationKeysItem] | None = None
        trusted_keys: str | None = None
        """List of trusted-keys as string ex. 10-12,15."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            local_interface: LocalInterface | None = None,
            servers: list[ServersItem] | None = None,
            authenticate: bool | None = None,
            authenticate_servers_only: bool | None = None,
            authentication_keys: list[AuthenticationKeysItem] | None = None,
            trusted_keys: str | None = None,
        ) -> None:
            """
            Ntp.

            Args:
            -----
                _custom_data: _custom_data
                local_interface: local_interface
                servers: servers
                authenticate: authenticate
                authenticate_servers_only: authenticate_servers_only
                authentication_keys: authentication_keys
                trusted_keys: List of trusted-keys as string ex. 10-12,15.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class PatchPanel(AvdBase):
        class Connector(AvdBase):
            class Interface(AvdBase):
                class Patch(AvdBase):
                    _fields = ("_custom_data", "bgp_vpws_remote_failure_errdisable")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    bgp_vpws_remote_failure_errdisable: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, bgp_vpws_remote_failure_errdisable: bool | None = None) -> None:
                        """
                        Patch.

                        Args:
                        -----
                            _custom_data: _custom_data
                            bgp_vpws_remote_failure_errdisable: bgp_vpws_remote_failure_errdisable

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Recovery(AvdBase):
                    class ReviewDelay(AvdBase):
                        _fields = ("_custom_data", "min", "max")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        min: Annotated[int, Min[10], Max[600]] = None
                        """Minimum delay."""
                        max: Annotated[int, Min[15], Max[900]] = None
                        """Maximum delay."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            min: Annotated[int, Min[10], Max[600]] = None,
                            max: Annotated[int, Min[15], Max[900]] = None,
                        ) -> None:
                            """
                            ReviewDelay.

                            Args:
                            -----
                                _custom_data: _custom_data
                                min: Minimum delay.
                                max: Maximum delay.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "review_delay")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    review_delay: ReviewDelay | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, review_delay: ReviewDelay | None = None) -> None:
                        """
                        Recovery.

                        Args:
                        -----
                            _custom_data: _custom_data
                            review_delay: review_delay

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "patch", "recovery")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                patch: Patch | None = None
                recovery: Recovery | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, patch: Patch | None = None, recovery: Recovery | None = None) -> None:
                    """
                    Interface.

                    Args:
                    -----
                        _custom_data: _custom_data
                        patch: patch
                        recovery: recovery

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "interface")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            interface: Interface | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, interface: Interface | None = None) -> None:
                """
                Connector.

                Args:
                -----
                    _custom_data: _custom_data
                    interface: interface

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PatchesItem(AvdBase):
            class ConnectorsItem(AvdBase):
                _fields = ("_custom_data", "id", "type", "endpoint")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                id: str = None
                type: Annotated[str, ValidValues["interface", "pseudowire"]] = None
                endpoint: str = None
                """
                String with relevant endpoint depending on type.
                Examples:
                - "Ethernet1"
                - "Ethernet1 dot1q vlan
                123"
                - "bgp vpws TENANT_A pseudowire VPWS_PW_1"
                - "ldp LDP_PW_1"
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    id: str = None,
                    type: Annotated[str, ValidValues["interface", "pseudowire"]] = None,
                    endpoint: str = None,
                ) -> None:
                    """
                    ConnectorsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        id: id
                        type: type
                        endpoint:
                           String with relevant endpoint depending on type.

                    Examples:
                           - "Ethernet1"
                           - "Ethernet1 dot1q vlan
                           123"
                           - "bgp vpws TENANT_A pseudowire VPWS_PW_1"
                           - "ldp LDP_PW_1"

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "enabled", "connectors")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            enabled: bool | None = None
            connectors: list[ConnectorsItem] | None = None
            """Must have exactly two connectors to a patch of which at least one must be of type "interface"."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                enabled: bool | None = None,
                connectors: list[ConnectorsItem] | None = None,
            ) -> None:
                """
                PatchesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    enabled: enabled
                    connectors: Must have exactly two connectors to a patch of which at least one must be of type "interface".

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "connector", "patches")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        connector: Connector | None = None
        patches: list[PatchesItem] | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, connector: Connector | None = None, patches: list[PatchesItem] | None = None) -> None:
            """
            PatchPanel.

            Args:
            -----
                _custom_data: _custom_data
                connector: connector
                patches: patches

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class PeerFiltersItem(AvdBase):
        class SequenceNumbersItem(AvdBase):
            _fields = ("_custom_data", "sequence", "match")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            sequence: int = None
            """Sequence ID."""
            match: str = None
            """
            Match as string.
            Example: "as-range 1-100 result accept"
            """

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, sequence: int = None, match: str = None) -> None:
                """
                SequenceNumbersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: Sequence ID.
                    match:
                       Match as string.
                       Example: "as-range 1-100 result accept"

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "name", "sequence_numbers")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Peer-filter Name."""
        sequence_numbers: list[SequenceNumbersItem] = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, sequence_numbers: list[SequenceNumbersItem] = None) -> None:
            """
            PeerFiltersItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Peer-filter Name.
                sequence_numbers: sequence_numbers

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Platform(AvdBase):
        class Trident(AvdBase):
            class Mmu(AvdBase):
                class QueueProfilesItem(AvdBase):
                    class MulticastQueuesItem(AvdBase):
                        class Drop(AvdBase):
                            _fields = ("_custom_data", "precedence", "threshold")
                            _required_fields = ()
                            _custom_data: dict[str, Any] | None = None
                            precedence: Annotated[int, ValidValues[1, 2]] = None
                            threshold: str = None
                            """
                            Drop Threshold. This value may also be fractions.
                            Example: 7/8 or 3/4 or 1/2
                            """

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | None = None, precedence: Annotated[int, ValidValues[1, 2]] = None, threshold: str = None
                            ) -> None:
                                """
                                Drop.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    precedence: precedence
                                    threshold:
                                       Drop Threshold. This value may also be fractions.
                                       Example: 7/8 or 3/4 or 1/2

                                """
                                for arg, arg_value in locals().items():
                                    if arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields = ("_custom_data", "id", "unit", "reserved", "threshold", "drop")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        id: Annotated[int, Max[7]] = None
                        unit: Annotated[str, ValidValues["bytes", "cells"]] | None = None
                        """Unit to be used for the reservation value. If not specified, default is bytes."""
                        reserved: int | None = None
                        """
                        Amount of memory that should be reserved for this
                        queue.
                        """
                        threshold: str | None = None
                        """Dynamic Shared Memory threshold."""
                        drop: Drop | None = None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            id: Annotated[int, Max[7]] = None,
                            unit: Annotated[str, ValidValues["bytes", "cells"]] | None = None,
                            reserved: int | None = None,
                            threshold: str | None = None,
                            drop: Drop | None = None,
                        ) -> None:
                            """
                            MulticastQueuesItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                id: id
                                unit: Unit to be used for the reservation value. If not specified, default is bytes.
                                reserved:
                                   Amount of memory that should be reserved for this
                                   queue.
                                threshold: Dynamic Shared Memory threshold.
                                drop: drop

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class UnicastQueuesItem(AvdBase):
                        class Drop(AvdBase):
                            _fields = ("_custom_data", "precedence", "threshold")
                            _required_fields = ()
                            _custom_data: dict[str, Any] | None = None
                            precedence: Annotated[int, ValidValues[1, 2]] = None
                            threshold: str = None
                            """
                            Drop Threshold. This value may also be fractions.
                            Example: 7/8 or 3/4 or 1/2
                            """

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | None = None, precedence: Annotated[int, ValidValues[1, 2]] = None, threshold: str = None
                            ) -> None:
                                """
                                Drop.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    precedence: precedence
                                    threshold:
                                       Drop Threshold. This value may also be fractions.
                                       Example: 7/8 or 3/4 or 1/2

                                """
                                for arg, arg_value in locals().items():
                                    if arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields = ("_custom_data", "id", "unit", "reserved", "threshold", "drop")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        id: Annotated[int, Max[7]] = None
                        unit: Annotated[str, ValidValues["bytes", "cells"]] | None = None
                        """Unit to be used for the reservation value. If not specified, default is bytes."""
                        reserved: int | None = None
                        """
                        Amount of memory that should be reserved for this
                        queue.
                        """
                        threshold: str | None = None
                        """Dynamic Shared Memory threshold."""
                        drop: Drop | None = None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            id: Annotated[int, Max[7]] = None,
                            unit: Annotated[str, ValidValues["bytes", "cells"]] | None = None,
                            reserved: int | None = None,
                            threshold: str | None = None,
                            drop: Drop | None = None,
                        ) -> None:
                            """
                            UnicastQueuesItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                id: id
                                unit: Unit to be used for the reservation value. If not specified, default is bytes.
                                reserved:
                                   Amount of memory that should be reserved for this
                                   queue.
                                threshold: Dynamic Shared Memory threshold.
                                drop: drop

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "name", "multicast_queues", "unicast_queues")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    name: str = None
                    multicast_queues: list[MulticastQueuesItem] | None = None
                    unicast_queues: list[UnicastQueuesItem] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        name: str = None,
                        multicast_queues: list[MulticastQueuesItem] | None = None,
                        unicast_queues: list[UnicastQueuesItem] | None = None,
                    ) -> None:
                        """
                        QueueProfilesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: name
                            multicast_queues: multicast_queues
                            unicast_queues: unicast_queues

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "active_profile", "queue_profiles")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                active_profile: str | None = None
                """The queue profile to be applied to the platform."""
                queue_profiles: list[QueueProfilesItem] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    active_profile: str | None = None,
                    queue_profiles: list[QueueProfilesItem] | None = None,
                ) -> None:
                    """
                    Mmu.

                    Args:
                    -----
                        _custom_data: _custom_data
                        active_profile: The queue profile to be applied to the platform.
                        queue_profiles: queue_profiles

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "forwarding_table_partition", "mmu")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            forwarding_table_partition: str | None = None
            mmu: Mmu | None = None
            """Memory Management Unit settings."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, forwarding_table_partition: str | None = None, mmu: Mmu | None = None) -> None:
                """
                Trident.

                Args:
                -----
                    _custom_data: _custom_data
                    forwarding_table_partition: forwarding_table_partition
                    mmu: Memory Management Unit settings.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Sand(AvdBase):
            class QosMapsItem(AvdBase):
                _fields = ("_custom_data", "traffic_class", "to_network_qos")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                traffic_class: Annotated[int, Max[7]] | None = None
                to_network_qos: Annotated[int, Max[63]] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    traffic_class: Annotated[int, Max[7]] | None = None,
                    to_network_qos: Annotated[int, Max[63]] | None = None,
                ) -> None:
                    """
                    QosMapsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        traffic_class: traffic_class
                        to_network_qos: to_network_qos

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Lag(AvdBase):
                _fields = ("_custom_data", "hardware_only", "mode")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                hardware_only: bool | None = None
                mode: str | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, hardware_only: bool | None = None, mode: str | None = None) -> None:
                    """
                    Lag.

                    Args:
                    -----
                        _custom_data: _custom_data
                        hardware_only: hardware_only
                        mode: mode

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class MulticastReplication(AvdBase):
                _fields = ("_custom_data", "default")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                default: Annotated[str, ValidValues["ingress", "egress"]] | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, default: Annotated[str, ValidValues["ingress", "egress"]] | None = None
                ) -> None:
                    """
                    MulticastReplication.

                    Args:
                    -----
                        _custom_data: _custom_data
                        default: default

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "qos_maps", "lag", "forwarding_mode", "multicast_replication", "mdb_profile")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            qos_maps: list[QosMapsItem] | None = None
            lag: Lag | None = None
            forwarding_mode: str | None = None
            multicast_replication: MulticastReplication | None = None
            mdb_profile: Annotated[str, ValidValues["balanced", "balanced-xl", "l3", "l3-xl", "l3-xxl", "l3-xxxl"]] | None = None
            """Sand platforms MDB Profile configuration. Note: l3-xxxl does not support MLAG."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                qos_maps: list[QosMapsItem] | None = None,
                lag: Lag | None = None,
                forwarding_mode: str | None = None,
                multicast_replication: MulticastReplication | None = None,
                mdb_profile: Annotated[str, ValidValues["balanced", "balanced-xl", "l3", "l3-xl", "l3-xxl", "l3-xxxl"]] | None = None,
            ) -> None:
                """
                Sand.

                Args:
                -----
                    _custom_data: _custom_data
                    qos_maps: qos_maps
                    lag: lag
                    forwarding_mode: forwarding_mode
                    multicast_replication: multicast_replication
                    mdb_profile: Sand platforms MDB Profile configuration. Note: l3-xxxl does not support MLAG.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Sfe(AvdBase):
            _fields = ("_custom_data", "data_plane_cpu_allocation_max")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            data_plane_cpu_allocation_max: Annotated[int, Min[1], Max[128]] | None = None
            """Maximum number of CPUs used for data plane traffic forwarding."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, data_plane_cpu_allocation_max: Annotated[int, Min[1], Max[128]] | None = None
            ) -> None:
                """
                Sfe.

                Args:
                -----
                    _custom_data: _custom_data
                    data_plane_cpu_allocation_max: Maximum number of CPUs used for data plane traffic forwarding.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "trident", "sand", "sfe")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        trident: Trident | None = None
        sand: Sand | None = None
        """Most of the platform sand options are hardware dependent and optional."""
        sfe: Sfe | None = None
        """Sfe (Software Forwarding Engine) settings."""

        def __init__(
            self, *, _custom_data: dict[str, Any] | None = None, trident: Trident | None = None, sand: Sand | None = None, sfe: Sfe | None = None
        ) -> None:
            """
            Platform.

            Args:
            -----
                _custom_data: _custom_data
                trident: trident
                sand: Most of the platform sand options are hardware dependent and optional.
                sfe: Sfe (Software Forwarding Engine) settings.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Poe(AvdBase):
        class Reboot(AvdBase):
            _fields = ("_custom_data", "action")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            action: Annotated[str, ValidValues["power-off", "maintain"]] | None = None
            """PoE action for interface. By default in EOS, reboot action is set to power-off."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, action: Annotated[str, ValidValues["power-off", "maintain"]] | None = None
            ) -> None:
                """
                Reboot.

                Args:
                -----
                    _custom_data: _custom_data
                    action: PoE action for interface. By default in EOS, reboot action is set to power-off.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class InterfaceShutdown(AvdBase):
            _fields = ("_custom_data", "action")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            action: Annotated[str, ValidValues["power-off", "maintain"]] | None = None
            """PoE action for interface. By default in EOS, interface shutdown action is set to maintain."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, action: Annotated[str, ValidValues["power-off", "maintain"]] | None = None
            ) -> None:
                """
                InterfaceShutdown.

                Args:
                -----
                    _custom_data: _custom_data
                    action: PoE action for interface. By default in EOS, interface shutdown action is set to maintain.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "reboot", "interface_shutdown")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        reboot: Reboot | None = None
        """Set the global PoE power behavior for PoE ports when the system is rebooted."""
        interface_shutdown: InterfaceShutdown | None = None
        """Set the global PoE power behavior for PoE ports when ports are admin down."""

        def __init__(
            self, *, _custom_data: dict[str, Any] | None = None, reboot: Reboot | None = None, interface_shutdown: InterfaceShutdown | None = None
        ) -> None:
            """
            Poe.

            Args:
            -----
                _custom_data: _custom_data
                reboot: Set the global PoE power behavior for PoE ports when the system is rebooted.
                interface_shutdown: Set the global PoE power behavior for PoE ports when ports are admin down.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class PolicyMaps(AvdBase):
        class PbrItem(AvdBase):
            class ClassesItem(AvdBase):
                class Set(AvdBase):
                    class Nexthop(AvdBase):
                        _fields = ("_custom_data", "ip_address", "recursive")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        ip_address: str | None = None
                        """IPv4 or IPv6 Address."""
                        recursive: bool | None = None

                        def __init__(self, *, _custom_data: dict[str, Any] | None = None, ip_address: str | None = None, recursive: bool | None = None) -> None:
                            """
                            Nexthop.

                            Args:
                            -----
                                _custom_data: _custom_data
                                ip_address: IPv4 or IPv6 Address.
                                recursive: recursive

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "nexthop")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    nexthop: Nexthop | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, nexthop: Nexthop | None = None) -> None:
                        """
                        Set.

                        Args:
                        -----
                            _custom_data: _custom_data
                            nexthop: nexthop

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "name", "index", "drop", "set")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Class Name."""
                index: int | None = None
                drop: bool | None = None
                """'drop' and 'set' are mutually exclusive."""
                set: Set | None = None
                """
                Set Nexthop
                'drop' and 'set' are mutually exclusive.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    index: int | None = None,
                    drop: bool | None = None,
                    set: Set | None = None,
                ) -> None:
                    """
                    ClassesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Class Name.
                        index: index
                        drop: 'drop' and 'set' are mutually exclusive.
                        set:
                           Set Nexthop
                           'drop' and 'set' are mutually exclusive.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "classes")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Policy-Map Name."""
            classes: list[ClassesItem] | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, classes: list[ClassesItem] | None = None) -> None:
                """
                PbrItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Policy-Map Name.
                    classes: classes

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class QosItem(AvdBase):
            class ClassesItem(AvdBase):
                class Set(AvdBase):
                    _fields = ("_custom_data", "cos", "dscp", "traffic_class", "drop_precedence")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    cos: int | None = None
                    dscp: str | None = None
                    traffic_class: int | None = None
                    drop_precedence: int | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        cos: int | None = None,
                        dscp: str | None = None,
                        traffic_class: int | None = None,
                        drop_precedence: int | None = None,
                    ) -> None:
                        """
                        Set.

                        Args:
                        -----
                            _custom_data: _custom_data
                            cos: cos
                            dscp: dscp
                            traffic_class: traffic_class
                            drop_precedence: drop_precedence

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Police(AvdBase):
                    class Action(AvdBase):
                        _fields = ("_custom_data", "type", "dscp_value")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        type: Annotated[str, ValidValues["dscp", "drop-precedence"]] | None = None
                        """Set action for policed traffic."""
                        dscp_value: str | None = None
                        """Set when action.type is set to "dscp"."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            type: Annotated[str, ValidValues["dscp", "drop-precedence"]] | None = None,
                            dscp_value: str | None = None,
                        ) -> None:
                            """
                            Action.

                            Args:
                            -----
                                _custom_data: _custom_data
                                type: Set action for policed traffic.
                                dscp_value: Set when action.type is set to "dscp".

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = (
                        "_custom_data",
                        "rate",
                        "rate_unit",
                        "rate_burst_size",
                        "rate_burst_size_unit",
                        "action",
                        "higher_rate",
                        "higher_rate_unit",
                        "higher_rate_burst_size",
                        "higher_rate_burst_size_unit",
                    )
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    rate: int | None = None
                    """
                    Specify rate.
                    Range in kbps <8-200000000>.
                    """
                    rate_unit: Annotated[str, ValidValues["bps", "kbps", "mbps", "pps"]] | None = "bps"
                    rate_burst_size: int | None = None
                    """Range in bytes <256-128000000>."""
                    rate_burst_size_unit: Annotated[str, ValidValues["bytes", "kbytes", "mbytes", "packets"]] | None = "bytes"
                    action: Action | None = None
                    higher_rate: int | None = None
                    """
                    Specify higher rate.
                    Range in kbps <lower_rate in kbps + 8 - lower_rate in kbps + 200000000>.
                    """
                    higher_rate_unit: Annotated[str, ValidValues["bps", "kbps", "mbps", "pps"]] | None = "bps"
                    higher_rate_burst_size: int | None = None
                    """Range in bytes <256-128000000>."""
                    higher_rate_burst_size_unit: Annotated[str, ValidValues["bytes", "kbytes", "mbytes", "packets"]] | None = "bytes"

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        rate: int | None = None,
                        rate_unit: Annotated[str, ValidValues["bps", "kbps", "mbps", "pps"]] | None = "bps",
                        rate_burst_size: int | None = None,
                        rate_burst_size_unit: Annotated[str, ValidValues["bytes", "kbytes", "mbytes", "packets"]] | None = "bytes",
                        action: Action | None = None,
                        higher_rate: int | None = None,
                        higher_rate_unit: Annotated[str, ValidValues["bps", "kbps", "mbps", "pps"]] | None = "bps",
                        higher_rate_burst_size: int | None = None,
                        higher_rate_burst_size_unit: Annotated[str, ValidValues["bytes", "kbytes", "mbytes", "packets"]] | None = "bytes",
                    ) -> None:
                        """
                        Police.

                        Args:
                        -----
                            _custom_data: _custom_data
                            rate:
                               Specify rate.
                               Range in kbps <8-200000000>.
                            rate_unit: rate_unit
                            rate_burst_size: Range in bytes <256-128000000>.
                            rate_burst_size_unit: rate_burst_size_unit
                            action: action
                            higher_rate:
                               Specify higher rate.
                               Range in kbps <lower_rate in kbps + 8 - lower_rate in kbps + 200000000>.
                            higher_rate_unit: higher_rate_unit
                            higher_rate_burst_size: Range in bytes <256-128000000>.
                            higher_rate_burst_size_unit: higher_rate_burst_size_unit

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "name", "set", "police")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Class Name."""
                set: Set | None = None
                police: Police | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, name: str = None, set: Set | None = None, police: Police | None = None
                ) -> None:
                    """
                    ClassesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Class Name.
                        set: set
                        police: police

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "classes")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Policy-Map Name."""
            classes: list[ClassesItem] | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, classes: list[ClassesItem] | None = None) -> None:
                """
                QosItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Policy-Map Name.
                    classes: classes

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class CoppSystemPolicy(AvdBase):
            class ClassesItem(AvdBase):
                _fields = ("_custom_data", "name", "shape", "bandwidth", "rate_unit")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                shape: Annotated[int, Max[10000000]] | None = None
                """Maximum rate limit."""
                bandwidth: Annotated[int, Max[10000000]] | None = None
                """Minimum bandwidth."""
                rate_unit: Annotated[str, ValidValues["pps", "kbps"]] | None = None
                """The `rate_unit` must be defined for `shape` and `bandwidth`."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    shape: Annotated[int, Max[10000000]] | None = None,
                    bandwidth: Annotated[int, Max[10000000]] | None = None,
                    rate_unit: Annotated[str, ValidValues["pps", "kbps"]] | None = None,
                ) -> None:
                    """
                    ClassesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        shape: Maximum rate limit.
                        bandwidth: Minimum bandwidth.
                        rate_unit: The `rate_unit` must be defined for `shape` and `bandwidth`.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "classes")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            classes: list[ClassesItem] | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, classes: list[ClassesItem] | None = None) -> None:
                """
                CoppSystemPolicy.

                Args:
                -----
                    _custom_data: _custom_data
                    classes: classes

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "pbr", "qos", "copp_system_policy")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        pbr: list[PbrItem] | None = None
        """PBR Policy-Maps."""
        qos: list[QosItem] | None = None
        """QOS Policy-Maps."""
        copp_system_policy: CoppSystemPolicy | None = None
        """Control-plane policy configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            pbr: list[PbrItem] | None = None,
            qos: list[QosItem] | None = None,
            copp_system_policy: CoppSystemPolicy | None = None,
        ) -> None:
            """
            PolicyMaps.

            Args:
            -----
                _custom_data: _custom_data
                pbr: PBR Policy-Maps.
                qos: QOS Policy-Maps.
                copp_system_policy: Control-plane policy configuration.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class PortChannelInterfacesItem(AvdBase):
        class Logging(AvdBase):
            class Event(AvdBase):
                _fields = ("_custom_data", "link_status", "storm_control_discards")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                link_status: bool | None = None
                storm_control_discards: bool | None = None
                """Discards due to storm-control."""

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, link_status: bool | None = None, storm_control_discards: bool | None = None
                ) -> None:
                    """
                    Event.

                    Args:
                    -----
                        _custom_data: _custom_data
                        link_status: link_status
                        storm_control_discards: Discards due to storm-control.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "event")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            event: Event | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, event: Event | None = None) -> None:
                """
                Logging.

                Args:
                -----
                    _custom_data: _custom_data
                    event: event

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class EncapsulationDot1q(AvdBase):
            _fields = ("_custom_data", "vlan", "inner_vlan")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            vlan: Annotated[int, Min[1], Max[4094]] = None
            """VLAD ID."""
            inner_vlan: Annotated[int, Min[1], Max[4094]] | None = None
            """Inner VLAN ID. This setting can only be applied to sub-interfaces on EOS."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                vlan: Annotated[int, Min[1], Max[4094]] = None,
                inner_vlan: Annotated[int, Min[1], Max[4094]] | None = None,
            ) -> None:
                """
                EncapsulationDot1q.

                Args:
                -----
                    _custom_data: _custom_data
                    vlan: VLAD ID.
                    inner_vlan: Inner VLAN ID. This setting can only be applied to sub-interfaces on EOS.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class EncapsulationVlan(AvdBase):
            class Client(AvdBase):
                class Dot1q(AvdBase):
                    _fields = ("_custom_data", "vlan", "outer", "inner")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    vlan: int | None = None
                    """Client VLAN ID."""
                    outer: Annotated[int, Min[1], Max[4094]] | None = None
                    """Client Outer VLAN ID."""
                    inner: Annotated[int, Min[1], Max[4094]] | None = None
                    """Client Inner VLAN ID."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        vlan: int | None = None,
                        outer: Annotated[int, Min[1], Max[4094]] | None = None,
                        inner: Annotated[int, Min[1], Max[4094]] | None = None,
                    ) -> None:
                        """
                        Dot1q.

                        Args:
                        -----
                            _custom_data: _custom_data
                            vlan: Client VLAN ID.
                            outer: Client Outer VLAN ID.
                            inner: Client Inner VLAN ID.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "dot1q", "unmatched", "encapsulation", "vlan", "outer_vlan", "inner_vlan", "inner_encapsulation")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                dot1q: Dot1q | None = None
                unmatched: bool | None = None
                encapsulation: Annotated[str, ValidValues["dot1q", "dot1ad", "unmatched", "untagged"]] | None = None
                vlan: Annotated[int, Min[1], Max[4094]] | None = None
                """Client VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                outer_vlan: Annotated[int, Min[1], Max[4094]] | None = None
                """Client Outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                inner_vlan: Annotated[int, Min[1], Max[4094]] | None = None
                """Client Inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                inner_encapsulation: Annotated[str, ValidValues["dot1q", "dot1ad"]] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    dot1q: Dot1q | None = None,
                    unmatched: bool | None = None,
                    encapsulation: Annotated[str, ValidValues["dot1q", "dot1ad", "unmatched", "untagged"]] | None = None,
                    vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                    outer_vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                    inner_vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                    inner_encapsulation: Annotated[str, ValidValues["dot1q", "dot1ad"]] | None = None,
                ) -> None:
                    """
                    Client.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dot1q: dot1q
                        unmatched: unmatched
                        encapsulation: encapsulation
                        vlan: Client VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                        outer_vlan: Client Outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                        inner_vlan: Client Inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                        inner_encapsulation: inner_encapsulation

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Network(AvdBase):
                class Dot1q(AvdBase):
                    _fields = ("_custom_data", "vlan", "outer", "inner")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    vlan: Annotated[int, Min[1], Max[4094]] | None = None
                    """Network VLAN ID."""
                    outer: Annotated[int, Min[1], Max[4094]] | None = None
                    """Network Outer VLAN ID."""
                    inner: Annotated[int, Min[1], Max[4094]] | None = None
                    """Network Inner VLAN ID."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                        outer: Annotated[int, Min[1], Max[4094]] | None = None,
                        inner: Annotated[int, Min[1], Max[4094]] | None = None,
                    ) -> None:
                        """
                        Dot1q.

                        Args:
                        -----
                            _custom_data: _custom_data
                            vlan: Network VLAN ID.
                            outer: Network Outer VLAN ID.
                            inner: Network Inner VLAN ID.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "dot1q", "client", "encapsulation", "vlan", "outer_vlan", "inner_vlan", "inner_encapsulation")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                dot1q: Dot1q | None = None
                client: bool | None = None
                encapsulation: Annotated[str, ValidValues["dot1q", "dot1ad", "client", "client inner", "untagged"]] | None = None
                """
                `untagged` (no encapsulation) is applicable for `untagged` client only.
                `client` and `client inner`
                (retain client encapsulation) is not applicable for `untagged` client.
                """
                vlan: Annotated[int, Min[1], Max[4094]] | None = None
                """Network VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                outer_vlan: Annotated[int, Min[1], Max[4094]] | None = None
                """Network outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                inner_vlan: Annotated[int, Min[1], Max[4094]] | None = None
                """Network inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                inner_encapsulation: Annotated[str, ValidValues["dot1q", "dot1ad"]] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    dot1q: Dot1q | None = None,
                    client: bool | None = None,
                    encapsulation: Annotated[str, ValidValues["dot1q", "dot1ad", "client", "client inner", "untagged"]] | None = None,
                    vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                    outer_vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                    inner_vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                    inner_encapsulation: Annotated[str, ValidValues["dot1q", "dot1ad"]] | None = None,
                ) -> None:
                    """
                    Network.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dot1q: dot1q
                        client: client
                        encapsulation:
                           `untagged` (no encapsulation) is applicable for `untagged` client only.
                           `client` and `client inner`
                           (retain client encapsulation) is not applicable for `untagged` client.
                        vlan: Network VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                        outer_vlan: Network outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                        inner_vlan: Network inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                        inner_encapsulation: inner_encapsulation

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "client", "network")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            client: Client | None = None
            network: Network | None = None
            """Network encapsulation are all optional, and skipped if using client unmatched."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, client: Client | None = None, network: Network | None = None) -> None:
                """
                EncapsulationVlan.

                Args:
                -----
                    _custom_data: _custom_data
                    client: client
                    network: Network encapsulation are all optional, and skipped if using client unmatched.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class LinkTrackingGroupsItem(AvdBase):
            _fields = ("_custom_data", "name", "direction")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Group name."""
            direction: Annotated[str, ValidValues["upstream", "downstream"]] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                direction: Annotated[str, ValidValues["upstream", "downstream"]] | None = None,
            ) -> None:
                """
                LinkTrackingGroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Group name.
                    direction: direction

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Phone(AvdBase):
            _fields = ("_custom_data", "trunk", "vlan")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            trunk: Annotated[str, ValidValues["tagged", "untagged"]] | None = None
            vlan: Annotated[int, Min[1], Max[4094]] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                trunk: Annotated[str, ValidValues["tagged", "untagged"]] | None = None,
                vlan: Annotated[int, Min[1], Max[4094]] | None = None,
            ) -> None:
                """
                Phone.

                Args:
                -----
                    _custom_data: _custom_data
                    trunk: trunk
                    vlan: vlan

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class L2Protocol(AvdBase):
            _fields = ("_custom_data", "encapsulation_dot1q_vlan", "forwarding_profile")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            encapsulation_dot1q_vlan: int | None = None
            """Vlan tag to configure on sub-interface."""
            forwarding_profile: str | None = None
            """L2 protocol forwarding profile."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, encapsulation_dot1q_vlan: int | None = None, forwarding_profile: str | None = None
            ) -> None:
                """
                L2Protocol.

                Args:
                -----
                    _custom_data: _custom_data
                    encapsulation_dot1q_vlan: Vlan tag to configure on sub-interface.
                    forwarding_profile: L2 protocol forwarding profile.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Qos(AvdBase):
            _fields = ("_custom_data", "trust", "dscp", "cos")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            trust: Annotated[str, ValidValues["dscp", "cos", "disabled"]] | None = None
            dscp: int | None = None
            """DSCP value."""
            cos: int | None = None
            """COS value."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                trust: Annotated[str, ValidValues["dscp", "cos", "disabled"]] | None = None,
                dscp: int | None = None,
                cos: int | None = None,
            ) -> None:
                """
                Qos.

                Args:
                -----
                    _custom_data: _custom_data
                    trust: trust
                    dscp: DSCP value.
                    cos: COS value.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Bfd(AvdBase):
            class PerLink(AvdBase):
                _fields = ("_custom_data", "enabled", "rfc_7130")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                rfc_7130: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, rfc_7130: bool | None = None) -> None:
                    """
                    PerLink.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        rfc_7130: rfc_7130

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "echo", "interval", "min_rx", "multiplier", "neighbor", "per_link")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            echo: bool | None = None
            interval: int | None = None
            """Interval in milliseconds."""
            min_rx: int | None = None
            """Rate in milliseconds."""
            multiplier: Annotated[int, Min[3], Max[50]] | None = None
            neighbor: str | None = None
            """
            IPv4 or IPv6 address. When the Port-channel is a L2 interface, a local L3 BFD address
            (router_bfd.local_address) has to be defined globally on the switch.
            """
            per_link: PerLink | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                echo: bool | None = None,
                interval: int | None = None,
                min_rx: int | None = None,
                multiplier: Annotated[int, Min[3], Max[50]] | None = None,
                neighbor: str | None = None,
                per_link: PerLink | None = None,
            ) -> None:
                """
                Bfd.

                Args:
                -----
                    _custom_data: _custom_data
                    echo: echo
                    interval: Interval in milliseconds.
                    min_rx: Rate in milliseconds.
                    multiplier: multiplier
                    neighbor:
                       IPv4 or IPv6 address. When the Port-channel is a L2 interface, a local L3 BFD address
                       (router_bfd.local_address) has to be defined globally on the switch.
                    per_link: per_link

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ServicePolicy(AvdBase):
            class Pbr(AvdBase):
                _fields = ("_custom_data", "input")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                input: str | None = None
                """Policy Based Routing Policy-map name."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, input: str | None = None) -> None:
                    """
                    Pbr.

                    Args:
                    -----
                        _custom_data: _custom_data
                        input: Policy Based Routing Policy-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Qos(AvdBase):
                _fields = ("_custom_data", "input")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                input: str = None
                """Quality of Service Policy-map name."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, input: str = None) -> None:
                    """
                    Qos.

                    Args:
                    -----
                        _custom_data: _custom_data
                        input: Quality of Service Policy-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "pbr", "qos")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            pbr: Pbr | None = None
            qos: Qos | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, pbr: Pbr | None = None, qos: Qos | None = None) -> None:
                """
                ServicePolicy.

                Args:
                -----
                    _custom_data: _custom_data
                    pbr: pbr
                    qos: qos

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Mpls(AvdBase):
            class Ldp(AvdBase):
                _fields = ("_custom_data", "interface", "igp_sync")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                interface: bool | None = None
                igp_sync: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, interface: bool | None = None, igp_sync: bool | None = None) -> None:
                    """
                    Ldp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interface: interface
                        igp_sync: igp_sync

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "ip", "ldp")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ip: bool | None = None
            ldp: Ldp | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, ip: bool | None = None, ldp: Ldp | None = None) -> None:
                """
                Mpls.

                Args:
                -----
                    _custom_data: _custom_data
                    ip: ip
                    ldp: ldp

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VlanTranslationsItem(AvdBase):
            _fields = ("_custom_data", "field_from", "to", "direction")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            field_from: str | None = None
            """List of vlans as string (only one vlan if direction is "both")."""
            to: int | None = None
            """VLAN ID."""
            direction: Annotated[str, ValidValues["in", "out", "both"]] | None = "both"

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                field_from: str | None = None,
                to: int | None = None,
                direction: Annotated[str, ValidValues["in", "out", "both"]] | None = "both",
            ) -> None:
                """
                VlanTranslationsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    field_from: List of vlans as string (only one vlan if direction is "both").
                    to: VLAN ID.
                    direction: direction

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Shape(AvdBase):
            _fields = ("_custom_data", "rate")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            rate: str | None = None
            """
            Rate in kbps, pps or percent.
            Supported options are platform dependent.
            Examples:
            - "5000 kbps"
            -
            "1000 pps"
            - "20 percent"
            """

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, rate: str | None = None) -> None:
                """
                Shape.

                Args:
                -----
                    _custom_data: _custom_data
                    rate:
                       Rate in kbps, pps or percent.
                       Supported options are platform dependent.

                Examples:
                       - "5000 kbps"
                       -
                       "1000 pps"
                       - "20 percent"

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class StormControl(AvdBase):
            class All(AvdBase):
                _fields = ("_custom_data", "level", "unit")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                level: str | None = None
                """Configure maximum storm-control level."""
                unit: Annotated[str, ValidValues["percent", "pps"]] | None = "percent"
                """Optional field and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    level: str | None = None,
                    unit: Annotated[str, ValidValues["percent", "pps"]] | None = "percent",
                ) -> None:
                    """
                    All.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional field and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Broadcast(AvdBase):
                _fields = ("_custom_data", "level", "unit")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                level: str | None = None
                """Configure maximum storm-control level."""
                unit: Annotated[str, ValidValues["percent", "pps"]] | None = "percent"
                """Optional field and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    level: str | None = None,
                    unit: Annotated[str, ValidValues["percent", "pps"]] | None = "percent",
                ) -> None:
                    """
                    Broadcast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional field and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Multicast(AvdBase):
                _fields = ("_custom_data", "level", "unit")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                level: str | None = None
                """Configure maximum storm-control level."""
                unit: Annotated[str, ValidValues["percent", "pps"]] | None = "percent"
                """Optional field and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    level: str | None = None,
                    unit: Annotated[str, ValidValues["percent", "pps"]] | None = "percent",
                ) -> None:
                    """
                    Multicast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional field and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class UnknownUnicast(AvdBase):
                _fields = ("_custom_data", "level", "unit")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                level: str | None = None
                """Configure maximum storm-control level."""
                unit: Annotated[str, ValidValues["percent", "pps"]] | None = "percent"
                """Optional field and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    level: str | None = None,
                    unit: Annotated[str, ValidValues["percent", "pps"]] | None = "percent",
                ) -> None:
                    """
                    UnknownUnicast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional field and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "all", "broadcast", "multicast", "unknown_unicast")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            all: All | None = None
            broadcast: Broadcast | None = None
            multicast: Multicast | None = None
            unknown_unicast: UnknownUnicast | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                all: All | None = None,
                broadcast: Broadcast | None = None,
                multicast: Multicast | None = None,
                unknown_unicast: UnknownUnicast | None = None,
            ) -> None:
                """
                StormControl.

                Args:
                -----
                    _custom_data: _custom_data
                    all: all
                    broadcast: broadcast
                    multicast: multicast
                    unknown_unicast: unknown_unicast

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TrafficPolicy(AvdBase):
            _fields = ("_custom_data", "input", "output")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            input: str | None = None
            """Ingress traffic policy."""
            output: str | None = None
            """Egress traffic policy."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, input: str | None = None, output: str | None = None) -> None:
                """
                TrafficPolicy.

                Args:
                -----
                    _custom_data: _custom_data
                    input: Ingress traffic policy.
                    output: Egress traffic policy.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class EvpnEthernetSegment(AvdBase):
            class DesignatedForwarderElection(AvdBase):
                _fields = (
                    "_custom_data",
                    "algorithm",
                    "preference_value",
                    "dont_preempt",
                    "hold_time",
                    "subsequent_hold_time",
                    "candidate_reachability_required",
                )
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                algorithm: Annotated[str, ValidValues["modulus", "preference"]] | None = None
                preference_value: Annotated[int, Max[65535]] | None = None
                """Preference_value is only used when "algorithm" is "preference"."""
                dont_preempt: bool | None = False
                """Dont_preempt is only used when "algorithm" is "preference"."""
                hold_time: int | None = None
                subsequent_hold_time: int | None = None
                candidate_reachability_required: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    algorithm: Annotated[str, ValidValues["modulus", "preference"]] | None = None,
                    preference_value: Annotated[int, Max[65535]] | None = None,
                    dont_preempt: bool | None = False,
                    hold_time: int | None = None,
                    subsequent_hold_time: int | None = None,
                    candidate_reachability_required: bool | None = None,
                ) -> None:
                    """
                    DesignatedForwarderElection.

                    Args:
                    -----
                        _custom_data: _custom_data
                        algorithm: algorithm
                        preference_value: Preference_value is only used when "algorithm" is "preference".
                        dont_preempt: Dont_preempt is only used when "algorithm" is "preference".
                        hold_time: hold_time
                        subsequent_hold_time: subsequent_hold_time
                        candidate_reachability_required: candidate_reachability_required

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Mpls(AvdBase):
                _fields = ("_custom_data", "shared_index", "tunnel_flood_filter_time")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                shared_index: Annotated[int, Min[1], Max[1024]] | None = None
                tunnel_flood_filter_time: int | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    shared_index: Annotated[int, Min[1], Max[1024]] | None = None,
                    tunnel_flood_filter_time: int | None = None,
                ) -> None:
                    """
                    Mpls.

                    Args:
                    -----
                        _custom_data: _custom_data
                        shared_index: shared_index
                        tunnel_flood_filter_time: tunnel_flood_filter_time

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "identifier", "redundancy", "designated_forwarder_election", "mpls", "route_target")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            identifier: str | None = None
            """EVPN Ethernet Segment Identifier (Type 1 format)."""
            redundancy: Annotated[str, ValidValues["all-active", "single-active"]] | None = None
            designated_forwarder_election: DesignatedForwarderElection | None = None
            mpls: Mpls | None = None
            route_target: str | None = None
            """EVPN Route Target for ESI with format xx:xx:xx:xx:xx:xx."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                identifier: str | None = None,
                redundancy: Annotated[str, ValidValues["all-active", "single-active"]] | None = None,
                designated_forwarder_election: DesignatedForwarderElection | None = None,
                mpls: Mpls | None = None,
                route_target: str | None = None,
            ) -> None:
                """
                EvpnEthernetSegment.

                Args:
                -----
                    _custom_data: _custom_data
                    identifier: EVPN Ethernet Segment Identifier (Type 1 format).
                    redundancy: redundancy
                    designated_forwarder_election: designated_forwarder_election
                    mpls: mpls
                    route_target: EVPN Route Target for ESI with format xx:xx:xx:xx:xx:xx.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ptp(AvdBase):
            class Announce(AvdBase):
                _fields = ("_custom_data", "interval", "timeout")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                interval: int | None = None
                timeout: int | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, interval: int | None = None, timeout: int | None = None) -> None:
                    """
                    Announce.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interval: interval
                        timeout: timeout

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Profile(AvdBase):
                class G82751(AvdBase):
                    _fields = ("_custom_data", "destination_mac_address")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    destination_mac_address: Annotated[str, ValidValues["forwardable", "non-forwardable"]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        destination_mac_address: Annotated[str, ValidValues["forwardable", "non-forwardable"]] | None = None,
                    ) -> None:
                        """
                        G82751.

                        Args:
                        -----
                            _custom_data: _custom_data
                            destination_mac_address: destination_mac_address

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "g8275_1")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                g8275_1: G82751 | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, g8275_1: G82751 | None = None) -> None:
                    """
                    Profile.

                    Args:
                    -----
                        _custom_data: _custom_data
                        g8275_1: g8275_1

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class SyncMessage(AvdBase):
                _fields = ("_custom_data", "interval")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                interval: int | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, interval: int | None = None) -> None:
                    """
                    SyncMessage.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interval: interval

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "enable", "announce", "delay_req", "delay_mechanism", "profile", "sync_message", "role", "vlan", "transport", "mpass")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enable: bool | None = None
            announce: Announce | None = None
            delay_req: int | None = None
            delay_mechanism: Annotated[str, ValidValues["e2e", "p2p"]] | None = None
            profile: Profile | None = None
            sync_message: SyncMessage | None = None
            role: Annotated[str, ValidValues["master", "dynamic"]] | None = None
            vlan: str | None = None
            """VLAN can be 'all' or list of vlans as string."""
            transport: Annotated[str, ValidValues["ipv4", "ipv6", "layer2"]] | None = None
            mpass: bool | None = None
            """
            When MPASS is enabled on an MLAG port-channel, MLAG peers coordinate to function as a single PTP
            logical device.
            Arista PTP enabled devices always place PTP messages on the same physical link
            within the port-channel.
            Hence, MPASS is needed only on MLAG port-channels connected to non-Arista
            devices.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enable: bool | None = None,
                announce: Announce | None = None,
                delay_req: int | None = None,
                delay_mechanism: Annotated[str, ValidValues["e2e", "p2p"]] | None = None,
                profile: Profile | None = None,
                sync_message: SyncMessage | None = None,
                role: Annotated[str, ValidValues["master", "dynamic"]] | None = None,
                vlan: str | None = None,
                transport: Annotated[str, ValidValues["ipv4", "ipv6", "layer2"]] | None = None,
                mpass: bool | None = None,
            ) -> None:
                """
                Ptp.

                Args:
                -----
                    _custom_data: _custom_data
                    enable: enable
                    announce: announce
                    delay_req: delay_req
                    delay_mechanism: delay_mechanism
                    profile: profile
                    sync_message: sync_message
                    role: role
                    vlan: VLAN can be 'all' or list of vlans as string.
                    transport: transport
                    mpass:
                       When MPASS is enabled on an MLAG port-channel, MLAG peers coordinate to function as a single PTP
                       logical device.
                       Arista PTP enabled devices always place PTP messages on the same physical link
                       within the port-channel.
                       Hence, MPASS is needed only on MLAG port-channels connected to non-Arista
                       devices.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IpNat(AvdBase):
            class Destination(AvdBase):
                class DynamicItem(AvdBase):
                    _fields = ("_custom_data", "access_list", "comment", "pool_name", "priority")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    access_list: str = None
                    comment: str | None = None
                    pool_name: str = None
                    priority: Annotated[int, Max[4294967295]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        access_list: str = None,
                        comment: str | None = None,
                        pool_name: str = None,
                        priority: Annotated[int, Max[4294967295]] | None = None,
                    ) -> None:
                        """
                        DynamicItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: access_list
                            comment: comment
                            pool_name: pool_name
                            priority: priority

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class StaticItem(AvdBase):
                    _fields = (
                        "_custom_data",
                        "access_list",
                        "comment",
                        "direction",
                        "group",
                        "original_ip",
                        "original_port",
                        "priority",
                        "protocol",
                        "translated_ip",
                        "translated_port",
                    )
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    access_list: str | None = None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None = None
                    direction: Annotated[str, ValidValues["egress", "ingress"]] | None = None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: Annotated[int, Min[1], Max[65535]] | None = None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None = None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: Annotated[int, Min[1], Max[65535]] | None = None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: Annotated[int, Max[4294967295]] | None = None
                    protocol: Annotated[str, ValidValues["udp", "tcp"]] | None = None
                    translated_ip: str = None
                    """IPv4 address."""
                    translated_port: Annotated[int, Min[1], Max[65535]] | None = None
                    """requires 'original_port'."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        access_list: str | None = None,
                        comment: str | None = None,
                        direction: Annotated[str, ValidValues["egress", "ingress"]] | None = None,
                        group: Annotated[int, Min[1], Max[65535]] | None = None,
                        original_ip: str | None = None,
                        original_port: Annotated[int, Min[1], Max[65535]] | None = None,
                        priority: Annotated[int, Max[4294967295]] | None = None,
                        protocol: Annotated[str, ValidValues["udp", "tcp"]] | None = None,
                        translated_ip: str = None,
                        translated_port: Annotated[int, Min[1], Max[65535]] | None = None,
                    ) -> None:
                        """
                        StaticItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: 'access_list' and 'group' are mutual exclusive.
                            comment: comment
                            direction:
                               Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                               platform.
                               EOS might remove this keyword in the configuration. So, check the configuration on
                               targeted HW/SW.
                            group: 'access_list' and 'group' are mutual exclusive.
                            original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                            original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                            priority: priority
                            protocol: protocol
                            translated_ip: IPv4 address.
                            translated_port: requires 'original_port'.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "dynamic", "static")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                dynamic: list[DynamicItem] | None = None
                static: list[StaticItem] | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, dynamic: list[DynamicItem] | None = None, static: list[StaticItem] | None = None
                ) -> None:
                    """
                    Destination.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dynamic: dynamic
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Source(AvdBase):
                class DynamicItem(AvdBase):
                    _fields = ("_custom_data", "access_list", "comment", "nat_type", "pool_name", "priority")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    access_list: str = None
                    comment: str | None = None
                    nat_type: Annotated[str, ValidValues["overload", "pool", "pool-address-only", "pool-full-cone"]] = None
                    pool_name: str | None = None
                    """
                    required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                    ignored if 'nat_type' is
                    overload.
                    """
                    priority: Annotated[int, Max[4294967295]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        access_list: str = None,
                        comment: str | None = None,
                        nat_type: Annotated[str, ValidValues["overload", "pool", "pool-address-only", "pool-full-cone"]] = None,
                        pool_name: str | None = None,
                        priority: Annotated[int, Max[4294967295]] | None = None,
                    ) -> None:
                        """
                        DynamicItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: access_list
                            comment: comment
                            nat_type: nat_type
                            pool_name:
                               required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                               ignored if 'nat_type' is
                               overload.
                            priority: priority

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class StaticItem(AvdBase):
                    _fields = (
                        "_custom_data",
                        "access_list",
                        "comment",
                        "direction",
                        "group",
                        "original_ip",
                        "original_port",
                        "priority",
                        "protocol",
                        "translated_ip",
                        "translated_port",
                    )
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    access_list: str | None = None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None = None
                    direction: Annotated[str, ValidValues["egress", "ingress"]] | None = None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: Annotated[int, Min[1], Max[65535]] | None = None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None = None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: Annotated[int, Min[1], Max[65535]] | None = None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: Annotated[int, Max[4294967295]] | None = None
                    protocol: Annotated[str, ValidValues["udp", "tcp"]] | None = None
                    translated_ip: str = None
                    """IPv4 address."""
                    translated_port: Annotated[int, Min[1], Max[65535]] | None = None
                    """requires 'original_port'."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        access_list: str | None = None,
                        comment: str | None = None,
                        direction: Annotated[str, ValidValues["egress", "ingress"]] | None = None,
                        group: Annotated[int, Min[1], Max[65535]] | None = None,
                        original_ip: str | None = None,
                        original_port: Annotated[int, Min[1], Max[65535]] | None = None,
                        priority: Annotated[int, Max[4294967295]] | None = None,
                        protocol: Annotated[str, ValidValues["udp", "tcp"]] | None = None,
                        translated_ip: str = None,
                        translated_port: Annotated[int, Min[1], Max[65535]] | None = None,
                    ) -> None:
                        """
                        StaticItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: 'access_list' and 'group' are mutual exclusive.
                            comment: comment
                            direction:
                               Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                               platform.
                               EOS might remove this keyword in the configuration. So, check the configuration on
                               targeted HW/SW.
                            group: 'access_list' and 'group' are mutual exclusive.
                            original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                            original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                            priority: priority
                            protocol: protocol
                            translated_ip: IPv4 address.
                            translated_port: requires 'original_port'.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "dynamic", "static")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                dynamic: list[DynamicItem] | None = None
                static: list[StaticItem] | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, dynamic: list[DynamicItem] | None = None, static: list[StaticItem] | None = None
                ) -> None:
                    """
                    Source.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dynamic: dynamic
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "destination", "source")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            destination: Destination | None = None
            source: Source | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, destination: Destination | None = None, source: Source | None = None) -> None:
                """
                IpNat.

                Args:
                -----
                    _custom_data: _custom_data
                    destination: destination
                    source: source

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6NdPrefixesItem(AvdBase):
            _fields = ("_custom_data", "ipv6_prefix", "valid_lifetime", "preferred_lifetime", "no_autoconfig_flag")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv6_prefix: str = None
            valid_lifetime: str | None = None
            """Infinite or lifetime in seconds."""
            preferred_lifetime: str | None = None
            """Infinite or lifetime in seconds."""
            no_autoconfig_flag: bool | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                ipv6_prefix: str = None,
                valid_lifetime: str | None = None,
                preferred_lifetime: str | None = None,
                no_autoconfig_flag: bool | None = None,
            ) -> None:
                """
                Ipv6NdPrefixesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv6_prefix: ipv6_prefix
                    valid_lifetime: Infinite or lifetime in seconds.
                    preferred_lifetime: Infinite or lifetime in seconds.
                    no_autoconfig_flag: no_autoconfig_flag

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Pim(AvdBase):
            class Ipv4(AvdBase):
                class Hello(AvdBase):
                    _fields = ("_custom_data", "count", "interval")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    count: str | None = None
                    """Number of missed hellos after which the neighbor expires. Range <1.5-65535>."""
                    interval: Annotated[int, Min[1], Max[65535]] | None = None
                    """PIM hello interval in seconds."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        count: str | None = None,
                        interval: Annotated[int, Min[1], Max[65535]] | None = None,
                    ) -> None:
                        """
                        Hello.

                        Args:
                        -----
                            _custom_data: _custom_data
                            count: Number of missed hellos after which the neighbor expires. Range <1.5-65535>.
                            interval: PIM hello interval in seconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "border_router", "dr_priority", "sparse_mode", "bfd", "bidirectional", "hello")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                border_router: bool | None = None
                """Configure PIM border router. EOS default is false."""
                dr_priority: Annotated[int, Max[429467295]] | None = None
                sparse_mode: bool | None = None
                bfd: bool | None = None
                """Set the default for whether Bidirectional Forwarding Detection is enabled for PIM."""
                bidirectional: bool | None = None
                hello: Hello | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    border_router: bool | None = None,
                    dr_priority: Annotated[int, Max[429467295]] | None = None,
                    sparse_mode: bool | None = None,
                    bfd: bool | None = None,
                    bidirectional: bool | None = None,
                    hello: Hello | None = None,
                ) -> None:
                    """
                    Ipv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        border_router: Configure PIM border router. EOS default is false.
                        dr_priority: dr_priority
                        sparse_mode: sparse_mode
                        bfd: Set the default for whether Bidirectional Forwarding Detection is enabled for PIM.
                        bidirectional: bidirectional
                        hello: hello

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "ipv4")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv4: Ipv4 | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, ipv4: Ipv4 | None = None) -> None:
                """
                Pim.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: ipv4

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class OspfMessageDigestKeysItem(AvdBase):
            _fields = ("_custom_data", "id", "hash_algorithm", "key")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            id: int = None
            hash_algorithm: Annotated[str, ValidValues["md5", "sha1", "sha256", "sha384", "sha512"]] | None = None
            key: str | None = None
            """Encrypted password."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                id: int = None,
                hash_algorithm: Annotated[str, ValidValues["md5", "sha1", "sha256", "sha384", "sha512"]] | None = None,
                key: str | None = None,
            ) -> None:
                """
                OspfMessageDigestKeysItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: id
                    hash_algorithm: hash_algorithm
                    key: Encrypted password.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class FlowTracker(AvdBase):
            _fields = ("_custom_data", "sampled", "hardware")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            sampled: str | None = None
            """Sampled flow tracker name."""
            hardware: str | None = None
            """Hardware flow tracker name."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, sampled: str | None = None, hardware: str | None = None) -> None:
                """
                FlowTracker.

                Args:
                -----
                    _custom_data: _custom_data
                    sampled: Sampled flow tracker name.
                    hardware: Hardware flow tracker name.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Bgp(AvdBase):
            _fields = ("_custom_data", "session_tracker")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            session_tracker: str | None = None
            """Name of session tracker."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, session_tracker: str | None = None) -> None:
                """
                Bgp.

                Args:
                -----
                    _custom_data: _custom_data
                    session_tracker: Name of session tracker.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IpIgmpHostProxy(AvdBase):
            class GroupsItem(AvdBase):
                class ExcludeItem(AvdBase):
                    _fields = ("_custom_data", "source")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    source: str = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, source: str = None) -> None:
                        """
                        ExcludeItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source: source

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class IncludeItem(AvdBase):
                    _fields = ("_custom_data", "source")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    source: str = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, source: str = None) -> None:
                        """
                        IncludeItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source: source

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "group", "exclude", "include")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                group: str = None
                """Multicast Address."""
                exclude: list[ExcludeItem] | None = None
                """The same source must not be present both in `exclude` and `include` list."""
                include: list[IncludeItem] | None = None
                """The same source must not be present both in `exclude` and `include` list."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    group: str = None,
                    exclude: list[ExcludeItem] | None = None,
                    include: list[IncludeItem] | None = None,
                ) -> None:
                    """
                    GroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        group: Multicast Address.
                        exclude: The same source must not be present both in `exclude` and `include` list.
                        include: The same source must not be present both in `exclude` and `include` list.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AccessListsItem(AvdBase):
                _fields = ("_custom_data", "name")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None) -> None:
                    """
                    AccessListsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "enabled", "groups", "report_interval", "access_lists", "version")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool | None = None
            groups: list[GroupsItem] | None = None
            report_interval: Annotated[int, Min[1], Max[31744]] | None = None
            """Time interval between unsolicited reports."""
            access_lists: list[AccessListsItem] | None = None
            """Non-standard Access List name."""
            version: Annotated[int, Min[1], Max[3]] | None = None
            """IGMP version on IGMP host-proxy interface."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enabled: bool | None = None,
                groups: list[GroupsItem] | None = None,
                report_interval: Annotated[int, Min[1], Max[31744]] | None = None,
                access_lists: list[AccessListsItem] | None = None,
                version: Annotated[int, Min[1], Max[3]] | None = None,
            ) -> None:
                """
                IpIgmpHostProxy.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    groups: groups
                    report_interval: Time interval between unsolicited reports.
                    access_lists: Non-standard Access List name.
                    version: IGMP version on IGMP host-proxy interface.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Sflow(AvdBase):
            class Egress(AvdBase):
                _fields = ("_custom_data", "enable", "unmodified_enable")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enable: bool | None = None
                unmodified_enable: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, enable: bool | None = None, unmodified_enable: bool | None = None) -> None:
                    """
                    Egress.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enable: enable
                        unmodified_enable: unmodified_enable

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "enable", "egress")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enable: bool | None = None
            egress: Egress | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, enable: bool | None = None, egress: Egress | None = None) -> None:
                """
                Sflow.

                Args:
                -----
                    _custom_data: _custom_data
                    enable: enable
                    egress: egress

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Switchport(AvdBase):
            class Trunk(AvdBase):
                _fields = ("_custom_data", "allowed_vlan", "native_vlan", "native_vlan_tag", "private_vlan_secondary", "groups")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                allowed_vlan: str | None = None
                """
                VLAN ID or range(s) of VLAN IDs (1-4094).
                Warning: This should not be combined with
                `port_channel_interfaces[].mode = trunk` and `port_channel_interfaces[].vlans`.
                """
                native_vlan: Annotated[int, Min[1], Max[4094]] | None = None
                """
                Set native VLAN when interface is in trunking mode.
                Warning: This should not be combined with
                `port_channel_interfaces[].native_vlan`.
                """
                native_vlan_tag: bool | None = None
                """
                If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                Warning: This
                should not be combined with `port_channel_interfaces[].native_vlan_tag`.
                """
                private_vlan_secondary: bool | None = None
                """
                Enable secondary VLAN mapping for a private vlan.
                Warning: This should not be combined with
                `port_channel_interfaces[].trunk_private_vlan_secondary`.
                """
                groups: list[str] | None = None
                """Warning: This should not be combined with `port_channel_interfaces[].trunk_groups`."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    allowed_vlan: str | None = None,
                    native_vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                    native_vlan_tag: bool | None = None,
                    private_vlan_secondary: bool | None = None,
                    groups: list[str] | None = None,
                ) -> None:
                    """
                    Trunk.

                    Args:
                    -----
                        _custom_data: _custom_data
                        allowed_vlan:
                           VLAN ID or range(s) of VLAN IDs (1-4094).
                           Warning: This should not be combined with
                           `port_channel_interfaces[].mode = trunk` and `port_channel_interfaces[].vlans`.
                        native_vlan:
                           Set native VLAN when interface is in trunking mode.
                           Warning: This should not be combined with
                           `port_channel_interfaces[].native_vlan`.
                        native_vlan_tag:
                           If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                           Warning: This
                           should not be combined with `port_channel_interfaces[].native_vlan_tag`.
                        private_vlan_secondary:
                           Enable secondary VLAN mapping for a private vlan.
                           Warning: This should not be combined with
                           `port_channel_interfaces[].trunk_private_vlan_secondary`.
                        groups: Warning: This should not be combined with `port_channel_interfaces[].trunk_groups`.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Phone(AvdBase):
                _fields = ("_custom_data", "vlan", "trunk")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                vlan: Annotated[int, Min[1], Max[4094]] | None = None
                """Warning: This should not be combined with `port_channel_interfaces[].phone.vlan`."""
                trunk: Annotated[str, ValidValues["tagged", "tagged phone", "untagged", "untagged phone"]] | None = None
                """Warning: This should not be combined with `port_channel_interfaces[].phone.trunk`"""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                    trunk: Annotated[str, ValidValues["tagged", "tagged phone", "untagged", "untagged phone"]] | None = None,
                ) -> None:
                    """
                    Phone.

                    Args:
                    -----
                        _custom_data: _custom_data
                        vlan: Warning: This should not be combined with `port_channel_interfaces[].phone.vlan`.
                        trunk: Warning: This should not be combined with `port_channel_interfaces[].phone.trunk`

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Dot1q(AvdBase):
                _fields = ("_custom_data", "ethertype", "vlan_tag")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ethertype: Annotated[int, Min[1536], Max[65535]] | None = None
                """Ethertype/TPID (Tag Protocol IDentifier) for VLAN tagged frames."""
                vlan_tag: Annotated[str, ValidValues["disallowed", "required"]] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    ethertype: Annotated[int, Min[1536], Max[65535]] | None = None,
                    vlan_tag: Annotated[str, ValidValues["disallowed", "required"]] | None = None,
                ) -> None:
                    """
                    Dot1q.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ethertype: Ethertype/TPID (Tag Protocol IDentifier) for VLAN tagged frames.
                        vlan_tag: vlan_tag

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class VlanTranslations(AvdBase):
                class DirectionInItem(AvdBase):
                    _fields = ("_custom_data", "field_from", "to", "dot1q_tunnel", "inner_vlan_from")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    field_from: str | None = None
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: Annotated[int, Min[1], Max[4094]] | None = None
                    """VLAN ID to map to."""
                    dot1q_tunnel: bool | None = None
                    inner_vlan_from: Annotated[int, Min[1], Max[4094]] | None = None
                    """Inner VLAN ID to map from."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        field_from: str | None = None,
                        to: Annotated[int, Min[1], Max[4094]] | None = None,
                        dot1q_tunnel: bool | None = None,
                        inner_vlan_from: Annotated[int, Min[1], Max[4094]] | None = None,
                    ) -> None:
                        """
                        DirectionInItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                            to: VLAN ID to map to.
                            dot1q_tunnel: dot1q_tunnel
                            inner_vlan_from: Inner VLAN ID to map from.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class DirectionOutItem(AvdBase):
                    _fields = ("_custom_data", "field_from", "to", "dot1q_tunnel_to", "inner_vlan_to")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    field_from: str = None
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: Annotated[int, Min[1], Max[4094]] | None = None
                    """VLAN ID to map to."""
                    dot1q_tunnel_to: str | None = None
                    """
                    VLAN ID or range of VLAN IDs or "all". Range 1-4094.
                    This takes precedence over `to` and
                    `inner_vlan_to`.
                    """
                    inner_vlan_to: Annotated[int, Min[1], Max[4094]] | None = None
                    """Inner VLAN ID to map to."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        field_from: str = None,
                        to: Annotated[int, Min[1], Max[4094]] | None = None,
                        dot1q_tunnel_to: str | None = None,
                        inner_vlan_to: Annotated[int, Min[1], Max[4094]] | None = None,
                    ) -> None:
                        """
                        DirectionOutItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                            to: VLAN ID to map to.
                            dot1q_tunnel_to:
                               VLAN ID or range of VLAN IDs or "all". Range 1-4094.
                               This takes precedence over `to` and
                               `inner_vlan_to`.
                            inner_vlan_to: Inner VLAN ID to map to.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class DirectionBothItem(AvdBase):
                    _fields = ("_custom_data", "field_from", "to", "dot1q_tunnel", "inner_vlan_from", "network")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    field_from: str = None
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: Annotated[int, Min[1], Max[4094]] = None
                    """VLAN ID to map to."""
                    dot1q_tunnel: bool | None = None
                    inner_vlan_from: Annotated[int, Min[1], Max[4094]] | None = None
                    """Inner VLAN ID to map from."""
                    network: bool | None = None
                    """
                    Enable use of network-side VLAN ID.
                    This setting can only be enabled when `inner_vlan_from` is
                    defined.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        field_from: str = None,
                        to: Annotated[int, Min[1], Max[4094]] = None,
                        dot1q_tunnel: bool | None = None,
                        inner_vlan_from: Annotated[int, Min[1], Max[4094]] | None = None,
                        network: bool | None = None,
                    ) -> None:
                        """
                        DirectionBothItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                            to: VLAN ID to map to.
                            dot1q_tunnel: dot1q_tunnel
                            inner_vlan_from: Inner VLAN ID to map from.
                            network:
                               Enable use of network-side VLAN ID.
                               This setting can only be enabled when `inner_vlan_from` is
                               defined.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "in_required", "out_required", "direction_in", "direction_out", "direction_both")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                in_required: bool | None = None
                """Drop the ingress traffic that do not match any VLAN mapping."""
                out_required: bool | None = None
                """Drop the egress traffic that do not match any VLAN mapping."""
                direction_in: list[DirectionInItem] | None = None
                """Map ingress traffic only."""
                direction_out: list[DirectionOutItem] | None = None
                """Map egress traffic only."""
                direction_both: list[DirectionBothItem] | None = None
                """Map both egress and ingress traffic."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    in_required: bool | None = None,
                    out_required: bool | None = None,
                    direction_in: list[DirectionInItem] | None = None,
                    direction_out: list[DirectionOutItem] | None = None,
                    direction_both: list[DirectionBothItem] | None = None,
                ) -> None:
                    """
                    VlanTranslations.

                    Args:
                    -----
                        _custom_data: _custom_data
                        in_required: Drop the ingress traffic that do not match any VLAN mapping.
                        out_required: Drop the egress traffic that do not match any VLAN mapping.
                        direction_in: Map ingress traffic only.
                        direction_out: Map egress traffic only.
                        direction_both: Map both egress and ingress traffic.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class BackupLink(AvdBase):
                _fields = ("_custom_data", "interface", "prefer_vlan")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                interface: str = None
                """Backup interface. Example - Ethernet4, Vlan10 etc."""
                prefer_vlan: str | None = None
                """VLANs to carry on the backup interface (1-4094)."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, interface: str = None, prefer_vlan: str | None = None) -> None:
                    """
                    BackupLink.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interface: Backup interface. Example - Ethernet4, Vlan10 etc.
                        prefer_vlan: VLANs to carry on the backup interface (1-4094).

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Backup(AvdBase):
                _fields = ("_custom_data", "dest_macaddr", "initial_mac_move_delay", "mac_move_burst", "mac_move_burst_interval", "preemption_delay")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                dest_macaddr: Annotated[str, Format["mac"]] | None = None
                """
                Destination MAC address for MAC move updates.
                The mac address should be multicast or broadcast.
                Example: 01:00:00:00:00:00
                """
                initial_mac_move_delay: Annotated[int, Max[65535]] | None = None
                """Initial MAC move delay in milliseconds."""
                mac_move_burst: Annotated[int, Max[65535]] | None = None
                """Size of MAC move bursts."""
                mac_move_burst_interval: Annotated[int, Max[65535]] | None = None
                """MAC move burst interval in milliseconds."""
                preemption_delay: Annotated[int, Max[65535]] | None = None
                """Preemption delay in milliseconds."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    dest_macaddr: Annotated[str, Format["mac"]] | None = None,
                    initial_mac_move_delay: Annotated[int, Max[65535]] | None = None,
                    mac_move_burst: Annotated[int, Max[65535]] | None = None,
                    mac_move_burst_interval: Annotated[int, Max[65535]] | None = None,
                    preemption_delay: Annotated[int, Max[65535]] | None = None,
                ) -> None:
                    """
                    Backup.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dest_macaddr:
                           Destination MAC address for MAC move updates.
                           The mac address should be multicast or broadcast.
                           Example: 01:00:00:00:00:00
                        initial_mac_move_delay: Initial MAC move delay in milliseconds.
                        mac_move_burst: Size of MAC move bursts.
                        mac_move_burst_interval: MAC move burst interval in milliseconds.
                        preemption_delay: Preemption delay in milliseconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PortSecurity(AvdBase):
                class MacAddressMaximum(AvdBase):
                    _fields = ("_custom_data", "disabled", "limit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    disabled: bool | None = None
                    """Disable port level check for port security (only in violation 'shutdown' mode)."""
                    limit: Annotated[int, Min[1], Max[1000]] | None = None
                    """MAC address limit."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        disabled: bool | None = None,
                        limit: Annotated[int, Min[1], Max[1000]] | None = None,
                    ) -> None:
                        """
                        MacAddressMaximum.

                        Args:
                        -----
                            _custom_data: _custom_data
                            disabled: Disable port level check for port security (only in violation 'shutdown' mode).
                            limit: MAC address limit.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Violation(AvdBase):
                    _fields = ("_custom_data", "mode", "protect_log")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    mode: Annotated[str, ValidValues["shutdown", "protect"]] | None = None
                    """Configure port security mode."""
                    protect_log: bool | None = None
                    """Log new addresses seen after limit is reached in protect mode."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        mode: Annotated[str, ValidValues["shutdown", "protect"]] | None = None,
                        protect_log: bool | None = None,
                    ) -> None:
                        """
                        Violation.

                        Args:
                        -----
                            _custom_data: _custom_data
                            mode: Configure port security mode.
                            protect_log: Log new addresses seen after limit is reached in protect mode.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class VlansItem(AvdBase):
                    _fields = ("_custom_data", "range", "mac_address_maximum")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    range: str = None
                    """
                    VLAN ID or range(s) of VLAN IDs, <1-4094>.
                    Example:
                      - 3
                      - 1,3
                      - 1-10
                    """
                    mac_address_maximum: int | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, range: str = None, mac_address_maximum: int | None = None) -> None:
                        """
                        VlansItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            range:
                               VLAN ID or range(s) of VLAN IDs, <1-4094>.

                        Example:
                                 - 3
                                 - 1,3
                                 - 1-10
                            mac_address_maximum: mac_address_maximum

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "enabled", "mac_address_maximum", "violation", "vlan_default_mac_address_maximum", "vlans")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                mac_address_maximum: MacAddressMaximum | None = None
                """Maximum number of MAC addresses allowed on the interface."""
                violation: Violation | None = None
                """Configure violation mode (shutdown or protect), EOS default is 'shutdown'."""
                vlan_default_mac_address_maximum: Annotated[int, Max[1000]] | None = None
                """Default maximum MAC addresses for all VLANs on this interface."""
                vlans: list[VlansItem] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    enabled: bool | None = None,
                    mac_address_maximum: MacAddressMaximum | None = None,
                    violation: Violation | None = None,
                    vlan_default_mac_address_maximum: Annotated[int, Max[1000]] | None = None,
                    vlans: list[VlansItem] | None = None,
                ) -> None:
                    """
                    PortSecurity.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        mac_address_maximum: Maximum number of MAC addresses allowed on the interface.
                        violation: Configure violation mode (shutdown or protect), EOS default is 'shutdown'.
                        vlan_default_mac_address_maximum: Default maximum MAC addresses for all VLANs on this interface.
                        vlans: vlans

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = (
                "_custom_data",
                "enabled",
                "mode",
                "access_vlan",
                "trunk",
                "phone",
                "pvlan_mapping",
                "dot1q",
                "source_interface",
                "vlan_translations",
                "vlan_forwarding_accept_all",
                "backup_link",
                "backup",
                "port_security",
            )
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool | None = None
            """Warning: This should not be combined with `port_channel_interfaces[].type = routed`."""
            mode: Annotated[str, ValidValues["access", "dot1q-tunnel", "trunk", "trunk phone"]] | None = None
            """Warning: This should not be combined with `port_channel_interfaces[].mode`"""
            access_vlan: Annotated[int, Min[1], Max[4094]] | None = None
            """
            Set VLAN when interface is in access mode.
            Warning: This should not be combined with
            `port_channel_interfaces[].mode = access/dot1q-tunnel` and `port_channel_interface.vlans`.
            """
            trunk: Trunk | None = None
            phone: Phone | None = None
            pvlan_mapping: str | None = None
            """
            Secondary VLAN IDs of the private VLAN mapping.
            Warning: This should not be combined with
            `port_channel_interfaces[].pvlan_mapping`.
            """
            dot1q: Dot1q | None = None
            source_interface: Annotated[str, ValidValues["tx", "tx multicast"]] | None = None
            """
            tx: Allow bridged traffic to go out of the source interface.
            tx multicast: Allow multicast traffic
            only to go out of the source interface.
            """
            vlan_translations: VlanTranslations | None = None
            """
            VLAN Translation mappings.
            Warning: This should not be combined with
            `port_channel_interfaces[].vlan_translations`.
            """
            vlan_forwarding_accept_all: bool | None = None
            backup_link: BackupLink | None = None
            backup: Backup | None = None
            """The `backup_link` is required for this setting."""
            port_security: PortSecurity | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enabled: bool | None = None,
                mode: Annotated[str, ValidValues["access", "dot1q-tunnel", "trunk", "trunk phone"]] | None = None,
                access_vlan: Annotated[int, Min[1], Max[4094]] | None = None,
                trunk: Trunk | None = None,
                phone: Phone | None = None,
                pvlan_mapping: str | None = None,
                dot1q: Dot1q | None = None,
                source_interface: Annotated[str, ValidValues["tx", "tx multicast"]] | None = None,
                vlan_translations: VlanTranslations | None = None,
                vlan_forwarding_accept_all: bool | None = None,
                backup_link: BackupLink | None = None,
                backup: Backup | None = None,
                port_security: PortSecurity | None = None,
            ) -> None:
                """
                Switchport.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: Warning: This should not be combined with `port_channel_interfaces[].type = routed`.
                    mode: Warning: This should not be combined with `port_channel_interfaces[].mode`
                    access_vlan:
                       Set VLAN when interface is in access mode.
                       Warning: This should not be combined with
                       `port_channel_interfaces[].mode = access/dot1q-tunnel` and `port_channel_interface.vlans`.
                    trunk: trunk
                    phone: phone
                    pvlan_mapping:
                       Secondary VLAN IDs of the private VLAN mapping.
                       Warning: This should not be combined with
                       `port_channel_interfaces[].pvlan_mapping`.
                    dot1q: dot1q
                    source_interface:
                       tx: Allow bridged traffic to go out of the source interface.
                       tx multicast: Allow multicast traffic
                       only to go out of the source interface.
                    vlan_translations:
                       VLAN Translation mappings.
                       Warning: This should not be combined with
                       `port_channel_interfaces[].vlan_translations`.
                    vlan_forwarding_accept_all: vlan_forwarding_accept_all
                    backup_link: backup_link
                    backup: The `backup_link` is required for this setting.
                    port_security: port_security

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "name",
            "description",
            "logging",
            "shutdown",
            "l2_mtu",
            "l2_mru",
            "vlans",
            "snmp_trap_link_change",
            "type",
            "encapsulation_dot1q_vlan",
            "encapsulation_dot1q",
            "vrf",
            "encapsulation_vlan",
            "vlan_id",
            "mode",
            "native_vlan",
            "native_vlan_tag",
            "link_tracking_groups",
            "phone",
            "l2_protocol",
            "mtu",
            "mlag",
            "trunk_groups",
            "lacp_fallback_timeout",
            "lacp_fallback_mode",
            "qos",
            "bfd",
            "service_policy",
            "mpls",
            "trunk_private_vlan_secondary",
            "pvlan_mapping",
            "vlan_translations",
            "shape",
            "storm_control",
            "ip_proxy_arp",
            "isis_enable",
            "isis_bfd",
            "isis_passive",
            "isis_metric",
            "isis_network_point_to_point",
            "isis_circuit_type",
            "isis_hello_padding",
            "isis_authentication_mode",
            "isis_authentication_key",
            "traffic_policy",
            "evpn_ethernet_segment",
            "lacp_id",
            "spanning_tree_bpdufilter",
            "spanning_tree_bpduguard",
            "spanning_tree_guard",
            "spanning_tree_portfast",
            "vmtracer",
            "ptp",
            "ip_address",
            "ip_verify_unicast_source_reachable_via",
            "ip_nat",
            "ipv6_enable",
            "ipv6_address",
            "ipv6_address_link_local",
            "ipv6_nd_ra_disabled",
            "ipv6_nd_managed_config_flag",
            "ipv6_nd_prefixes",
            "access_group_in",
            "access_group_out",
            "ipv6_access_group_in",
            "ipv6_access_group_out",
            "mac_access_group_in",
            "mac_access_group_out",
            "pim",
            "service_profile",
            "ospf_network_point_to_point",
            "ospf_area",
            "ospf_cost",
            "ospf_authentication",
            "ospf_authentication_key",
            "ospf_message_digest_keys",
            "flow_tracker",
            "bgp",
            "ip_igmp_host_proxy",
            "peer",
            "peer_interface",
            "peer_type",
            "sflow",
            "switchport",
            "validate_state",
            "eos_cli",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        description: str | None = None
        logging: Logging | None = None
        shutdown: bool | None = None
        l2_mtu: Annotated[int, Min[68], Max[65535]] | None = None
        """"l2_mtu" should only be defined for platforms supporting the "l2 mtu" CLI."""
        l2_mru: Annotated[int, Min[68], Max[65535]] | None = None
        """"l2_mru" should only be defined for platforms supporting the "l2 mru" CLI."""
        vlans: str | None = None
        """
        List of switchport vlans as string.
        For a trunk port this would be a range like "1-200,300".
        For an
        access port this would be a single vlan "123".
        """
        snmp_trap_link_change: bool | None = None
        type: Annotated[str, ValidValues["routed", "switched", "l3dot1q", "l2dot1q"]] | None = None
        """
        l3dot1q and l2dot1q are used for sub-interfaces. The parent interface should be defined as routed.
        Interface will not be listed in device documentation, unless "type" is set.
        """
        encapsulation_dot1q_vlan: int | None = None
        """VLAN tag to configure on sub-interface."""
        encapsulation_dot1q: EncapsulationDot1q | None = None
        """
        Warning: `encapsulation_dot1q` should not be combined with `ethernet_interfaces[].type: l3dot1q` or
        `ethernet_interfaces[].type: l2dot1q`.
        """
        vrf: str | None = None
        """VRF name."""
        encapsulation_vlan: EncapsulationVlan | None = None
        """
        This setting can only be applied to sub-interfaces on EOS.
        Warning: `encapsulation_vlan` should not
        be combined with `ethernet_interfaces[].type: l3dot1q` or `ethernet_interfaces[].type: l2dot1q`.
        """
        vlan_id: Annotated[int, Min[1], Max[4094]] | None = None
        """
        This setting can only be applied to sub-interfaces on EOS.
        Warning: `vlan_id` should not be combined
        with `ethernet_interfaces[].type == l2dot1q`.
        """
        mode: Annotated[str, ValidValues["access", "dot1q-tunnel", "trunk", "trunk phone"]] | None = None
        native_vlan: int | None = None
        """If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence."""
        native_vlan_tag: bool | None = False
        """If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence."""
        link_tracking_groups: list[LinkTrackingGroupsItem] | None = None
        phone: Phone | None = None
        l2_protocol: L2Protocol | None = None
        mtu: Annotated[int, Min[68], Max[65535]] | None = None
        mlag: Annotated[int, Min[1], Max[2000]] | None = None
        """MLAG ID."""
        trunk_groups: list[str] | None = None
        lacp_fallback_timeout: Annotated[int, Max[300]] | None = 90
        """Timeout in seconds."""
        lacp_fallback_mode: Annotated[str, ValidValues["individual", "static"]] | None = None
        qos: Qos | None = None
        bfd: Bfd | None = None
        service_policy: ServicePolicy | None = None
        mpls: Mpls | None = None
        trunk_private_vlan_secondary: bool | None = None
        pvlan_mapping: str | None = None
        """List of vlans as string."""
        vlan_translations: list[VlanTranslationsItem] | None = None
        shape: Shape | None = None
        storm_control: StormControl | None = None
        ip_proxy_arp: bool | None = None
        isis_enable: str | None = None
        """ISIS instance."""
        isis_bfd: bool | None = None
        """Enable BFD for ISIS."""
        isis_passive: bool | None = None
        isis_metric: int | None = None
        isis_network_point_to_point: bool | None = None
        isis_circuit_type: Annotated[str, ValidValues["level-1-2", "level-1", "level-2"]] | None = None
        isis_hello_padding: bool | None = None
        isis_authentication_mode: Annotated[str, ValidValues["text", "md5"]] | None = None
        isis_authentication_key: str | None = None
        """Type-7 encrypted password."""
        traffic_policy: TrafficPolicy | None = None
        evpn_ethernet_segment: EvpnEthernetSegment | None = None
        lacp_id: str | None = None
        """LACP ID with format xxxx.xxxx.xxxx."""
        spanning_tree_bpdufilter: Annotated[str, ValidValues["enabled", "disabled", "True", "False", "true", "false"]] | None = None
        spanning_tree_bpduguard: Annotated[str, ValidValues["enabled", "disabled", "True", "False", "true", "false"]] | None = None
        spanning_tree_guard: Annotated[str, ValidValues["loop", "root", "disabled"]] | None = None
        spanning_tree_portfast: Annotated[str, ValidValues["edge", "network"]] | None = None
        vmtracer: bool | None = None
        ptp: Ptp | None = None
        ip_address: str | None = None
        """IPv4 address/mask."""
        ip_verify_unicast_source_reachable_via: Annotated[str, ValidValues["any", "rx"]] | None = None
        ip_nat: IpNat | None = None
        ipv6_enable: bool | None = None
        ipv6_address: str | None = None
        """IPv6 address/mask."""
        ipv6_address_link_local: str | None = None
        """Link local IPv6 address/mask."""
        ipv6_nd_ra_disabled: bool | None = None
        ipv6_nd_managed_config_flag: bool | None = None
        ipv6_nd_prefixes: list[Ipv6NdPrefixesItem] | None = None
        access_group_in: str | None = None
        """Access list name."""
        access_group_out: str | None = None
        """Access list name."""
        ipv6_access_group_in: str | None = None
        """IPv6 access list name."""
        ipv6_access_group_out: str | None = None
        """IPv6 access list name."""
        mac_access_group_in: str | None = None
        """MAC access list name."""
        mac_access_group_out: str | None = None
        """MAC access list name."""
        pim: Pim | None = None
        service_profile: str | None = None
        """QOS profile."""
        ospf_network_point_to_point: bool | None = None
        ospf_area: str | None = None
        ospf_cost: int | None = None
        ospf_authentication: Annotated[str, ValidValues["none", "simple", "message-digest"]] | None = None
        ospf_authentication_key: str | None = None
        """Encrypted password."""
        ospf_message_digest_keys: list[OspfMessageDigestKeysItem] | None = None
        flow_tracker: FlowTracker | None = None
        bgp: Bgp | None = None
        ip_igmp_host_proxy: IpIgmpHostProxy | None = None
        peer: str | None = None
        """Key only used for documentation or validation purposes."""
        peer_interface: str | None = None
        """Key only used for documentation or validation purposes."""
        peer_type: str | None = None
        """Key only used for documentation or validation purposes."""
        sflow: Sflow | None = None
        switchport: Switchport | None = None
        validate_state: bool | None = None
        """Set to false to disable interface validation by the `eos_validate_state` role."""
        eos_cli: str | None = None
        """Multiline EOS CLI rendered directly on the port-channel interface in the final EOS configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str = None,
            description: str | None = None,
            logging: Logging | None = None,
            shutdown: bool | None = None,
            l2_mtu: Annotated[int, Min[68], Max[65535]] | None = None,
            l2_mru: Annotated[int, Min[68], Max[65535]] | None = None,
            vlans: str | None = None,
            snmp_trap_link_change: bool | None = None,
            type: Annotated[str, ValidValues["routed", "switched", "l3dot1q", "l2dot1q"]] | None = None,
            encapsulation_dot1q_vlan: int | None = None,
            encapsulation_dot1q: EncapsulationDot1q | None = None,
            vrf: str | None = None,
            encapsulation_vlan: EncapsulationVlan | None = None,
            vlan_id: Annotated[int, Min[1], Max[4094]] | None = None,
            mode: Annotated[str, ValidValues["access", "dot1q-tunnel", "trunk", "trunk phone"]] | None = None,
            native_vlan: int | None = None,
            native_vlan_tag: bool | None = False,
            link_tracking_groups: list[LinkTrackingGroupsItem] | None = None,
            phone: Phone | None = None,
            l2_protocol: L2Protocol | None = None,
            mtu: Annotated[int, Min[68], Max[65535]] | None = None,
            mlag: Annotated[int, Min[1], Max[2000]] | None = None,
            trunk_groups: list[str] | None = None,
            lacp_fallback_timeout: Annotated[int, Max[300]] | None = 90,
            lacp_fallback_mode: Annotated[str, ValidValues["individual", "static"]] | None = None,
            qos: Qos | None = None,
            bfd: Bfd | None = None,
            service_policy: ServicePolicy | None = None,
            mpls: Mpls | None = None,
            trunk_private_vlan_secondary: bool | None = None,
            pvlan_mapping: str | None = None,
            vlan_translations: list[VlanTranslationsItem] | None = None,
            shape: Shape | None = None,
            storm_control: StormControl | None = None,
            ip_proxy_arp: bool | None = None,
            isis_enable: str | None = None,
            isis_bfd: bool | None = None,
            isis_passive: bool | None = None,
            isis_metric: int | None = None,
            isis_network_point_to_point: bool | None = None,
            isis_circuit_type: Annotated[str, ValidValues["level-1-2", "level-1", "level-2"]] | None = None,
            isis_hello_padding: bool | None = None,
            isis_authentication_mode: Annotated[str, ValidValues["text", "md5"]] | None = None,
            isis_authentication_key: str | None = None,
            traffic_policy: TrafficPolicy | None = None,
            evpn_ethernet_segment: EvpnEthernetSegment | None = None,
            lacp_id: str | None = None,
            spanning_tree_bpdufilter: Annotated[str, ValidValues["enabled", "disabled", "True", "False", "true", "false"]] | None = None,
            spanning_tree_bpduguard: Annotated[str, ValidValues["enabled", "disabled", "True", "False", "true", "false"]] | None = None,
            spanning_tree_guard: Annotated[str, ValidValues["loop", "root", "disabled"]] | None = None,
            spanning_tree_portfast: Annotated[str, ValidValues["edge", "network"]] | None = None,
            vmtracer: bool | None = None,
            ptp: Ptp | None = None,
            ip_address: str | None = None,
            ip_verify_unicast_source_reachable_via: Annotated[str, ValidValues["any", "rx"]] | None = None,
            ip_nat: IpNat | None = None,
            ipv6_enable: bool | None = None,
            ipv6_address: str | None = None,
            ipv6_address_link_local: str | None = None,
            ipv6_nd_ra_disabled: bool | None = None,
            ipv6_nd_managed_config_flag: bool | None = None,
            ipv6_nd_prefixes: list[Ipv6NdPrefixesItem] | None = None,
            access_group_in: str | None = None,
            access_group_out: str | None = None,
            ipv6_access_group_in: str | None = None,
            ipv6_access_group_out: str | None = None,
            mac_access_group_in: str | None = None,
            mac_access_group_out: str | None = None,
            pim: Pim | None = None,
            service_profile: str | None = None,
            ospf_network_point_to_point: bool | None = None,
            ospf_area: str | None = None,
            ospf_cost: int | None = None,
            ospf_authentication: Annotated[str, ValidValues["none", "simple", "message-digest"]] | None = None,
            ospf_authentication_key: str | None = None,
            ospf_message_digest_keys: list[OspfMessageDigestKeysItem] | None = None,
            flow_tracker: FlowTracker | None = None,
            bgp: Bgp | None = None,
            ip_igmp_host_proxy: IpIgmpHostProxy | None = None,
            peer: str | None = None,
            peer_interface: str | None = None,
            peer_type: str | None = None,
            sflow: Sflow | None = None,
            switchport: Switchport | None = None,
            validate_state: bool | None = None,
            eos_cli: str | None = None,
        ) -> None:
            """
            PortChannelInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: name
                description: description
                logging: logging
                shutdown: shutdown
                l2_mtu: "l2_mtu" should only be defined for platforms supporting the "l2 mtu" CLI.
                l2_mru: "l2_mru" should only be defined for platforms supporting the "l2 mru" CLI.
                vlans:
                   List of switchport vlans as string.
                   For a trunk port this would be a range like "1-200,300".
                   For an
                   access port this would be a single vlan "123".
                snmp_trap_link_change: snmp_trap_link_change
                type:
                   l3dot1q and l2dot1q are used for sub-interfaces. The parent interface should be defined as routed.
                   Interface will not be listed in device documentation, unless "type" is set.
                encapsulation_dot1q_vlan: VLAN tag to configure on sub-interface.
                encapsulation_dot1q:
                   Warning: `encapsulation_dot1q` should not be combined with `ethernet_interfaces[].type: l3dot1q` or
                   `ethernet_interfaces[].type: l2dot1q`.
                vrf: VRF name.
                encapsulation_vlan:
                   This setting can only be applied to sub-interfaces on EOS.
                   Warning: `encapsulation_vlan` should not
                   be combined with `ethernet_interfaces[].type: l3dot1q` or `ethernet_interfaces[].type: l2dot1q`.
                vlan_id:
                   This setting can only be applied to sub-interfaces on EOS.
                   Warning: `vlan_id` should not be combined
                   with `ethernet_interfaces[].type == l2dot1q`.
                mode: mode
                native_vlan: If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                native_vlan_tag: If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                link_tracking_groups: link_tracking_groups
                phone: phone
                l2_protocol: l2_protocol
                mtu: mtu
                mlag: MLAG ID.
                trunk_groups: trunk_groups
                lacp_fallback_timeout: Timeout in seconds.
                lacp_fallback_mode: lacp_fallback_mode
                qos: qos
                bfd: bfd
                service_policy: service_policy
                mpls: mpls
                trunk_private_vlan_secondary: trunk_private_vlan_secondary
                pvlan_mapping: List of vlans as string.
                vlan_translations: vlan_translations
                shape: shape
                storm_control: storm_control
                ip_proxy_arp: ip_proxy_arp
                isis_enable: ISIS instance.
                isis_bfd: Enable BFD for ISIS.
                isis_passive: isis_passive
                isis_metric: isis_metric
                isis_network_point_to_point: isis_network_point_to_point
                isis_circuit_type: isis_circuit_type
                isis_hello_padding: isis_hello_padding
                isis_authentication_mode: isis_authentication_mode
                isis_authentication_key: Type-7 encrypted password.
                traffic_policy: traffic_policy
                evpn_ethernet_segment: evpn_ethernet_segment
                lacp_id: LACP ID with format xxxx.xxxx.xxxx.
                spanning_tree_bpdufilter: spanning_tree_bpdufilter
                spanning_tree_bpduguard: spanning_tree_bpduguard
                spanning_tree_guard: spanning_tree_guard
                spanning_tree_portfast: spanning_tree_portfast
                vmtracer: vmtracer
                ptp: ptp
                ip_address: IPv4 address/mask.
                ip_verify_unicast_source_reachable_via: ip_verify_unicast_source_reachable_via
                ip_nat: ip_nat
                ipv6_enable: ipv6_enable
                ipv6_address: IPv6 address/mask.
                ipv6_address_link_local: Link local IPv6 address/mask.
                ipv6_nd_ra_disabled: ipv6_nd_ra_disabled
                ipv6_nd_managed_config_flag: ipv6_nd_managed_config_flag
                ipv6_nd_prefixes: ipv6_nd_prefixes
                access_group_in: Access list name.
                access_group_out: Access list name.
                ipv6_access_group_in: IPv6 access list name.
                ipv6_access_group_out: IPv6 access list name.
                mac_access_group_in: MAC access list name.
                mac_access_group_out: MAC access list name.
                pim: pim
                service_profile: QOS profile.
                ospf_network_point_to_point: ospf_network_point_to_point
                ospf_area: ospf_area
                ospf_cost: ospf_cost
                ospf_authentication: ospf_authentication
                ospf_authentication_key: Encrypted password.
                ospf_message_digest_keys: ospf_message_digest_keys
                flow_tracker: flow_tracker
                bgp: bgp
                ip_igmp_host_proxy: ip_igmp_host_proxy
                peer: Key only used for documentation or validation purposes.
                peer_interface: Key only used for documentation or validation purposes.
                peer_type: Key only used for documentation or validation purposes.
                sflow: sflow
                switchport: switchport
                validate_state: Set to false to disable interface validation by the `eos_validate_state` role.
                eos_cli: Multiline EOS CLI rendered directly on the port-channel interface in the final EOS configuration.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class PrefixListsItem(AvdBase):
        class SequenceNumbersItem(AvdBase):
            _fields = ("_custom_data", "sequence", "action")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            sequence: int = None
            """Sequence ID."""
            action: str = None
            """
            Action as string.
            Example: "permit 10.255.0.0/27 eq 32"
            """

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, sequence: int = None, action: str = None) -> None:
                """
                SequenceNumbersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: Sequence ID.
                    action:
                       Action as string.
                       Example: "permit 10.255.0.0/27 eq 32"

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "name", "sequence_numbers")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Prefix-list Name."""
        sequence_numbers: list[SequenceNumbersItem] | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, sequence_numbers: list[SequenceNumbersItem] | None = None) -> None:
            """
            PrefixListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Prefix-list Name.
                sequence_numbers: sequence_numbers

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class PriorityFlowControl(AvdBase):
        class Watchdog(AvdBase):
            _fields = ("_custom_data", "action", "timeout", "polling_interval", "recovery_time", "override_action_drop")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            action: Annotated[str, ValidValues["drop", "no-drop"]] | None = None
            """Action on stuck queue."""
            timeout: Annotated[str, Pattern[r"^\d+(\.\d{1,2})?$"]] | None = None
            """
            Timeout in seconds after which port should be errdisabled or
            should start dropping on congested
            priorities.
            This should be decimal with up to 2 decimal point.
            Example: 0.01 or 60
            """
            polling_interval: Annotated[str, Pattern[r"^\d+(\.\d{1,3})?$"]] | None = None
            """
            Time interval in seconds at which the watchdog should poll the queues.
            This should be decimal with
            up to 3 decimal point.
            Example: 0.005 or 60
            """
            recovery_time: Annotated[str, Pattern[r"^\d+(\.\d{1,2})?$"]] | None = None
            """
            Recovery-time in seconds after which stuck queue should
            recover and start forwarding again.
            This
            should be decimal with up to 2 decimal point.
            Example: 0.01 or 60
            """
            override_action_drop: bool | None = None
            """Override configured action on stuck queue to drop."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                action: Annotated[str, ValidValues["drop", "no-drop"]] | None = None,
                timeout: Annotated[str, Pattern[r"^\d+(\.\d{1,2})?$"]] | None = None,
                polling_interval: Annotated[str, Pattern[r"^\d+(\.\d{1,3})?$"]] | None = None,
                recovery_time: Annotated[str, Pattern[r"^\d+(\.\d{1,2})?$"]] | None = None,
                override_action_drop: bool | None = None,
            ) -> None:
                """
                Watchdog.

                Args:
                -----
                    _custom_data: _custom_data
                    action: Action on stuck queue.
                    timeout:
                       Timeout in seconds after which port should be errdisabled or
                       should start dropping on congested
                       priorities.
                       This should be decimal with up to 2 decimal point.
                       Example: 0.01 or 60
                    polling_interval:
                       Time interval in seconds at which the watchdog should poll the queues.
                       This should be decimal with
                       up to 3 decimal point.
                       Example: 0.005 or 60
                    recovery_time:
                       Recovery-time in seconds after which stuck queue should
                       recover and start forwarding again.
                       This
                       should be decimal with up to 2 decimal point.
                       Example: 0.01 or 60
                    override_action_drop: Override configured action on stuck queue to drop.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "all_off", "watchdog")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        all_off: bool | None = None
        """Disable PFC on all interfaces."""
        watchdog: Watchdog | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, all_off: bool | None = None, watchdog: Watchdog | None = None) -> None:
            """
            PriorityFlowControl.

            Args:
            -----
                _custom_data: _custom_data
                all_off: Disable PFC on all interfaces.
                watchdog: watchdog

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Ptp(AvdBase):
        class Source(AvdBase):
            _fields = ("_custom_data", "ip")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ip: str | None = None
            """Source IP."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, ip: str | None = None) -> None:
                """
                Source.

                Args:
                -----
                    _custom_data: _custom_data
                    ip: Source IP.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class MessageType(AvdBase):
            class General(AvdBase):
                _fields = ("_custom_data", "dscp")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                dscp: int | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, dscp: int | None = None) -> None:
                    """
                    General.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dscp: dscp

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Event(AvdBase):
                _fields = ("_custom_data", "dscp")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                dscp: int | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, dscp: int | None = None) -> None:
                    """
                    Event.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dscp: dscp

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "general", "event")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            general: General | None = None
            event: Event | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, general: General | None = None, event: Event | None = None) -> None:
                """
                MessageType.

                Args:
                -----
                    _custom_data: _custom_data
                    general: general
                    event: event

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Monitor(AvdBase):
            class Threshold(AvdBase):
                class Drop(AvdBase):
                    _fields = ("_custom_data", "offset_from_master", "mean_path_delay")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    offset_from_master: Annotated[int, Max[1000000000]] | None = None
                    mean_path_delay: Annotated[int, Max[1000000000]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        offset_from_master: Annotated[int, Max[1000000000]] | None = None,
                        mean_path_delay: Annotated[int, Max[1000000000]] | None = None,
                    ) -> None:
                        """
                        Drop.

                        Args:
                        -----
                            _custom_data: _custom_data
                            offset_from_master: offset_from_master
                            mean_path_delay: mean_path_delay

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "offset_from_master", "mean_path_delay", "drop")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                offset_from_master: Annotated[int, Max[1000000000]] | None = None
                mean_path_delay: Annotated[int, Max[1000000000]] | None = None
                drop: Drop | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    offset_from_master: Annotated[int, Max[1000000000]] | None = None,
                    mean_path_delay: Annotated[int, Max[1000000000]] | None = None,
                    drop: Drop | None = None,
                ) -> None:
                    """
                    Threshold.

                    Args:
                    -----
                        _custom_data: _custom_data
                        offset_from_master: offset_from_master
                        mean_path_delay: mean_path_delay
                        drop: drop

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class MissingMessage(AvdBase):
                class Intervals(AvdBase):
                    _fields = ("_custom_data", "announce", "follow_up", "sync")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    announce: Annotated[int, Min[2], Max[255]] | None = None
                    follow_up: Annotated[int, Min[2], Max[255]] | None = None
                    sync: Annotated[int, Min[2], Max[255]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        announce: Annotated[int, Min[2], Max[255]] | None = None,
                        follow_up: Annotated[int, Min[2], Max[255]] | None = None,
                        sync: Annotated[int, Min[2], Max[255]] | None = None,
                    ) -> None:
                        """
                        Intervals.

                        Args:
                        -----
                            _custom_data: _custom_data
                            announce: announce
                            follow_up: follow_up
                            sync: sync

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class SequenceIds(AvdBase):
                    _fields = ("_custom_data", "enabled", "announce", "delay_resp", "follow_up", "sync")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None
                    announce: Annotated[int, Min[2], Max[255]] | None = None
                    delay_resp: Annotated[int, Min[2], Max[255]] | None = None
                    follow_up: Annotated[int, Min[2], Max[255]] | None = None
                    sync: Annotated[int, Min[2], Max[255]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        enabled: bool | None = None,
                        announce: Annotated[int, Min[2], Max[255]] | None = None,
                        delay_resp: Annotated[int, Min[2], Max[255]] | None = None,
                        follow_up: Annotated[int, Min[2], Max[255]] | None = None,
                        sync: Annotated[int, Min[2], Max[255]] | None = None,
                    ) -> None:
                        """
                        SequenceIds.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            announce: announce
                            delay_resp: delay_resp
                            follow_up: follow_up
                            sync: sync

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "intervals", "sequence_ids")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                intervals: Intervals | None = None
                sequence_ids: SequenceIds | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, intervals: Intervals | None = None, sequence_ids: SequenceIds | None = None
                ) -> None:
                    """
                    MissingMessage.

                    Args:
                    -----
                        _custom_data: _custom_data
                        intervals: intervals
                        sequence_ids: sequence_ids

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "enabled", "threshold", "missing_message")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool | None = True
            threshold: Threshold | None = None
            missing_message: MissingMessage | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enabled: bool | None = True,
                threshold: Threshold | None = None,
                missing_message: MissingMessage | None = None,
            ) -> None:
                """
                Monitor.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    threshold: threshold
                    missing_message: missing_message

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "mode",
            "profile",
            "mode_one_step",
            "forward_unicast",
            "clock_identity",
            "source",
            "priority1",
            "priority2",
            "ttl",
            "domain",
            "message_type",
            "monitor",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        mode: Annotated[str, ValidValues["boundary", "disabled", "e2etransparent", "gptp", "ordinarymaster", "p2ptransparent"]] | None = None
        profile: Annotated[str, ValidValues["g8275.1", "g8275.2"]] | None = None
        mode_one_step: bool | None = None
        forward_unicast: bool | None = None
        clock_identity: str | None = None
        """The clock-id in xx:xx:xx:xx:xx:xx format."""
        source: Source | None = None
        priority1: Annotated[int, Max[255]] | None = None
        priority2: Annotated[int, Max[255]] | None = None
        ttl: Annotated[int, Min[1], Max[255]] | None = None
        domain: Annotated[int, Max[255]] | None = None
        message_type: MessageType | None = None
        monitor: Monitor | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            mode: Annotated[str, ValidValues["boundary", "disabled", "e2etransparent", "gptp", "ordinarymaster", "p2ptransparent"]] | None = None,
            profile: Annotated[str, ValidValues["g8275.1", "g8275.2"]] | None = None,
            mode_one_step: bool | None = None,
            forward_unicast: bool | None = None,
            clock_identity: str | None = None,
            source: Source | None = None,
            priority1: Annotated[int, Max[255]] | None = None,
            priority2: Annotated[int, Max[255]] | None = None,
            ttl: Annotated[int, Min[1], Max[255]] | None = None,
            domain: Annotated[int, Max[255]] | None = None,
            message_type: MessageType | None = None,
            monitor: Monitor | None = None,
        ) -> None:
            """
            Ptp.

            Args:
            -----
                _custom_data: _custom_data
                mode: mode
                profile: profile
                mode_one_step: mode_one_step
                forward_unicast: forward_unicast
                clock_identity: The clock-id in xx:xx:xx:xx:xx:xx format.
                source: source
                priority1: priority1
                priority2: priority2
                ttl: ttl
                domain: domain
                message_type: message_type
                monitor: monitor

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Qos(AvdBase):
        class Map(AvdBase):
            _fields = ("_custom_data", "cos", "dscp", "exp", "traffic_class")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            cos: list[str] | None = None
            dscp: list[str] | None = None
            exp: list[str] | None = None
            traffic_class: list[str] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                cos: list[str] | None = None,
                dscp: list[str] | None = None,
                exp: list[str] | None = None,
                traffic_class: list[str] | None = None,
            ) -> None:
                """
                Map.

                Args:
                -----
                    _custom_data: _custom_data
                    cos: cos
                    dscp: dscp
                    exp: exp
                    traffic_class: traffic_class

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class RandomDetect(AvdBase):
            class Ecn(AvdBase):
                class AllowNonEct(AvdBase):
                    _fields = ("_custom_data", "enabled", "chip_based")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None
                    """
                    Allow non-ect and set drop-precedence 1 in a policy map simultaneously.
                    Check which command is
                    required for your platform.
                    """
                    chip_based: bool | None = None
                    """Allow non-ect chip-based."""

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, chip_based: bool | None = None) -> None:
                        """
                        AllowNonEct.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled:
                               Allow non-ect and set drop-precedence 1 in a policy map simultaneously.
                               Check which command is
                               required for your platform.
                            chip_based: Allow non-ect chip-based.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "allow_non_ect")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                allow_non_ect: AllowNonEct | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, allow_non_ect: AllowNonEct | None = None) -> None:
                    """
                    Ecn.

                    Args:
                    -----
                        _custom_data: _custom_data
                        allow_non_ect: allow_non_ect

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "ecn")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ecn: Ecn | None = None
            """Global ECN Configuration."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, ecn: Ecn | None = None) -> None:
                """
                RandomDetect.

                Args:
                -----
                    _custom_data: _custom_data
                    ecn: Global ECN Configuration.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "map", "rewrite_dscp", "random_detect")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        map: Map | None = None
        rewrite_dscp: bool | None = None
        random_detect: RandomDetect | None = None
        """Global random-detect settings."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            map: Map | None = None,
            rewrite_dscp: bool | None = None,
            random_detect: RandomDetect | None = None,
        ) -> None:
            """
            Qos.

            Args:
            -----
                _custom_data: _custom_data
                map: map
                rewrite_dscp: rewrite_dscp
                random_detect: Global random-detect settings.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class QosProfilesItem(AvdBase):
        class Shape(AvdBase):
            _fields = ("_custom_data", "rate")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            rate: str | None = None
            """
            Supported options are platform dependent.
            Example: "< rate > kbps", "1-100 percent", "< rate > pps"
            """

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, rate: str | None = None) -> None:
                """
                Shape.

                Args:
                -----
                    _custom_data: _custom_data
                    rate:
                       Supported options are platform dependent.
                       Example: "< rate > kbps", "1-100 percent", "< rate > pps"

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ServicePolicy(AvdBase):
            class Type(AvdBase):
                _fields = ("_custom_data", "qos_input")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                qos_input: str | None = None
                """Policy-map name."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, qos_input: str | None = None) -> None:
                    """
                    Type.

                    Args:
                    -----
                        _custom_data: _custom_data
                        qos_input: Policy-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "type")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            type: Type | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, type: Type | None = None) -> None:
                """
                ServicePolicy.

                Args:
                -----
                    _custom_data: _custom_data
                    type: type

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TxQueuesItem(AvdBase):
            class Shape(AvdBase):
                _fields = ("_custom_data", "rate")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                rate: str | None = None
                """
                Supported options are platform dependent.
                Example: "< rate > kbps", "1-100 percent", "< rate > pps"
                """

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, rate: str | None = None) -> None:
                    """
                    Shape.

                    Args:
                    -----
                        _custom_data: _custom_data
                        rate:
                           Supported options are platform dependent.
                           Example: "< rate > kbps", "1-100 percent", "< rate > pps"

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RandomDetect(AvdBase):
                class Ecn(AvdBase):
                    class Threshold(AvdBase):
                        _fields = ("_custom_data", "units", "min", "max", "max_probability", "weight")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        units: Annotated[str, ValidValues["segments", "bytes", "kbytes", "mbytes", "milliseconds"]] = None
                        """
                        Units to be used for the threshold values.
                        This should be one of segments, byte, kbytes, mbytes.
                        """
                        min: Annotated[int, Min[1]] = None
                        """Random-detect ECN minimum-threshold."""
                        max: Annotated[int, Min[1]] = None
                        """Random-detect ECN maximum-threshold."""
                        max_probability: Annotated[int, Min[1], Max[100]] | None = None
                        """Random-detect ECN maximum mark probability."""
                        weight: Annotated[int, Max[15]] | None = None
                        """Random-detect ECN weight."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            units: Annotated[str, ValidValues["segments", "bytes", "kbytes", "mbytes", "milliseconds"]] = None,
                            min: Annotated[int, Min[1]] = None,
                            max: Annotated[int, Min[1]] = None,
                            max_probability: Annotated[int, Min[1], Max[100]] | None = None,
                            weight: Annotated[int, Max[15]] | None = None,
                        ) -> None:
                            """
                            Threshold.

                            Args:
                            -----
                                _custom_data: _custom_data
                                units:
                                   Units to be used for the threshold values.
                                   This should be one of segments, byte, kbytes, mbytes.
                                min: Random-detect ECN minimum-threshold.
                                max: Random-detect ECN maximum-threshold.
                                max_probability: Random-detect ECN maximum mark probability.
                                weight: Random-detect ECN weight.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "count", "threshold")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    count: bool | None = None
                    """Enable counter for random-detect ECNs."""
                    threshold: Threshold | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, count: bool | None = None, threshold: Threshold | None = None) -> None:
                        """
                        Ecn.

                        Args:
                        -----
                            _custom_data: _custom_data
                            count: Enable counter for random-detect ECNs.
                            threshold: threshold

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Drop(AvdBase):
                    class Threshold(AvdBase):
                        _fields = ("_custom_data", "units", "drop_precedence", "min", "max", "drop_probability", "weight")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        units: Annotated[str, ValidValues["segments", "bytes", "kbytes", "mbytes", "microseconds", "milliseconds"]] = None
                        """Units to be used for the threshold values."""
                        drop_precedence: Annotated[int, Max[2]] | None = None
                        """Specify Drop Precedence value."""
                        min: Annotated[int, Min[1]] = None
                        """WRED minimum-threshold."""
                        max: Annotated[int, Min[1]] = None
                        """WRED maximum-threshold."""
                        drop_probability: Annotated[int, Min[1], Max[100]] = None
                        """WRED drop probability."""
                        weight: Annotated[int, Max[15]] | None = None
                        """WRED weight."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            units: Annotated[str, ValidValues["segments", "bytes", "kbytes", "mbytes", "microseconds", "milliseconds"]] = None,
                            drop_precedence: Annotated[int, Max[2]] | None = None,
                            min: Annotated[int, Min[1]] = None,
                            max: Annotated[int, Min[1]] = None,
                            drop_probability: Annotated[int, Min[1], Max[100]] = None,
                            weight: Annotated[int, Max[15]] | None = None,
                        ) -> None:
                            """
                            Threshold.

                            Args:
                            -----
                                _custom_data: _custom_data
                                units: Units to be used for the threshold values.
                                drop_precedence: Specify Drop Precedence value.
                                min: WRED minimum-threshold.
                                max: WRED maximum-threshold.
                                drop_probability: WRED drop probability.
                                weight: WRED weight.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "threshold")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    threshold: Threshold | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, threshold: Threshold | None = None) -> None:
                        """
                        Drop.

                        Args:
                        -----
                            _custom_data: _custom_data
                            threshold: threshold

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "ecn", "drop")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ecn: Ecn | None = None
                """Explicit Congestion Notification."""
                drop: Drop | None = None
                """Set WRED parameters."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, ecn: Ecn | None = None, drop: Drop | None = None) -> None:
                    """
                    RandomDetect.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ecn: Explicit Congestion Notification.
                        drop: Set WRED parameters.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "id", "bandwidth_percent", "bandwidth_guaranteed_percent", "priority", "shape", "comment", "random_detect")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            id: int = None
            """TX-Queue ID."""
            bandwidth_percent: int | None = None
            bandwidth_guaranteed_percent: int | None = None
            priority: Annotated[str, ValidValues["priority strict", "no priority"]] | None = None
            shape: Shape | None = None
            comment: str | None = None
            """Text comment added to queue."""
            random_detect: RandomDetect | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                id: int = None,
                bandwidth_percent: int | None = None,
                bandwidth_guaranteed_percent: int | None = None,
                priority: Annotated[str, ValidValues["priority strict", "no priority"]] | None = None,
                shape: Shape | None = None,
                comment: str | None = None,
                random_detect: RandomDetect | None = None,
            ) -> None:
                """
                TxQueuesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: TX-Queue ID.
                    bandwidth_percent: bandwidth_percent
                    bandwidth_guaranteed_percent: bandwidth_guaranteed_percent
                    priority: priority
                    shape: shape
                    comment: Text comment added to queue.
                    random_detect: random_detect

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class UcTxQueuesItem(AvdBase):
            class Shape(AvdBase):
                _fields = ("_custom_data", "rate")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                rate: str | None = None
                """
                Supported options are platform dependent.
                Example: "< rate > kbps", "1-100 percent", "< rate > pps"
                """

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, rate: str | None = None) -> None:
                    """
                    Shape.

                    Args:
                    -----
                        _custom_data: _custom_data
                        rate:
                           Supported options are platform dependent.
                           Example: "< rate > kbps", "1-100 percent", "< rate > pps"

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RandomDetect(AvdBase):
                class Ecn(AvdBase):
                    class Threshold(AvdBase):
                        _fields = ("_custom_data", "units", "min", "max", "max_probability", "weight")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        units: Annotated[str, ValidValues["segments", "bytes", "kbytes", "mbytes", "milliseconds"]] = None
                        """Unit to be used for the threshold values."""
                        min: Annotated[int, Min[1]] = None
                        """Random-detect ECN minimum-threshold."""
                        max: Annotated[int, Min[1]] = None
                        """Random-detect ECN maximum-threshold."""
                        max_probability: Annotated[int, Min[1], Max[100]] | None = None
                        """Random-detect ECN maximum mark probability."""
                        weight: Annotated[int, Max[15]] | None = None
                        """Random-detect ECN weight."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            units: Annotated[str, ValidValues["segments", "bytes", "kbytes", "mbytes", "milliseconds"]] = None,
                            min: Annotated[int, Min[1]] = None,
                            max: Annotated[int, Min[1]] = None,
                            max_probability: Annotated[int, Min[1], Max[100]] | None = None,
                            weight: Annotated[int, Max[15]] | None = None,
                        ) -> None:
                            """
                            Threshold.

                            Args:
                            -----
                                _custom_data: _custom_data
                                units: Unit to be used for the threshold values.
                                min: Random-detect ECN minimum-threshold.
                                max: Random-detect ECN maximum-threshold.
                                max_probability: Random-detect ECN maximum mark probability.
                                weight: Random-detect ECN weight.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "count", "threshold")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    count: bool | None = None
                    """Enable counter for random-detect ECNs."""
                    threshold: Threshold | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, count: bool | None = None, threshold: Threshold | None = None) -> None:
                        """
                        Ecn.

                        Args:
                        -----
                            _custom_data: _custom_data
                            count: Enable counter for random-detect ECNs.
                            threshold: threshold

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Drop(AvdBase):
                    class Threshold(AvdBase):
                        _fields = ("_custom_data", "units", "drop_precedence", "min", "max", "drop_probability", "weight")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        units: Annotated[str, ValidValues["segments", "bytes", "kbytes", "mbytes", "microseconds", "milliseconds"]] = None
                        """Units to be used for the threshold values."""
                        drop_precedence: Annotated[int, Max[2]] | None = None
                        """Specify Drop Precedence value."""
                        min: Annotated[int, Min[1]] = None
                        """WRED minimum-threshold."""
                        max: Annotated[int, Min[1]] = None
                        """WRED maximum-threshold."""
                        drop_probability: Annotated[int, Min[1], Max[100]] = None
                        """WRED drop probability."""
                        weight: Annotated[int, Max[15]] | None = None
                        """WRED weight."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            units: Annotated[str, ValidValues["segments", "bytes", "kbytes", "mbytes", "microseconds", "milliseconds"]] = None,
                            drop_precedence: Annotated[int, Max[2]] | None = None,
                            min: Annotated[int, Min[1]] = None,
                            max: Annotated[int, Min[1]] = None,
                            drop_probability: Annotated[int, Min[1], Max[100]] = None,
                            weight: Annotated[int, Max[15]] | None = None,
                        ) -> None:
                            """
                            Threshold.

                            Args:
                            -----
                                _custom_data: _custom_data
                                units: Units to be used for the threshold values.
                                drop_precedence: Specify Drop Precedence value.
                                min: WRED minimum-threshold.
                                max: WRED maximum-threshold.
                                drop_probability: WRED drop probability.
                                weight: WRED weight.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "threshold")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    threshold: Threshold | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, threshold: Threshold | None = None) -> None:
                        """
                        Drop.

                        Args:
                        -----
                            _custom_data: _custom_data
                            threshold: threshold

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "ecn", "drop")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ecn: Ecn | None = None
                """Explicit Congestion Notification."""
                drop: Drop | None = None
                """Set WRED parameters."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, ecn: Ecn | None = None, drop: Drop | None = None) -> None:
                    """
                    RandomDetect.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ecn: Explicit Congestion Notification.
                        drop: Set WRED parameters.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "id", "bandwidth_percent", "bandwidth_guaranteed_percent", "priority", "shape", "comment", "random_detect")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            id: int = None
            """UC TX queue ID."""
            bandwidth_percent: int | None = None
            bandwidth_guaranteed_percent: int | None = None
            priority: Annotated[str, ValidValues["priority strict", "no priority"]] | None = None
            shape: Shape | None = None
            comment: str | None = None
            """Text comment added to queue."""
            random_detect: RandomDetect | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                id: int = None,
                bandwidth_percent: int | None = None,
                bandwidth_guaranteed_percent: int | None = None,
                priority: Annotated[str, ValidValues["priority strict", "no priority"]] | None = None,
                shape: Shape | None = None,
                comment: str | None = None,
                random_detect: RandomDetect | None = None,
            ) -> None:
                """
                UcTxQueuesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: UC TX queue ID.
                    bandwidth_percent: bandwidth_percent
                    bandwidth_guaranteed_percent: bandwidth_guaranteed_percent
                    priority: priority
                    shape: shape
                    comment: Text comment added to queue.
                    random_detect: random_detect

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class McTxQueuesItem(AvdBase):
            class Shape(AvdBase):
                _fields = ("_custom_data", "rate")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                rate: str | None = None
                """
                Supported options are platform dependent.
                Example: "< rate > kbps", "1-100 percent", "< rate > pps"
                """

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, rate: str | None = None) -> None:
                    """
                    Shape.

                    Args:
                    -----
                        _custom_data: _custom_data
                        rate:
                           Supported options are platform dependent.
                           Example: "< rate > kbps", "1-100 percent", "< rate > pps"

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "id", "bandwidth_percent", "bandwidth_guaranteed_percent", "priority", "shape", "comment")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            id: int = None
            """MC TX queue ID."""
            bandwidth_percent: int | None = None
            bandwidth_guaranteed_percent: int | None = None
            priority: Annotated[str, ValidValues["priority strict", "no priority"]] | None = None
            shape: Shape | None = None
            comment: str | None = None
            """Text comment added to queue."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                id: int = None,
                bandwidth_percent: int | None = None,
                bandwidth_guaranteed_percent: int | None = None,
                priority: Annotated[str, ValidValues["priority strict", "no priority"]] | None = None,
                shape: Shape | None = None,
                comment: str | None = None,
            ) -> None:
                """
                McTxQueuesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: MC TX queue ID.
                    bandwidth_percent: bandwidth_percent
                    bandwidth_guaranteed_percent: bandwidth_guaranteed_percent
                    priority: priority
                    shape: shape
                    comment: Text comment added to queue.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PriorityFlowControl(AvdBase):
            class Watchdog(AvdBase):
                class Timer(AvdBase):
                    _fields = ("_custom_data", "timeout", "polling_interval", "recovery_time", "forced")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    timeout: Annotated[str, Pattern[r"^\d+(\.\d{1,2})?$"]] = None
                    """
                    Timeout in seconds after which port should be errdisabled or
                    should start dropping on congested
                    priorities.
                    This should be decimal with up to 2 decimal point.
                    Example: 0.01 or 60
                    """
                    polling_interval: Annotated[str, Pattern[r"^auto|\d+(\.\d{1,3})?$"]] = None
                    """
                    Time interval in seconds at which the watchdog should poll the queues.
                    This should be decimal with
                    up to 3 decimal point or set
                    to 'auto' based on recovery_time and timeout values.
                    Example: 0.005 or
                    60
                    """
                    recovery_time: Annotated[str, Pattern[r"^\d+(\.\d{1,2})?$"]] = None
                    """
                    Recovery-time in seconds after which stuck queue should
                    recover and start forwarding again.
                    This
                    should be decimal with up to 2 decimal point.
                    Example: 0.01 or 60
                    """
                    forced: bool | None = None
                    """
                    Force recover any stuck queue(s) after the duration,
                    irrespective of whether PFC frames are being
                    received or not.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        timeout: Annotated[str, Pattern[r"^\d+(\.\d{1,2})?$"]] = None,
                        polling_interval: Annotated[str, Pattern[r"^auto|\d+(\.\d{1,3})?$"]] = None,
                        recovery_time: Annotated[str, Pattern[r"^\d+(\.\d{1,2})?$"]] = None,
                        forced: bool | None = None,
                    ) -> None:
                        """
                        Timer.

                        Args:
                        -----
                            _custom_data: _custom_data
                            timeout:
                               Timeout in seconds after which port should be errdisabled or
                               should start dropping on congested
                               priorities.
                               This should be decimal with up to 2 decimal point.
                               Example: 0.01 or 60
                            polling_interval:
                               Time interval in seconds at which the watchdog should poll the queues.
                               This should be decimal with
                               up to 3 decimal point or set
                               to 'auto' based on recovery_time and timeout values.
                               Example: 0.005 or
                               60
                            recovery_time:
                               Recovery-time in seconds after which stuck queue should
                               recover and start forwarding again.
                               This
                               should be decimal with up to 2 decimal point.
                               Example: 0.01 or 60
                            forced:
                               Force recover any stuck queue(s) after the duration,
                               irrespective of whether PFC frames are being
                               received or not.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "enabled", "action", "timer")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool = None
                """Enable the watchdog on stuck transmit queues."""
                action: Annotated[str, ValidValues["drop", "notify-only"]] | None = None
                """
                Override the default error-disable action to either drop
                traffic on the stuck queue or notify-only
                without making any actions on the stuck queue.
                """
                timer: Timer | None = None
                """Timer thresholds whilst monitoring queues."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    enabled: bool = None,
                    action: Annotated[str, ValidValues["drop", "notify-only"]] | None = None,
                    timer: Timer | None = None,
                ) -> None:
                    """
                    Watchdog.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: Enable the watchdog on stuck transmit queues.
                        action:
                           Override the default error-disable action to either drop
                           traffic on the stuck queue or notify-only
                           without making any actions on the stuck queue.
                        timer: Timer thresholds whilst monitoring queues.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PrioritiesItem(AvdBase):
                _fields = ("_custom_data", "priority", "no_drop")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                priority: Annotated[int, Max[7]] = None
                """Priority queue number (COS value)."""
                no_drop: bool = None
                """Enable Priority Flow Control frames on this queue."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, priority: Annotated[int, Max[7]] = None, no_drop: bool = None) -> None:
                    """
                    PrioritiesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        priority: Priority queue number (COS value).
                        no_drop: Enable Priority Flow Control frames on this queue.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "enabled", "watchdog", "priorities")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool | None = None
            """Enable Priority Flow control."""
            watchdog: Watchdog | None = None
            """Watchdog can detect stuck transmit queues."""
            priorities: list[PrioritiesItem] | None = None
            """Set the drop/no_drop on each queue."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enabled: bool | None = None,
                watchdog: Watchdog | None = None,
                priorities: list[PrioritiesItem] | None = None,
            ) -> None:
                """
                PriorityFlowControl.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: Enable Priority Flow control.
                    watchdog: Watchdog can detect stuck transmit queues.
                    priorities: Set the drop/no_drop on each queue.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "name",
            "trust",
            "cos",
            "dscp",
            "shape",
            "service_policy",
            "tx_queues",
            "uc_tx_queues",
            "mc_tx_queues",
            "priority_flow_control",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Profile-Name."""
        trust: Annotated[str, ValidValues["cos", "dscp", "disabled"]] | None = None
        cos: int | None = None
        dscp: int | None = None
        shape: Shape | None = None
        service_policy: ServicePolicy | None = None
        tx_queues: list[TxQueuesItem] | None = None
        uc_tx_queues: list[UcTxQueuesItem] | None = None
        mc_tx_queues: list[McTxQueuesItem] | None = None
        priority_flow_control: PriorityFlowControl | None = None
        """Priority Flow Control settings."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str = None,
            trust: Annotated[str, ValidValues["cos", "dscp", "disabled"]] | None = None,
            cos: int | None = None,
            dscp: int | None = None,
            shape: Shape | None = None,
            service_policy: ServicePolicy | None = None,
            tx_queues: list[TxQueuesItem] | None = None,
            uc_tx_queues: list[UcTxQueuesItem] | None = None,
            mc_tx_queues: list[McTxQueuesItem] | None = None,
            priority_flow_control: PriorityFlowControl | None = None,
        ) -> None:
            """
            QosProfilesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Profile-Name.
                trust: trust
                cos: cos
                dscp: dscp
                shape: shape
                service_policy: service_policy
                tx_queues: tx_queues
                uc_tx_queues: uc_tx_queues
                mc_tx_queues: mc_tx_queues
                priority_flow_control: Priority Flow Control settings.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class QueueMonitorLength(AvdBase):
        class DefaultThresholds(AvdBase):
            _fields = ("_custom_data", "high", "low")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            high: int = None
            """Default high threshold for Ethernet Interfaces."""
            low: int | None = None
            """
            Default low threshold for Ethernet Interfaces.
            Low threshold support is platform dependent.
            """

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, high: int = None, low: int | None = None) -> None:
                """
                DefaultThresholds.

                Args:
                -----
                    _custom_data: _custom_data
                    high: Default high threshold for Ethernet Interfaces.
                    low:
                       Default low threshold for Ethernet Interfaces.
                       Low threshold support is platform dependent.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Cpu(AvdBase):
            class Thresholds(AvdBase):
                _fields = ("_custom_data", "high", "low")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                high: int = None
                low: int | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, high: int = None, low: int | None = None) -> None:
                    """
                    Thresholds.

                    Args:
                    -----
                        _custom_data: _custom_data
                        high: high
                        low: low

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "thresholds")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            thresholds: Thresholds | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, thresholds: Thresholds | None = None) -> None:
                """
                Cpu.

                Args:
                -----
                    _custom_data: _custom_data
                    thresholds: thresholds

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "enabled", "default_thresholds", "log", "notifying", "cpu", "tx_latency")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        enabled: bool = None
        default_thresholds: DefaultThresholds | None = None
        log: int | None = None
        """Logging interval in seconds."""
        notifying: bool | None = None
        """Should only be used for platforms supporting the "queue-monitor length notifying" CLI."""
        cpu: Cpu | None = None
        tx_latency: bool | None = None
        """Enable tx-latency mode."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            enabled: bool = None,
            default_thresholds: DefaultThresholds | None = None,
            log: int | None = None,
            notifying: bool | None = None,
            cpu: Cpu | None = None,
            tx_latency: bool | None = None,
        ) -> None:
            """
            QueueMonitorLength.

            Args:
            -----
                _custom_data: _custom_data
                enabled: enabled
                default_thresholds: default_thresholds
                log: Logging interval in seconds.
                notifying: Should only be used for platforms supporting the "queue-monitor length notifying" CLI.
                cpu: cpu
                tx_latency: Enable tx-latency mode.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class QueueMonitorStreaming(AvdBase):
        _fields = ("_custom_data", "enable", "ip_access_group", "ipv6_access_group", "max_connections", "vrf")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        enable: bool | None = None
        ip_access_group: str | None = None
        """Name of IP ACL."""
        ipv6_access_group: str | None = None
        """Name of IPv6 ACL."""
        max_connections: Annotated[int, Min[1], Max[100]] | None = None
        vrf: str | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            enable: bool | None = None,
            ip_access_group: str | None = None,
            ipv6_access_group: str | None = None,
            max_connections: Annotated[int, Min[1], Max[100]] | None = None,
            vrf: str | None = None,
        ) -> None:
            """
            QueueMonitorStreaming.

            Args:
            -----
                _custom_data: _custom_data
                enable: enable
                ip_access_group: Name of IP ACL.
                ipv6_access_group: Name of IPv6 ACL.
                max_connections: max_connections
                vrf: vrf

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RadiusServer(AvdBase):
        class Attribute32IncludeInAccessReq(AvdBase):
            _fields = ("_custom_data", "hostname", "format")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            hostname: bool | None = None
            format: str | None = None
            """Specify the format of the NAS-Identifier. If 'hostname' is set, this is ignored."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, hostname: bool | None = None, format: str | None = None) -> None:
                """
                Attribute32IncludeInAccessReq.

                Args:
                -----
                    _custom_data: _custom_data
                    hostname: hostname
                    format: Specify the format of the NAS-Identifier. If 'hostname' is set, this is ignored.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class DynamicAuthorization(AvdBase):
            _fields = ("_custom_data", "port", "tls_ssl_profile")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            port: Annotated[int, Max[65535]] | None = None
            """TCP Port."""
            tls_ssl_profile: str | None = None
            """Name of TLS profile."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, port: Annotated[int, Max[65535]] | None = None, tls_ssl_profile: str | None = None
            ) -> None:
                """
                DynamicAuthorization.

                Args:
                -----
                    _custom_data: _custom_data
                    port: TCP Port.
                    tls_ssl_profile: Name of TLS profile.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class HostsItem(AvdBase):
            class Tls(AvdBase):
                _fields = ("_custom_data", "enabled", "ssl_profile", "port")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                """Enable TLS for radius-server."""
                ssl_profile: str | None = None
                """Name of TLS profile."""
                port: Annotated[int, Max[65535]] | None = None
                """TCP Port used for TLS. EOS default is 2083."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    enabled: bool | None = None,
                    ssl_profile: str | None = None,
                    port: Annotated[int, Max[65535]] | None = None,
                ) -> None:
                    """
                    Tls.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: Enable TLS for radius-server.
                        ssl_profile: Name of TLS profile.
                        port: TCP Port used for TLS. EOS default is 2083.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "host", "vrf", "tls", "timeout", "retransmit", "key")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            host: str = None
            """Host IP address or name."""
            vrf: str | None = None
            tls: Tls | None = None
            """When TLS is configured, `key` is ignored.."""
            timeout: Annotated[int, Min[1], Max[1000]] | None = None
            retransmit: Annotated[int, Max[100]] | None = None
            key: str | None = None
            """
            Encrypted key - only type 7 supported.
            When TLS is configured, `key` is ignored.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                host: str = None,
                vrf: str | None = None,
                tls: Tls | None = None,
                timeout: Annotated[int, Min[1], Max[1000]] | None = None,
                retransmit: Annotated[int, Max[100]] | None = None,
                key: str | None = None,
            ) -> None:
                """
                HostsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    host: Host IP address or name.
                    vrf: vrf
                    tls: When TLS is configured, `key` is ignored..
                    timeout: timeout
                    retransmit: retransmit
                    key:
                       Encrypted key - only type 7 supported.
                       When TLS is configured, `key` is ignored.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "attribute_32_include_in_access_req", "dynamic_authorization", "hosts", "tls_ssl_profile")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        attribute_32_include_in_access_req: Attribute32IncludeInAccessReq | None = None
        dynamic_authorization: DynamicAuthorization | None = None
        hosts: list[HostsItem] | None = None
        tls_ssl_profile: str | None = None
        """Name of global TLS profile."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            attribute_32_include_in_access_req: Attribute32IncludeInAccessReq | None = None,
            dynamic_authorization: DynamicAuthorization | None = None,
            hosts: list[HostsItem] | None = None,
            tls_ssl_profile: str | None = None,
        ) -> None:
            """
            RadiusServer.

            Args:
            -----
                _custom_data: _custom_data
                attribute_32_include_in_access_req: attribute_32_include_in_access_req
                dynamic_authorization: dynamic_authorization
                hosts: hosts
                tls_ssl_profile: Name of global TLS profile.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Redundancy(AvdBase):
        _fields = ("_custom_data", "protocol")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        protocol: str | None = None
        """Redundancy Protocol."""

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, protocol: str | None = None) -> None:
            """
            Redundancy.

            Args:
            -----
                _custom_data: _custom_data
                protocol: Redundancy Protocol.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RolesItem(AvdBase):
        class SequenceNumbersItem(AvdBase):
            _fields = ("_custom_data", "sequence", "action", "mode", "command")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            sequence: int | None = None
            """Sequence number."""
            action: Annotated[str, ValidValues["permit", "deny"]] | None = None
            mode: str | None = None
            """"config", "config-all", "exec" or mode key as string."""
            command: str | None = None
            """Command as string."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                sequence: int | None = None,
                action: Annotated[str, ValidValues["permit", "deny"]] | None = None,
                mode: str | None = None,
                command: str | None = None,
            ) -> None:
                """
                SequenceNumbersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: Sequence number.
                    action: action
                    mode: "config", "config-all", "exec" or mode key as string.
                    command: Command as string.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "name", "sequence_numbers")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str | None = None
        """Role name."""
        sequence_numbers: list[SequenceNumbersItem] | None = None

        def __init__(
            self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, sequence_numbers: list[SequenceNumbersItem] | None = None
        ) -> None:
            """
            RolesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Role name.
                sequence_numbers: sequence_numbers

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouteMapsItem(AvdBase):
        class SequenceNumbersItem(AvdBase):
            class Continue(AvdBase):
                _fields = ("_custom_data", "enabled", "sequence_number")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                sequence_number: int | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, sequence_number: int | None = None) -> None:
                    """
                    Continue.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        sequence_number: sequence_number

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "sequence", "type", "description", "match", "set", "sub_route_map", "field_continue")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            sequence: int = None
            """Sequence ID."""
            type: Annotated[str, ValidValues["permit", "deny"]] = None
            description: str | None = None
            match: list[str] | None = None
            """List of "match" statements."""
            set: list[str] | None = None
            """List of "set" statements."""
            sub_route_map: str | None = None
            """Name of Sub-Route-map."""
            field_continue: Continue | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                sequence: int = None,
                type: Annotated[str, ValidValues["permit", "deny"]] = None,
                description: str | None = None,
                match: list[str] | None = None,
                set: list[str] | None = None,
                sub_route_map: str | None = None,
                field_continue: Continue | None = None,
            ) -> None:
                """
                SequenceNumbersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: Sequence ID.
                    type: type
                    description: description
                    match: List of "match" statements.
                    set: List of "set" statements.
                    sub_route_map: Name of Sub-Route-map.
                    field_continue: field_continue

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "name", "sequence_numbers")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Route-map Name."""
        sequence_numbers: list[SequenceNumbersItem] = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, sequence_numbers: list[SequenceNumbersItem] = None) -> None:
            """
            RouteMapsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Route-map Name.
                sequence_numbers: sequence_numbers

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterAdaptiveVirtualTopology(AvdBase):
        class Region(AvdBase):
            _fields = ("_custom_data", "name", "id")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: Annotated[str, Pattern[r"^[A-Za-z0-9_.:{}\[\]-]+$"]] = None
            id: Annotated[int, Min[1], Max[255]] = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: Annotated[str, Pattern[r"^[A-Za-z0-9_.:{}\[\]-]+$"]] = None,
                id: Annotated[int, Min[1], Max[255]] = None,
            ) -> None:
                """
                Region.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    id: id

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Zone(AvdBase):
            _fields = ("_custom_data", "name", "id")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: Annotated[str, Pattern[r"^[A-Za-z0-9_.:{}\[\]-]+$"]] = None
            id: Annotated[int, Min[1], Max[10000]] = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: Annotated[str, Pattern[r"^[A-Za-z0-9_.:{}\[\]-]+$"]] = None,
                id: Annotated[int, Min[1], Max[10000]] = None,
            ) -> None:
                """
                Zone.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    id: id

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Site(AvdBase):
            _fields = ("_custom_data", "name", "id")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: Annotated[str, Pattern[r"^[A-Za-z0-9_.:{}\[\]-]+$"]] = None
            id: Annotated[int, Min[1], Max[10000]] = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: Annotated[str, Pattern[r"^[A-Za-z0-9_.:{}\[\]-]+$"]] = None,
                id: Annotated[int, Min[1], Max[10000]] = None,
            ) -> None:
                """
                Site.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    id: id

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ProfilesItem(AvdBase):
            _fields = ("_custom_data", "name", "load_balance_policy", "internet_exit_policy")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """AVT Name."""
            load_balance_policy: str | None = None
            """Name of the load-balance policy."""
            internet_exit_policy: str | None = None
            """Name of the internet exit policy."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                load_balance_policy: str | None = None,
                internet_exit_policy: str | None = None,
            ) -> None:
                """
                ProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: AVT Name.
                    load_balance_policy: Name of the load-balance policy.
                    internet_exit_policy: Name of the internet exit policy.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PoliciesItem(AvdBase):
            class MatchesItem(AvdBase):
                _fields = ("_custom_data", "application_profile", "avt_profile", "dscp", "traffic_class")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                application_profile: str | None = None
                """Application profile name."""
                avt_profile: str | None = None
                """AVT Profile name."""
                dscp: Annotated[int, Max[63]] | None = None
                """Set DSCP for matched traffic."""
                traffic_class: Annotated[int, Max[7]] | None = None
                """Set traffic-class for matched traffic."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    application_profile: str | None = None,
                    avt_profile: str | None = None,
                    dscp: Annotated[int, Max[63]] | None = None,
                    traffic_class: Annotated[int, Max[7]] | None = None,
                ) -> None:
                    """
                    MatchesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        application_profile: Application profile name.
                        avt_profile: AVT Profile name.
                        dscp: Set DSCP for matched traffic.
                        traffic_class: Set traffic-class for matched traffic.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "matches")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Policy name."""
            matches: list[MatchesItem] | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, matches: list[MatchesItem] | None = None) -> None:
                """
                PoliciesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Policy name.
                    matches: matches

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrfsItem(AvdBase):
            class ProfilesItem(AvdBase):
                _fields = ("_custom_data", "name", "id")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str | None = None
                """AVT profile name."""
                id: Annotated[int, Min[1], Max[254]] = None
                """Unique ID for this AVT (per VRF)."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, id: Annotated[int, Min[1], Max[254]] = None) -> None:
                    """
                    ProfilesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: AVT profile name.
                        id: Unique ID for this AVT (per VRF).

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "policy", "profiles")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """VRF name."""
            policy: str | None = None
            """AVT Policy name."""
            profiles: list[ProfilesItem] | None = None
            """AVT profiles in this VRF."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, name: str = None, policy: str | None = None, profiles: list[ProfilesItem] | None = None
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF name.
                    policy: AVT Policy name.
                    profiles: AVT profiles in this VRF.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "topology_role", "gateway_vxlan", "region", "zone", "site", "profiles", "policies", "vrfs")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        topology_role: Annotated[str, ValidValues["edge", "pathfinder", "transit region", "transit zone"]] | None = None
        """Role name."""
        gateway_vxlan: bool | None = None
        """
        Enables VXLAN gateway router profile.
        Only applicable for `topology_role: edge`, `topology_role:
        transit region` or `topology_role: transit zone`.
        """
        region: Region | None = None
        """Region name and ID."""
        zone: Zone | None = None
        """Zone name and ID."""
        site: Site | None = None
        """Site name and ID."""
        profiles: list[ProfilesItem] | None = None
        policies: list[PoliciesItem] | None = None
        """A sequence of application profiles mapped to some virtual topologies."""
        vrfs: list[VrfsItem] | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            topology_role: Annotated[str, ValidValues["edge", "pathfinder", "transit region", "transit zone"]] | None = None,
            gateway_vxlan: bool | None = None,
            region: Region | None = None,
            zone: Zone | None = None,
            site: Site | None = None,
            profiles: list[ProfilesItem] | None = None,
            policies: list[PoliciesItem] | None = None,
            vrfs: list[VrfsItem] | None = None,
        ) -> None:
            """
            RouterAdaptiveVirtualTopology.

            Args:
            -----
                _custom_data: _custom_data
                topology_role: Role name.
                gateway_vxlan:
                   Enables VXLAN gateway router profile.
                   Only applicable for `topology_role: edge`, `topology_role:
                   transit region` or `topology_role: transit zone`.
                region: Region name and ID.
                zone: Zone name and ID.
                site: Site name and ID.
                profiles: profiles
                policies: A sequence of application profiles mapped to some virtual topologies.
                vrfs: vrfs

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterBfd(AvdBase):
        class Multihop(AvdBase):
            _fields = ("_custom_data", "interval", "min_rx", "multiplier")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            interval: int | None = None
            """Rate in milliseconds."""
            min_rx: int | None = None
            """Rate in milliseconds."""
            multiplier: Annotated[int, Min[3], Max[50]] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                interval: int | None = None,
                min_rx: int | None = None,
                multiplier: Annotated[int, Min[3], Max[50]] | None = None,
            ) -> None:
                """
                Multihop.

                Args:
                -----
                    _custom_data: _custom_data
                    interval: Rate in milliseconds.
                    min_rx: Rate in milliseconds.
                    multiplier: multiplier

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Sbfd(AvdBase):
            class LocalInterface(AvdBase):
                class Protocols(AvdBase):
                    _fields = ("_custom_data", "ipv4", "ipv6")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    ipv4: bool | None = None
                    ipv6: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, ipv4: bool | None = None, ipv6: bool | None = None) -> None:
                        """
                        Protocols.

                        Args:
                        -----
                            _custom_data: _custom_data
                            ipv4: ipv4
                            ipv6: ipv6

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "name", "protocols")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str | None = None
                """Interface Name."""
                protocols: Protocols | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, protocols: Protocols | None = None) -> None:
                    """
                    LocalInterface.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Interface Name.
                        protocols: protocols

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Reflector(AvdBase):
                _fields = ("_custom_data", "min_rx", "local_discriminator")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                min_rx: int | None = None
                """Rate in milliseconds."""
                local_discriminator: str | None = None
                """IPv4 address or 32 bit integer."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, min_rx: int | None = None, local_discriminator: str | None = None) -> None:
                    """
                    Reflector.

                    Args:
                    -----
                        _custom_data: _custom_data
                        min_rx: Rate in milliseconds.
                        local_discriminator: IPv4 address or 32 bit integer.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "local_interface", "initiator_interval", "initiator_multiplier", "initiator_measurement_round_trip", "reflector")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            local_interface: LocalInterface | None = None
            initiator_interval: int | None = None
            """Rate in milliseconds."""
            initiator_multiplier: Annotated[int, Min[3], Max[50]] | None = None
            initiator_measurement_round_trip: bool | None = None
            """Enable round-trip delay measurement."""
            reflector: Reflector | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                local_interface: LocalInterface | None = None,
                initiator_interval: int | None = None,
                initiator_multiplier: Annotated[int, Min[3], Max[50]] | None = None,
                initiator_measurement_round_trip: bool | None = None,
                reflector: Reflector | None = None,
            ) -> None:
                """
                Sbfd.

                Args:
                -----
                    _custom_data: _custom_data
                    local_interface: local_interface
                    initiator_interval: Rate in milliseconds.
                    initiator_multiplier: initiator_multiplier
                    initiator_measurement_round_trip: Enable round-trip delay measurement.
                    reflector: reflector

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "interval",
            "local_address",
            "min_rx",
            "multiplier",
            "multihop",
            "session_snapshot_interval",
            "session_snapshot_interval_dangerous",
            "sbfd",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        interval: int | None = None
        """Rate in milliseconds."""
        local_address: str | None = None
        """Configure BFD local IP/IPv6 address."""
        min_rx: int | None = None
        """Rate in milliseconds."""
        multiplier: Annotated[int, Min[3], Max[50]] | None = None
        multihop: Multihop | None = None
        session_snapshot_interval: Annotated[int, Min[1], Max[3600]] | None = None
        """
        Interval in seconds.
        Intervals below 10 are considered "dangerous" on EOS and must have
        `session_snapshot_interval_dangerous` set to `true`.
        """
        session_snapshot_interval_dangerous: bool | None = None
        sbfd: Sbfd | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            interval: int | None = None,
            local_address: str | None = None,
            min_rx: int | None = None,
            multiplier: Annotated[int, Min[3], Max[50]] | None = None,
            multihop: Multihop | None = None,
            session_snapshot_interval: Annotated[int, Min[1], Max[3600]] | None = None,
            session_snapshot_interval_dangerous: bool | None = None,
            sbfd: Sbfd | None = None,
        ) -> None:
            """
            RouterBfd.

            Args:
            -----
                _custom_data: _custom_data
                interval: Rate in milliseconds.
                local_address: Configure BFD local IP/IPv6 address.
                min_rx: Rate in milliseconds.
                multiplier: multiplier
                multihop: multihop
                session_snapshot_interval:
                   Interval in seconds.
                   Intervals below 10 are considered "dangerous" on EOS and must have
                   `session_snapshot_interval_dangerous` set to `true`.
                session_snapshot_interval_dangerous: session_snapshot_interval_dangerous
                sbfd: sbfd

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterBgp(AvdBase):
        class Distance(AvdBase):
            _fields = ("_custom_data", "external_routes", "internal_routes", "local_routes")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            external_routes: Annotated[int, Min[1], Max[255]] = None
            internal_routes: Annotated[int, Min[1], Max[255]] = None
            local_routes: Annotated[int, Min[1], Max[255]] = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                external_routes: Annotated[int, Min[1], Max[255]] = None,
                internal_routes: Annotated[int, Min[1], Max[255]] = None,
                local_routes: Annotated[int, Min[1], Max[255]] = None,
            ) -> None:
                """
                Distance.

                Args:
                -----
                    _custom_data: _custom_data
                    external_routes: external_routes
                    internal_routes: internal_routes
                    local_routes: local_routes

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class GracefulRestart(AvdBase):
            _fields = ("_custom_data", "enabled", "restart_time", "stalepath_time")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool | None = None
            restart_time: Annotated[int, Min[1], Max[3600]] | None = None
            """Number of seconds."""
            stalepath_time: Annotated[int, Min[1], Max[3600]] | None = None
            """Number of seconds."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enabled: bool | None = None,
                restart_time: Annotated[int, Min[1], Max[3600]] | None = None,
                stalepath_time: Annotated[int, Min[1], Max[3600]] | None = None,
            ) -> None:
                """
                GracefulRestart.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    restart_time: Number of seconds.
                    stalepath_time: Number of seconds.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class GracefulRestartHelper(AvdBase):
            _fields = ("_custom_data", "enabled", "restart_time", "long_lived")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool | None = None
            restart_time: Annotated[int, Min[1], Max[100000000]] | None = None
            """
            Number of seconds
            graceful-restart-help long-lived and restart-time are mutually exclusive in CLI.
            restart-time will take precedence if both are configured.
            """
            long_lived: bool | None = None
            """
            graceful-restart-help long-lived and restart-time are mutually exclusive in CLI.
            restart-time will
            take precedence if both are configured.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enabled: bool | None = None,
                restart_time: Annotated[int, Min[1], Max[100000000]] | None = None,
                long_lived: bool | None = None,
            ) -> None:
                """
                GracefulRestartHelper.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    restart_time:
                       Number of seconds
                       graceful-restart-help long-lived and restart-time are mutually exclusive in CLI.
                       restart-time will take precedence if both are configured.
                    long_lived:
                       graceful-restart-help long-lived and restart-time are mutually exclusive in CLI.
                       restart-time will
                       take precedence if both are configured.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class MaximumPaths(AvdBase):
            _fields = ("_custom_data", "paths", "ecmp")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            paths: Annotated[int, Min[1], Max[600]] = None
            ecmp: Annotated[int, Min[1], Max[600]] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                paths: Annotated[int, Min[1], Max[600]] = None,
                ecmp: Annotated[int, Min[1], Max[600]] | None = None,
            ) -> None:
                """
                MaximumPaths.

                Args:
                -----
                    _custom_data: _custom_data
                    paths: paths
                    ecmp: ecmp

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Updates(AvdBase):
            _fields = ("_custom_data", "wait_for_convergence", "wait_install")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            wait_for_convergence: bool | None = None
            """
            Disables FIB updates and route advertisement when the BGP instance is initiated until the BGP
            convergence state is reached.
            """
            wait_install: bool | None = None
            """
            Do not advertise reachability to a prefix until that prefix has been installed in hardware.
            This
            will eliminate any temporary black holes due to a BGP speaker advertising reachability to a prefix
            that may not yet be installed into the forwarding plane.
            """

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, wait_for_convergence: bool | None = None, wait_install: bool | None = None
            ) -> None:
                """
                Updates.

                Args:
                -----
                    _custom_data: _custom_data
                    wait_for_convergence:
                       Disables FIB updates and route advertisement when the BGP instance is initiated until the BGP
                       convergence state is reached.
                    wait_install:
                       Do not advertise reachability to a prefix until that prefix has been installed in hardware.
                       This
                       will eliminate any temporary black holes due to a BGP speaker advertising reachability to a prefix
                       that may not yet be installed into the forwarding plane.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Bgp(AvdBase):
            class Default(AvdBase):
                _fields = ("_custom_data", "ipv4_unicast", "ipv4_unicast_transport_ipv6")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ipv4_unicast: bool | None = None
                """Default activation of IPv4 unicast address-family on all IPv4 neighbors (EOS default = True)."""
                ipv4_unicast_transport_ipv6: bool | None = None
                """Default activation of IPv4 unicast address-family on all IPv6 neighbors (EOS default == False)."""

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, ipv4_unicast: bool | None = None, ipv4_unicast_transport_ipv6: bool | None = None
                ) -> None:
                    """
                    Default.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ipv4_unicast: Default activation of IPv4 unicast address-family on all IPv4 neighbors (EOS default = True).
                        ipv4_unicast_transport_ipv6: Default activation of IPv4 unicast address-family on all IPv6 neighbors (EOS default == False).

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RouteReflectorPreserveAttributes(AvdBase):
                _fields = ("_custom_data", "enabled", "always")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                always: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, always: bool | None = None) -> None:
                    """
                    RouteReflectorPreserveAttributes.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        always: always

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Bestpath(AvdBase):
                _fields = ("_custom_data", "d_path")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                d_path: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, d_path: bool | None = None) -> None:
                    """
                    Bestpath.

                    Args:
                    -----
                        _custom_data: _custom_data
                        d_path: d_path

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AdditionalPaths(AvdBase):
                _fields = ("_custom_data", "receive", "send", "send_limit")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                receive: bool | None = None
                """Enable or disable reception of additional-paths."""
                send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                """
                Select an option to send multiple paths for same prefix through bgp updates.
                any: Send any eligible
                path.
                backup: Best path and installed backup path.
                ecmp: All paths in best path ECMP group.
                limit:
                Limit to n eligible paths.
                disabled: Disable sending any paths.
                """
                send_limit: Annotated[int, Min[2], Max[64]] | None = None
                """
                Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                `ecmp`.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    receive: bool | None = None,
                    send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                    send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                ) -> None:
                    """
                    AdditionalPaths.

                    Args:
                    -----
                        _custom_data: _custom_data
                        receive: Enable or disable reception of additional-paths.
                        send:
                           Select an option to send multiple paths for same prefix through bgp updates.
                           any: Send any eligible
                           path.
                           backup: Best path and installed backup path.
                           ecmp: All paths in best path ECMP group.
                           limit:
                           Limit to n eligible paths.
                           disabled: Disable sending any paths.
                        send_limit:
                           Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                           `ecmp`.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "default", "route_reflector_preserve_attributes", "bestpath", "additional_paths", "redistribute_internal")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            default: Default | None = None
            route_reflector_preserve_attributes: RouteReflectorPreserveAttributes | None = None
            bestpath: Bestpath | None = None
            additional_paths: AdditionalPaths | None = None
            redistribute_internal: bool | None = None
            """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                default: Default | None = None,
                route_reflector_preserve_attributes: RouteReflectorPreserveAttributes | None = None,
                bestpath: Bestpath | None = None,
                additional_paths: AdditionalPaths | None = None,
                redistribute_internal: bool | None = None,
            ) -> None:
                """
                Bgp.

                Args:
                -----
                    _custom_data: _custom_data
                    default: default
                    route_reflector_preserve_attributes: route_reflector_preserve_attributes
                    bestpath: bestpath
                    additional_paths: additional_paths
                    redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ListenRangesItem(AvdBase):
            _fields = ("_custom_data", "prefix", "peer_id_include_router_id", "peer_group", "peer_filter", "remote_as")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            prefix: str | None = None
            """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
            peer_id_include_router_id: bool | None = None
            """Include router ID as part of peer filter."""
            peer_group: str | None = None
            """Peer group name."""
            peer_filter: str | None = None
            """
            Peer-filter name.
            note: `peer_filter` or `remote_as` is required but mutually exclusive.
            If both are
            defined, `peer_filter` takes precedence
            """
            remote_as: str | None = None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                prefix: str | None = None,
                peer_id_include_router_id: bool | None = None,
                peer_group: str | None = None,
                peer_filter: str | None = None,
                remote_as: str | None = None,
            ) -> None:
                """
                ListenRangesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                    peer_id_include_router_id: Include router ID as part of peer filter.
                    peer_group: Peer group name.
                    peer_filter:
                       Peer-filter name.
                       note: `peer_filter` or `remote_as` is required but mutually exclusive.
                       If both are
                       defined, `peer_filter` takes precedence
                    remote_as:
                       BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                       For asdot notation in
                       YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                       number.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PeerGroupsItem(AvdBase):
            class AsPath(AvdBase):
                _fields = ("_custom_data", "remote_as_replace_out", "prepend_own_disabled")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                remote_as_replace_out: bool | None = None
                """Replace AS number with local AS number."""
                prepend_own_disabled: bool | None = None
                """Disable prepending own AS number to AS path."""

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, remote_as_replace_out: bool | None = None, prepend_own_disabled: bool | None = None
                ) -> None:
                    """
                    AsPath.

                    Args:
                    -----
                        _custom_data: _custom_data
                        remote_as_replace_out: Replace AS number with local AS number.
                        prepend_own_disabled: Disable prepending own AS number to AS path.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RemovePrivateAs(AvdBase):
                _fields = ("_custom_data", "enabled", "all", "replace_as")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                all: bool | None = None
                replace_as: bool | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, all: bool | None = None, replace_as: bool | None = None
                ) -> None:
                    """
                    RemovePrivateAs.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        all: all
                        replace_as: replace_as

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RemovePrivateAsIngress(AvdBase):
                _fields = ("_custom_data", "enabled", "replace_as")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                replace_as: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, replace_as: bool | None = None) -> None:
                    """
                    RemovePrivateAsIngress.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        replace_as: replace_as

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class BfdTimers(AvdBase):
                _fields = ("_custom_data", "interval", "min_rx", "multiplier")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                interval: Annotated[int, Min[50], Max[60000]] = None
                """Interval in milliseconds."""
                min_rx: Annotated[int, Min[50], Max[60000]] = None
                """Rate in milliseconds."""
                multiplier: Annotated[int, Min[3], Max[50]] = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    interval: Annotated[int, Min[50], Max[60000]] = None,
                    min_rx: Annotated[int, Min[50], Max[60000]] = None,
                    multiplier: Annotated[int, Min[3], Max[50]] = None,
                ) -> None:
                    """
                    BfdTimers.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interval: Interval in milliseconds.
                        min_rx: Rate in milliseconds.
                        multiplier: multiplier

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class DefaultOriginate(AvdBase):
                _fields = ("_custom_data", "enabled", "always", "route_map")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                always: bool | None = None
                route_map: str | None = None
                """Route-map name."""

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, always: bool | None = None, route_map: str | None = None
                ) -> None:
                    """
                    DefaultOriginate.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        always: always
                        route_map: Route-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class MissingPolicy(AvdBase):
                class DirectionIn(AvdBase):
                    _fields = ("_custom_data", "action", "include_community_list", "include_prefix_list", "include_sub_route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    action: Annotated[str, ValidValues["deny", "permit", "deny-in-out"]] = None
                    """Missing policy action."""
                    include_community_list: bool | None = None
                    """Include community-list references in missing policy decision."""
                    include_prefix_list: bool | None = None
                    """Include prefix-list references in missing policy decision."""
                    include_sub_route_map: bool | None = None
                    """Include sub-route-map references in missing policy decision."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        action: Annotated[str, ValidValues["deny", "permit", "deny-in-out"]] = None,
                        include_community_list: bool | None = None,
                        include_prefix_list: bool | None = None,
                        include_sub_route_map: bool | None = None,
                    ) -> None:
                        """
                        DirectionIn.

                        Args:
                        -----
                            _custom_data: _custom_data
                            action: Missing policy action.
                            include_community_list: Include community-list references in missing policy decision.
                            include_prefix_list: Include prefix-list references in missing policy decision.
                            include_sub_route_map: Include sub-route-map references in missing policy decision.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class DirectionOut(AvdBase):
                    _fields = ("_custom_data", "action", "include_community_list", "include_prefix_list", "include_sub_route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    action: Annotated[str, ValidValues["deny", "permit", "deny-in-out"]] = None
                    """Missing policy action."""
                    include_community_list: bool | None = None
                    """Include community-list references in missing policy decision."""
                    include_prefix_list: bool | None = None
                    """Include prefix-list references in missing policy decision."""
                    include_sub_route_map: bool | None = None
                    """Include sub-route-map references in missing policy decision."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        action: Annotated[str, ValidValues["deny", "permit", "deny-in-out"]] = None,
                        include_community_list: bool | None = None,
                        include_prefix_list: bool | None = None,
                        include_sub_route_map: bool | None = None,
                    ) -> None:
                        """
                        DirectionOut.

                        Args:
                        -----
                            _custom_data: _custom_data
                            action: Missing policy action.
                            include_community_list: Include community-list references in missing policy decision.
                            include_prefix_list: Include prefix-list references in missing policy decision.
                            include_sub_route_map: Include sub-route-map references in missing policy decision.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "direction_in", "direction_out")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                direction_in: DirectionIn | None = None
                """Missing policy inbound direction."""
                direction_out: DirectionOut | None = None
                """Missing policy outbound direction."""

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, direction_in: DirectionIn | None = None, direction_out: DirectionOut | None = None
                ) -> None:
                    """
                    MissingPolicy.

                    Args:
                    -----
                        _custom_data: _custom_data
                        direction_in: Missing policy inbound direction.
                        direction_out: Missing policy outbound direction.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class LinkBandwidth(AvdBase):
                _fields = ("_custom_data", "enabled", "default")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                default: str | None = None
                """nn.nn(K|M|G) link speed in bits/second."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, default: str | None = None) -> None:
                    """
                    LinkBandwidth.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        default: nn.nn(K|M|G) link speed in bits/second.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AllowasIn(AvdBase):
                _fields = ("_custom_data", "enabled", "times")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                times: Annotated[int, Min[1], Max[10]] | None = None
                """Number of local ASNs allowed in a BGP update."""

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, times: Annotated[int, Min[1], Max[10]] | None = None
                ) -> None:
                    """
                    AllowasIn.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        times: Number of local ASNs allowed in a BGP update.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RibInPrePolicyRetain(AvdBase):
                _fields = ("_custom_data", "enabled", "all")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                all: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, all: bool | None = None) -> None:
                    """
                    RibInPrePolicyRetain.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        all: all

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class SharedSecret(AvdBase):
                _fields = ("_custom_data", "profile", "hash_algorithm")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                profile: str = None
                """Name of profile defined under `management_security`."""
                hash_algorithm: Annotated[str, ValidValues["aes-128-cmac-96", "hmac-sha-256", "hmac-sha1-96"]] = None
                """Note: Algorithm hmac-sha-256 requires EOS version 4.31.1F and above."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    profile: str = None,
                    hash_algorithm: Annotated[str, ValidValues["aes-128-cmac-96", "hmac-sha-256", "hmac-sha1-96"]] = None,
                ) -> None:
                    """
                    SharedSecret.

                    Args:
                    -----
                        _custom_data: _custom_data
                        profile: Name of profile defined under `management_security`.
                        hash_algorithm: Note: Algorithm hmac-sha-256 requires EOS version 4.31.1F and above.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = (
                "_custom_data",
                "name",
                "type",
                "remote_as",
                "local_as",
                "description",
                "shutdown",
                "as_path",
                "remove_private_as",
                "remove_private_as_ingress",
                "next_hop_unchanged",
                "update_source",
                "route_reflector_client",
                "bfd",
                "bfd_timers",
                "ebgp_multihop",
                "next_hop_self",
                "password",
                "passive",
                "default_originate",
                "send_community",
                "maximum_routes",
                "maximum_routes_warning_limit",
                "maximum_routes_warning_only",
                "missing_policy",
                "link_bandwidth",
                "allowas_in",
                "weight",
                "timers",
                "rib_in_pre_policy_retain",
                "route_map_in",
                "route_map_out",
                "session_tracker",
                "shared_secret",
                "ttl_maximum_hops",
            )
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Peer-group name."""
            type: str | None = None
            """Key only used for documentation or validation purposes."""
            remote_as: str | None = None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            local_as: str | None = None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            description: str | None = None
            shutdown: bool | None = None
            as_path: AsPath | None = None
            """BGP AS-PATH options."""
            remove_private_as: RemovePrivateAs | None = None
            """Remove private AS numbers in outbound AS path."""
            remove_private_as_ingress: RemovePrivateAsIngress | None = None
            next_hop_unchanged: bool | None = None
            update_source: str | None = None
            """IP address or interface name."""
            route_reflector_client: bool | None = None
            bfd: bool | None = None
            """Enable BFD."""
            bfd_timers: BfdTimers | None = None
            """Override default BFD timers. BFD must be enabled with `bfd: true`."""
            ebgp_multihop: Annotated[int, Min[1], Max[255]] | None = None
            """Time-to-live in range of hops."""
            next_hop_self: bool | None = None
            password: str | None = None
            passive: bool | None = None
            default_originate: DefaultOriginate | None = None
            send_community: str | None = None
            """'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'."""
            maximum_routes: Annotated[int, Max[4294967294]] | None = None
            """Maximum number of routes (0 means unlimited)."""
            maximum_routes_warning_limit: str | None = None
            """
            Maximum number of routes after which a warning is issued (0 means never warn) or
            Percentage of
            maximum number of routes at which to warn ("<1-100> percent").
            """
            maximum_routes_warning_only: bool | None = None
            missing_policy: MissingPolicy | None = None
            """Missing policy configuration for all address-families."""
            link_bandwidth: LinkBandwidth | None = None
            allowas_in: AllowasIn | None = None
            weight: Annotated[int, Max[65535]] | None = None
            timers: str | None = None
            """BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>"."""
            rib_in_pre_policy_retain: RibInPrePolicyRetain | None = None
            route_map_in: str | None = None
            """Inbound route-map name."""
            route_map_out: str | None = None
            """Outbound route-map name."""
            session_tracker: str | None = None
            shared_secret: SharedSecret | None = None
            ttl_maximum_hops: Annotated[int, Max[254]] | None = None
            """Maximum number of hops."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                type: str | None = None,
                remote_as: str | None = None,
                local_as: str | None = None,
                description: str | None = None,
                shutdown: bool | None = None,
                as_path: AsPath | None = None,
                remove_private_as: RemovePrivateAs | None = None,
                remove_private_as_ingress: RemovePrivateAsIngress | None = None,
                next_hop_unchanged: bool | None = None,
                update_source: str | None = None,
                route_reflector_client: bool | None = None,
                bfd: bool | None = None,
                bfd_timers: BfdTimers | None = None,
                ebgp_multihop: Annotated[int, Min[1], Max[255]] | None = None,
                next_hop_self: bool | None = None,
                password: str | None = None,
                passive: bool | None = None,
                default_originate: DefaultOriginate | None = None,
                send_community: str | None = None,
                maximum_routes: Annotated[int, Max[4294967294]] | None = None,
                maximum_routes_warning_limit: str | None = None,
                maximum_routes_warning_only: bool | None = None,
                missing_policy: MissingPolicy | None = None,
                link_bandwidth: LinkBandwidth | None = None,
                allowas_in: AllowasIn | None = None,
                weight: Annotated[int, Max[65535]] | None = None,
                timers: str | None = None,
                rib_in_pre_policy_retain: RibInPrePolicyRetain | None = None,
                route_map_in: str | None = None,
                route_map_out: str | None = None,
                session_tracker: str | None = None,
                shared_secret: SharedSecret | None = None,
                ttl_maximum_hops: Annotated[int, Max[254]] | None = None,
            ) -> None:
                """
                PeerGroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Peer-group name.
                    type: Key only used for documentation or validation purposes.
                    remote_as:
                       BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                       For asdot notation in
                       YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                       number.
                    local_as:
                       BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                       For asdot notation in
                       YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                       number.
                    description: description
                    shutdown: shutdown
                    as_path: BGP AS-PATH options.
                    remove_private_as: Remove private AS numbers in outbound AS path.
                    remove_private_as_ingress: remove_private_as_ingress
                    next_hop_unchanged: next_hop_unchanged
                    update_source: IP address or interface name.
                    route_reflector_client: route_reflector_client
                    bfd: Enable BFD.
                    bfd_timers: Override default BFD timers. BFD must be enabled with `bfd: true`.
                    ebgp_multihop: Time-to-live in range of hops.
                    next_hop_self: next_hop_self
                    password: password
                    passive: passive
                    default_originate: default_originate
                    send_community: 'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'.
                    maximum_routes: Maximum number of routes (0 means unlimited).
                    maximum_routes_warning_limit:
                       Maximum number of routes after which a warning is issued (0 means never warn) or
                       Percentage of
                       maximum number of routes at which to warn ("<1-100> percent").
                    maximum_routes_warning_only: maximum_routes_warning_only
                    missing_policy: Missing policy configuration for all address-families.
                    link_bandwidth: link_bandwidth
                    allowas_in: allowas_in
                    weight: weight
                    timers: BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>".
                    rib_in_pre_policy_retain: rib_in_pre_policy_retain
                    route_map_in: Inbound route-map name.
                    route_map_out: Outbound route-map name.
                    session_tracker: session_tracker
                    shared_secret: shared_secret
                    ttl_maximum_hops: Maximum number of hops.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class NeighborsItem(AvdBase):
            class AsPath(AvdBase):
                _fields = ("_custom_data", "remote_as_replace_out", "prepend_own_disabled")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                remote_as_replace_out: bool | None = None
                """Replace AS number with local AS number."""
                prepend_own_disabled: bool | None = None
                """Disable prepending own AS number to AS path."""

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, remote_as_replace_out: bool | None = None, prepend_own_disabled: bool | None = None
                ) -> None:
                    """
                    AsPath.

                    Args:
                    -----
                        _custom_data: _custom_data
                        remote_as_replace_out: Replace AS number with local AS number.
                        prepend_own_disabled: Disable prepending own AS number to AS path.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class BfdTimers(AvdBase):
                _fields = ("_custom_data", "interval", "min_rx", "multiplier")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                interval: Annotated[int, Min[50], Max[60000]] = None
                """Interval in milliseconds."""
                min_rx: Annotated[int, Min[50], Max[60000]] = None
                """Rate in milliseconds."""
                multiplier: Annotated[int, Min[3], Max[50]] = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    interval: Annotated[int, Min[50], Max[60000]] = None,
                    min_rx: Annotated[int, Min[50], Max[60000]] = None,
                    multiplier: Annotated[int, Min[3], Max[50]] = None,
                ) -> None:
                    """
                    BfdTimers.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interval: Interval in milliseconds.
                        min_rx: Rate in milliseconds.
                        multiplier: multiplier

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class DefaultOriginate(AvdBase):
                _fields = ("_custom_data", "enabled", "always", "route_map")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                always: bool | None = None
                route_map: str | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, always: bool | None = None, route_map: str | None = None
                ) -> None:
                    """
                    DefaultOriginate.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        always: always
                        route_map: route_map

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class MissingPolicy(AvdBase):
                class DirectionIn(AvdBase):
                    _fields = ("_custom_data", "action", "include_community_list", "include_prefix_list", "include_sub_route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    action: Annotated[str, ValidValues["deny", "permit", "deny-in-out"]] = None
                    """Missing policy action."""
                    include_community_list: bool | None = None
                    """Include community-list references in missing policy decision."""
                    include_prefix_list: bool | None = None
                    """Include prefix-list references in missing policy decision."""
                    include_sub_route_map: bool | None = None
                    """Include sub-route-map references in missing policy decision."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        action: Annotated[str, ValidValues["deny", "permit", "deny-in-out"]] = None,
                        include_community_list: bool | None = None,
                        include_prefix_list: bool | None = None,
                        include_sub_route_map: bool | None = None,
                    ) -> None:
                        """
                        DirectionIn.

                        Args:
                        -----
                            _custom_data: _custom_data
                            action: Missing policy action.
                            include_community_list: Include community-list references in missing policy decision.
                            include_prefix_list: Include prefix-list references in missing policy decision.
                            include_sub_route_map: Include sub-route-map references in missing policy decision.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class DirectionOut(AvdBase):
                    _fields = ("_custom_data", "action", "include_community_list", "include_prefix_list", "include_sub_route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    action: Annotated[str, ValidValues["deny", "permit", "deny-in-out"]] = None
                    """Missing policy action."""
                    include_community_list: bool | None = None
                    """Include community-list references in missing policy decision."""
                    include_prefix_list: bool | None = None
                    """Include prefix-list references in missing policy decision."""
                    include_sub_route_map: bool | None = None
                    """Include sub-route-map references in missing policy decision."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        action: Annotated[str, ValidValues["deny", "permit", "deny-in-out"]] = None,
                        include_community_list: bool | None = None,
                        include_prefix_list: bool | None = None,
                        include_sub_route_map: bool | None = None,
                    ) -> None:
                        """
                        DirectionOut.

                        Args:
                        -----
                            _custom_data: _custom_data
                            action: Missing policy action.
                            include_community_list: Include community-list references in missing policy decision.
                            include_prefix_list: Include prefix-list references in missing policy decision.
                            include_sub_route_map: Include sub-route-map references in missing policy decision.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "direction_in", "direction_out")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                direction_in: DirectionIn | None = None
                """Missing policy inbound direction."""
                direction_out: DirectionOut | None = None
                """Missing policy outbound direction."""

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, direction_in: DirectionIn | None = None, direction_out: DirectionOut | None = None
                ) -> None:
                    """
                    MissingPolicy.

                    Args:
                    -----
                        _custom_data: _custom_data
                        direction_in: Missing policy inbound direction.
                        direction_out: Missing policy outbound direction.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AllowasIn(AvdBase):
                _fields = ("_custom_data", "enabled", "times")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                times: Annotated[int, Min[1], Max[10]] | None = None
                """Number of local ASNs allowed in a BGP update."""

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, times: Annotated[int, Min[1], Max[10]] | None = None
                ) -> None:
                    """
                    AllowasIn.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        times: Number of local ASNs allowed in a BGP update.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class LinkBandwidth(AvdBase):
                _fields = ("_custom_data", "enabled", "default")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                default: str | None = None
                """nn.nn(K|M|G) link speed in bits/second."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, default: str | None = None) -> None:
                    """
                    LinkBandwidth.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        default: nn.nn(K|M|G) link speed in bits/second.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RibInPrePolicyRetain(AvdBase):
                _fields = ("_custom_data", "enabled", "all")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                all: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, all: bool | None = None) -> None:
                    """
                    RibInPrePolicyRetain.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        all: all

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RemovePrivateAs(AvdBase):
                _fields = ("_custom_data", "enabled", "all", "replace_as")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                all: bool | None = None
                replace_as: bool | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, all: bool | None = None, replace_as: bool | None = None
                ) -> None:
                    """
                    RemovePrivateAs.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        all: all
                        replace_as: replace_as

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RemovePrivateAsIngress(AvdBase):
                _fields = ("_custom_data", "enabled", "replace_as")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                replace_as: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, replace_as: bool | None = None) -> None:
                    """
                    RemovePrivateAsIngress.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        replace_as: replace_as

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class SharedSecret(AvdBase):
                _fields = ("_custom_data", "profile", "hash_algorithm")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                profile: str = None
                """Name of profile defined under `management_security`."""
                hash_algorithm: Annotated[str, ValidValues["aes-128-cmac-96", "hmac-sha-256", "hmac-sha1-96"]] = None
                """Note: Algorithm hmac-sha-256 requires EOS version 4.31.1F and above."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    profile: str = None,
                    hash_algorithm: Annotated[str, ValidValues["aes-128-cmac-96", "hmac-sha-256", "hmac-sha1-96"]] = None,
                ) -> None:
                    """
                    SharedSecret.

                    Args:
                    -----
                        _custom_data: _custom_data
                        profile: Name of profile defined under `management_security`.
                        hash_algorithm: Note: Algorithm hmac-sha-256 requires EOS version 4.31.1F and above.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = (
                "_custom_data",
                "ip_address",
                "peer_group",
                "remote_as",
                "local_as",
                "as_path",
                "peer",
                "description",
                "route_reflector_client",
                "password",
                "passive",
                "shutdown",
                "update_source",
                "bfd",
                "bfd_timers",
                "weight",
                "timers",
                "route_map_in",
                "route_map_out",
                "default_originate",
                "send_community",
                "maximum_routes",
                "maximum_routes_warning_limit",
                "maximum_routes_warning_only",
                "missing_policy",
                "allowas_in",
                "ebgp_multihop",
                "next_hop_self",
                "link_bandwidth",
                "rib_in_pre_policy_retain",
                "remove_private_as",
                "remove_private_as_ingress",
                "session_tracker",
                "shared_secret",
                "ttl_maximum_hops",
            )
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ip_address: str = None
            peer_group: str | None = None
            remote_as: str | None = None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            local_as: str | None = None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            as_path: AsPath | None = None
            """BGP AS-PATH options."""
            peer: str | None = None
            """Key only used for documentation or validation purposes."""
            description: str | None = None
            route_reflector_client: bool | None = None
            password: str | None = None
            passive: bool | None = None
            shutdown: bool | None = None
            update_source: str | None = None
            """Source Interface."""
            bfd: bool | None = None
            """Enable BFD."""
            bfd_timers: BfdTimers | None = None
            """Override default BFD timers. BFD must be enabled with `bfd: true`."""
            weight: Annotated[int, Max[65535]] | None = None
            timers: str | None = None
            """BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>"."""
            route_map_in: str | None = None
            """Inbound route-map name."""
            route_map_out: str | None = None
            """Outbound route-map name."""
            default_originate: DefaultOriginate | None = None
            send_community: str | None = None
            """'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'."""
            maximum_routes: Annotated[int, Max[4294967294]] | None = None
            """Maximum number of routes (0 means unlimited)."""
            maximum_routes_warning_limit: str | None = None
            """
            Maximum number of routes after which a warning is issued (0 means never warn) or
            Percentage of
            maximum number of routes at which to warn ("<1-100> percent").
            """
            maximum_routes_warning_only: bool | None = None
            missing_policy: MissingPolicy | None = None
            """Missing policy configuration for all address-families."""
            allowas_in: AllowasIn | None = None
            ebgp_multihop: Annotated[int, Min[1], Max[255]] | None = None
            """Time-to-live in range of hops."""
            next_hop_self: bool | None = None
            link_bandwidth: LinkBandwidth | None = None
            rib_in_pre_policy_retain: RibInPrePolicyRetain | None = None
            remove_private_as: RemovePrivateAs | None = None
            """Remove private AS numbers in outbound AS path."""
            remove_private_as_ingress: RemovePrivateAsIngress | None = None
            session_tracker: str | None = None
            shared_secret: SharedSecret | None = None
            ttl_maximum_hops: Annotated[int, Max[254]] | None = None
            """Maximum number of hops."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                ip_address: str = None,
                peer_group: str | None = None,
                remote_as: str | None = None,
                local_as: str | None = None,
                as_path: AsPath | None = None,
                peer: str | None = None,
                description: str | None = None,
                route_reflector_client: bool | None = None,
                password: str | None = None,
                passive: bool | None = None,
                shutdown: bool | None = None,
                update_source: str | None = None,
                bfd: bool | None = None,
                bfd_timers: BfdTimers | None = None,
                weight: Annotated[int, Max[65535]] | None = None,
                timers: str | None = None,
                route_map_in: str | None = None,
                route_map_out: str | None = None,
                default_originate: DefaultOriginate | None = None,
                send_community: str | None = None,
                maximum_routes: Annotated[int, Max[4294967294]] | None = None,
                maximum_routes_warning_limit: str | None = None,
                maximum_routes_warning_only: bool | None = None,
                missing_policy: MissingPolicy | None = None,
                allowas_in: AllowasIn | None = None,
                ebgp_multihop: Annotated[int, Min[1], Max[255]] | None = None,
                next_hop_self: bool | None = None,
                link_bandwidth: LinkBandwidth | None = None,
                rib_in_pre_policy_retain: RibInPrePolicyRetain | None = None,
                remove_private_as: RemovePrivateAs | None = None,
                remove_private_as_ingress: RemovePrivateAsIngress | None = None,
                session_tracker: str | None = None,
                shared_secret: SharedSecret | None = None,
                ttl_maximum_hops: Annotated[int, Max[254]] | None = None,
            ) -> None:
                """
                NeighborsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    ip_address: ip_address
                    peer_group: peer_group
                    remote_as:
                       BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                       For asdot notation in
                       YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                       number.
                    local_as:
                       BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                       For asdot notation in
                       YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                       number.
                    as_path: BGP AS-PATH options.
                    peer: Key only used for documentation or validation purposes.
                    description: description
                    route_reflector_client: route_reflector_client
                    password: password
                    passive: passive
                    shutdown: shutdown
                    update_source: Source Interface.
                    bfd: Enable BFD.
                    bfd_timers: Override default BFD timers. BFD must be enabled with `bfd: true`.
                    weight: weight
                    timers: BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>".
                    route_map_in: Inbound route-map name.
                    route_map_out: Outbound route-map name.
                    default_originate: default_originate
                    send_community: 'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'.
                    maximum_routes: Maximum number of routes (0 means unlimited).
                    maximum_routes_warning_limit:
                       Maximum number of routes after which a warning is issued (0 means never warn) or
                       Percentage of
                       maximum number of routes at which to warn ("<1-100> percent").
                    maximum_routes_warning_only: maximum_routes_warning_only
                    missing_policy: Missing policy configuration for all address-families.
                    allowas_in: allowas_in
                    ebgp_multihop: Time-to-live in range of hops.
                    next_hop_self: next_hop_self
                    link_bandwidth: link_bandwidth
                    rib_in_pre_policy_retain: rib_in_pre_policy_retain
                    remove_private_as: Remove private AS numbers in outbound AS path.
                    remove_private_as_ingress: remove_private_as_ingress
                    session_tracker: session_tracker
                    shared_secret: shared_secret
                    ttl_maximum_hops: Maximum number of hops.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class NeighborInterfacesItem(AvdBase):
            _fields = ("_custom_data", "name", "remote_as", "peer", "peer_group", "description", "peer_filter")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Interface name."""
            remote_as: str | None = None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            peer: str | None = None
            """Key only used for documentation or validation purposes."""
            peer_group: str | None = "Peer-group name"
            description: str | None = None
            peer_filter: str | None = None
            """Peer-filter name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                remote_as: str | None = None,
                peer: str | None = None,
                peer_group: str | None = "Peer-group name",
                description: str | None = None,
                peer_filter: str | None = None,
            ) -> None:
                """
                NeighborInterfacesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Interface name.
                    remote_as:
                       BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                       For asdot notation in
                       YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                       number.
                    peer: Key only used for documentation or validation purposes.
                    peer_group: peer_group
                    description: description
                    peer_filter: Peer-filter name.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AggregateAddressesItem(AvdBase):
            _fields = ("_custom_data", "prefix", "advertise_only", "as_set", "summary_only", "attribute_map", "match_map")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            prefix: str = None
            """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
            advertise_only: bool | None = None
            as_set: bool | None = None
            summary_only: bool | None = None
            attribute_map: str | None = None
            """Route-map name."""
            match_map: str | None = None
            """Route-map name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                prefix: str = None,
                advertise_only: bool | None = None,
                as_set: bool | None = None,
                summary_only: bool | None = None,
                attribute_map: str | None = None,
                match_map: str | None = None,
            ) -> None:
                """
                AggregateAddressesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                    advertise_only: advertise_only
                    as_set: as_set
                    summary_only: summary_only
                    attribute_map: Route-map name.
                    match_map: Route-map name.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class RedistributeRoutesItem(AvdBase):
            _fields = ("_custom_data", "source_protocol", "route_map", "rcf", "include_leaked", "ospf_route_type")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            source_protocol: Annotated[str, ValidValues["attached-host", "bgp", "connected", "dynamic", "isis", "ospf", "ospfv3", "rip", "static", "user"]] = (
                None
            )
            route_map: str | None = None
            rcf: str | None = None
            """
            RCF function name with parenthesis.
            Example: MyFunction(myarg).
            `route_map` and `rcf` are mutually
            exclusive. `route_map` takes precedence.
            Only applicable if `source_protocol` is one of `connected`,
            `static`, `isis`, `user`, `dynamic`.
            """
            include_leaked: bool | None = None
            ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]] | None = None
            """
            Routes learned by the OSPF protocol.
            The `ospf_route_type` is valid for source_protocols 'ospf' and
            'ospfv3'.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                source_protocol: Annotated[
                    str, ValidValues["attached-host", "bgp", "connected", "dynamic", "isis", "ospf", "ospfv3", "rip", "static", "user"]
                ] = None,
                route_map: str | None = None,
                rcf: str | None = None,
                include_leaked: bool | None = None,
                ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]] | None = None,
            ) -> None:
                """
                RedistributeRoutesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    source_protocol: source_protocol
                    route_map: route_map
                    rcf:
                       RCF function name with parenthesis.
                       Example: MyFunction(myarg).
                       `route_map` and `rcf` are mutually
                       exclusive. `route_map` takes precedence.
                       Only applicable if `source_protocol` is one of `connected`,
                       `static`, `isis`, `user`, `dynamic`.
                    include_leaked: include_leaked
                    ospf_route_type:
                       Routes learned by the OSPF protocol.
                       The `ospf_route_type` is valid for source_protocols 'ospf' and
                       'ospfv3'.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VlanAwareBundlesItem(AvdBase):
            class RdEvpnDomain(AvdBase):
                _fields = ("_custom_data", "domain", "rd")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                domain: Annotated[str, ValidValues["remote", "all"]] | None = None
                rd: str | None = None
                """Route distinguisher."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    domain: Annotated[str, ValidValues["remote", "all"]] | None = None,
                    rd: str | None = None,
                ) -> None:
                    """
                    RdEvpnDomain.

                    Args:
                    -----
                        _custom_data: _custom_data
                        domain: domain
                        rd: Route distinguisher.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RouteTargets(AvdBase):
                class ImportEvpnDomainsItem(AvdBase):
                    _fields = ("_custom_data", "domain", "route_target")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    domain: Annotated[str, ValidValues["remote", "all"]] | None = None
                    route_target: str | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        domain: Annotated[str, ValidValues["remote", "all"]] | None = None,
                        route_target: str | None = None,
                    ) -> None:
                        """
                        ImportEvpnDomainsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            domain: domain
                            route_target: route_target

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class ExportEvpnDomainsItem(AvdBase):
                    _fields = ("_custom_data", "domain", "route_target")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    domain: Annotated[str, ValidValues["remote", "all"]] | None = None
                    route_target: str | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        domain: Annotated[str, ValidValues["remote", "all"]] | None = None,
                        route_target: str | None = None,
                    ) -> None:
                        """
                        ExportEvpnDomainsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            domain: domain
                            route_target: route_target

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class ImportExportEvpnDomainsItem(AvdBase):
                    _fields = ("_custom_data", "domain", "route_target")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    domain: Annotated[str, ValidValues["remote", "all"]] | None = None
                    route_target: str | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        domain: Annotated[str, ValidValues["remote", "all"]] | None = None,
                        route_target: str | None = None,
                    ) -> None:
                        """
                        ImportExportEvpnDomainsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            domain: domain
                            route_target: route_target

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "both", "field_import", "export", "import_evpn_domains", "export_evpn_domains", "import_export_evpn_domains")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                both: list[str] | None = None
                field_import: list[str] | None = None
                export: list[str] | None = None
                import_evpn_domains: list[ImportEvpnDomainsItem] | None = None
                export_evpn_domains: list[ExportEvpnDomainsItem] | None = None
                import_export_evpn_domains: list[ImportExportEvpnDomainsItem] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    both: list[str] | None = None,
                    field_import: list[str] | None = None,
                    export: list[str] | None = None,
                    import_evpn_domains: list[ImportEvpnDomainsItem] | None = None,
                    export_evpn_domains: list[ExportEvpnDomainsItem] | None = None,
                    import_export_evpn_domains: list[ImportExportEvpnDomainsItem] | None = None,
                ) -> None:
                    """
                    RouteTargets.

                    Args:
                    -----
                        _custom_data: _custom_data
                        both: both
                        field_import: field_import
                        export: export
                        import_evpn_domains: import_evpn_domains
                        export_evpn_domains: export_evpn_domains
                        import_export_evpn_domains: import_export_evpn_domains

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = (
                "_custom_data",
                "name",
                "tenant",
                "description",
                "rd",
                "rd_evpn_domain",
                "route_targets",
                "redistribute_routes",
                "no_redistribute_routes",
                "vlan",
                "eos_cli",
            )
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """VLAN aware bundle name."""
            tenant: str | None = None
            """Key only used for documentation or validation purposes."""
            description: str | None = None
            """Key only used for documentation or validation purposes."""
            rd: str | None = None
            """Route distinguisher."""
            rd_evpn_domain: RdEvpnDomain | None = None
            route_targets: RouteTargets | None = None
            redistribute_routes: list[str] | None = None
            no_redistribute_routes: list[str] | None = None
            vlan: str | None = None
            """VLAN range as string. Example "100-200,300"."""
            eos_cli: str | None = None
            """
            Multiline EOS CLI rendered directly on the Router BGP, VLAN-aware-bundle definition in the final EOS
            configuration.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                tenant: str | None = None,
                description: str | None = None,
                rd: str | None = None,
                rd_evpn_domain: RdEvpnDomain | None = None,
                route_targets: RouteTargets | None = None,
                redistribute_routes: list[str] | None = None,
                no_redistribute_routes: list[str] | None = None,
                vlan: str | None = None,
                eos_cli: str | None = None,
            ) -> None:
                """
                VlanAwareBundlesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VLAN aware bundle name.
                    tenant: Key only used for documentation or validation purposes.
                    description: Key only used for documentation or validation purposes.
                    rd: Route distinguisher.
                    rd_evpn_domain: rd_evpn_domain
                    route_targets: route_targets
                    redistribute_routes: redistribute_routes
                    no_redistribute_routes: no_redistribute_routes
                    vlan: VLAN range as string. Example "100-200,300".
                    eos_cli:
                       Multiline EOS CLI rendered directly on the Router BGP, VLAN-aware-bundle definition in the final EOS
                       configuration.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VlansItem(AvdBase):
            class RdEvpnDomain(AvdBase):
                _fields = ("_custom_data", "domain", "rd")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                domain: Annotated[str, ValidValues["remote", "all"]] | None = None
                rd: str | None = None
                """Route distinguisher."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    domain: Annotated[str, ValidValues["remote", "all"]] | None = None,
                    rd: str | None = None,
                ) -> None:
                    """
                    RdEvpnDomain.

                    Args:
                    -----
                        _custom_data: _custom_data
                        domain: domain
                        rd: Route distinguisher.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RouteTargets(AvdBase):
                class ImportEvpnDomainsItem(AvdBase):
                    _fields = ("_custom_data", "domain", "route_target")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    domain: Annotated[str, ValidValues["remote", "all"]] | None = None
                    route_target: str | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        domain: Annotated[str, ValidValues["remote", "all"]] | None = None,
                        route_target: str | None = None,
                    ) -> None:
                        """
                        ImportEvpnDomainsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            domain: domain
                            route_target: route_target

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class ExportEvpnDomainsItem(AvdBase):
                    _fields = ("_custom_data", "domain", "route_target")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    domain: Annotated[str, ValidValues["remote", "all"]] | None = None
                    route_target: str | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        domain: Annotated[str, ValidValues["remote", "all"]] | None = None,
                        route_target: str | None = None,
                    ) -> None:
                        """
                        ExportEvpnDomainsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            domain: domain
                            route_target: route_target

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class ImportExportEvpnDomainsItem(AvdBase):
                    _fields = ("_custom_data", "domain", "route_target")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    domain: Annotated[str, ValidValues["remote", "all"]] | None = None
                    route_target: str | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        domain: Annotated[str, ValidValues["remote", "all"]] | None = None,
                        route_target: str | None = None,
                    ) -> None:
                        """
                        ImportExportEvpnDomainsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            domain: domain
                            route_target: route_target

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "both", "field_import", "export", "import_evpn_domains", "export_evpn_domains", "import_export_evpn_domains")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                both: list[str] | None = None
                field_import: list[str] | None = None
                export: list[str] | None = None
                import_evpn_domains: list[ImportEvpnDomainsItem] | None = None
                export_evpn_domains: list[ExportEvpnDomainsItem] | None = None
                import_export_evpn_domains: list[ImportExportEvpnDomainsItem] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    both: list[str] | None = None,
                    field_import: list[str] | None = None,
                    export: list[str] | None = None,
                    import_evpn_domains: list[ImportEvpnDomainsItem] | None = None,
                    export_evpn_domains: list[ExportEvpnDomainsItem] | None = None,
                    import_export_evpn_domains: list[ImportExportEvpnDomainsItem] | None = None,
                ) -> None:
                    """
                    RouteTargets.

                    Args:
                    -----
                        _custom_data: _custom_data
                        both: both
                        field_import: field_import
                        export: export
                        import_evpn_domains: import_evpn_domains
                        export_evpn_domains: export_evpn_domains
                        import_export_evpn_domains: import_export_evpn_domains

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "id", "tenant", "rd", "rd_evpn_domain", "eos_cli", "route_targets", "redistribute_routes", "no_redistribute_routes")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            id: int = None
            tenant: str | None = None
            """Key only used for documentation or validation purposes."""
            rd: str | None = None
            """Route distinguisher."""
            rd_evpn_domain: RdEvpnDomain | None = None
            eos_cli: str | None = None
            """
            Multiline EOS CLI rendered directly on the Router BGP, VLAN definition in the final EOS
            configuration.
            """
            route_targets: RouteTargets | None = None
            redistribute_routes: list[str] | None = None
            no_redistribute_routes: list[str] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                id: int = None,
                tenant: str | None = None,
                rd: str | None = None,
                rd_evpn_domain: RdEvpnDomain | None = None,
                eos_cli: str | None = None,
                route_targets: RouteTargets | None = None,
                redistribute_routes: list[str] | None = None,
                no_redistribute_routes: list[str] | None = None,
            ) -> None:
                """
                VlansItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: id
                    tenant: Key only used for documentation or validation purposes.
                    rd: Route distinguisher.
                    rd_evpn_domain: rd_evpn_domain
                    eos_cli:
                       Multiline EOS CLI rendered directly on the Router BGP, VLAN definition in the final EOS
                       configuration.
                    route_targets: route_targets
                    redistribute_routes: redistribute_routes
                    no_redistribute_routes: no_redistribute_routes

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VpwsItem(AvdBase):
            class RouteTargets(AvdBase):
                _fields = ("_custom_data", "import_export")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                import_export: str | None = None
                """Route Target."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, import_export: str | None = None) -> None:
                    """
                    RouteTargets.

                    Args:
                    -----
                        _custom_data: _custom_data
                        import_export: Route Target.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PseudowiresItem(AvdBase):
                _fields = ("_custom_data", "name", "id_local", "id_remote")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Pseudowire name."""
                id_local: int | None = None
                """Must match id_remote on other pe."""
                id_remote: int | None = None
                """Must match id_local on other pe."""

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, name: str = None, id_local: int | None = None, id_remote: int | None = None
                ) -> None:
                    """
                    PseudowiresItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Pseudowire name.
                        id_local: Must match id_remote on other pe.
                        id_remote: Must match id_local on other pe.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "rd", "route_targets", "mpls_control_word", "label_flow", "mtu", "pseudowires")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """VPWS instance name."""
            rd: str | None = None
            """Route distinguisher."""
            route_targets: RouteTargets | None = None
            mpls_control_word: bool | None = None
            label_flow: bool | None = None
            mtu: int | None = None
            pseudowires: list[PseudowiresItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                rd: str | None = None,
                route_targets: RouteTargets | None = None,
                mpls_control_word: bool | None = None,
                label_flow: bool | None = None,
                mtu: int | None = None,
                pseudowires: list[PseudowiresItem] | None = None,
            ) -> None:
                """
                VpwsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VPWS instance name.
                    rd: Route distinguisher.
                    route_targets: route_targets
                    mpls_control_word: mpls_control_word
                    label_flow: label_flow
                    mtu: mtu
                    pseudowires: pseudowires

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyEvpn(AvdBase):
            class NeighborDefault(AvdBase):
                class NextHopSelfReceivedEvpnRoutes(AvdBase):
                    _fields = ("_custom_data", "enable", "inter_domain")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enable: bool | None = None
                    inter_domain: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, enable: bool | None = None, inter_domain: bool | None = None) -> None:
                        """
                        NextHopSelfReceivedEvpnRoutes.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enable: enable
                            inter_domain: inter_domain

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "encapsulation", "next_hop_self_source_interface", "next_hop_self_received_evpn_routes")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                encapsulation: Annotated[str, ValidValues["vxlan", "mpls", "path-selection"]] | None = None
                """Transport encapsulation for neighbor."""
                next_hop_self_source_interface: str | None = None
                """Source interface name."""
                next_hop_self_received_evpn_routes: NextHopSelfReceivedEvpnRoutes | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    encapsulation: Annotated[str, ValidValues["vxlan", "mpls", "path-selection"]] | None = None,
                    next_hop_self_source_interface: str | None = None,
                    next_hop_self_received_evpn_routes: NextHopSelfReceivedEvpnRoutes | None = None,
                ) -> None:
                    """
                    NeighborDefault.

                    Args:
                    -----
                        _custom_data: _custom_data
                        encapsulation: Transport encapsulation for neighbor.
                        next_hop_self_source_interface: Source interface name.
                        next_hop_self_received_evpn_routes: next_hop_self_received_evpn_routes

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NextHopMplsResolutionRibsItem(AvdBase):
                _fields = ("_custom_data", "rib_type", "rib_name")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                rib_type: Annotated[str, ValidValues["system-connected", "tunnel-rib-colored", "tunnel-rib"]] = None
                """Type of RIB. For 'tunnel-rib', use 'rib_name' to specify the name of the Tunnel-RIB to use."""
                rib_name: str | None = None
                """The name of the tunnel-rib to use when using 'tunnel-rib' type."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    rib_type: Annotated[str, ValidValues["system-connected", "tunnel-rib-colored", "tunnel-rib"]] = None,
                    rib_name: str | None = None,
                ) -> None:
                    """
                    NextHopMplsResolutionRibsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        rib_type: Type of RIB. For 'tunnel-rib', use 'rib_name' to specify the name of the Tunnel-RIB to use.
                        rib_name: The name of the tunnel-rib to use when using 'tunnel-rib' type.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborsItem(AvdBase):
                class DefaultRoute(AvdBase):
                    _fields = ("_custom_data", "enabled", "rcf", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None = None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, rcf: str | None = None, route_map: str | None = None
                    ) -> None:
                        """
                        DefaultRoute.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "receive", "send", "send_limit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    receive: bool | None = None
                    """Enable or disable reception of additional-paths."""
                    send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: Annotated[int, Min[2], Max[64]] | None = None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        receive: bool | None = None,
                        send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                        send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "ip_address", "activate", "rcf_in", "rcf_out", "default_route", "additional_paths", "encapsulation")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ip_address: str = None
                activate: bool | None = None
                rcf_in: str | None = None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None = None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute | None = None
                additional_paths: AdditionalPaths | None = None
                encapsulation: Annotated[str, ValidValues["vxlan", "mpls", "path-selection"]] | None = None
                """Transport encapsulation for the neighbor."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    ip_address: str = None,
                    activate: bool | None = None,
                    rcf_in: str | None = None,
                    rcf_out: str | None = None,
                    default_route: DefaultRoute | None = None,
                    additional_paths: AdditionalPaths | None = None,
                    encapsulation: Annotated[str, ValidValues["vxlan", "mpls", "path-selection"]] | None = None,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        default_route: default_route
                        additional_paths: additional_paths
                        encapsulation: Transport encapsulation for the neighbor.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroupsItem(AvdBase):
                class DefaultRoute(AvdBase):
                    _fields = ("_custom_data", "enabled", "rcf", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None = None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, rcf: str | None = None, route_map: str | None = None
                    ) -> None:
                        """
                        DefaultRoute.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "receive", "send", "send_limit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    receive: bool | None = None
                    """Enable or disable reception of additional-paths."""
                    send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: Annotated[int, Min[2], Max[64]] | None = None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        receive: bool | None = None,
                        send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                        send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = (
                    "_custom_data",
                    "name",
                    "activate",
                    "route_map_in",
                    "route_map_out",
                    "rcf_in",
                    "rcf_out",
                    "default_route",
                    "domain_remote",
                    "encapsulation",
                    "additional_paths",
                )
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Peer-group name."""
                activate: bool | None = None
                route_map_in: str | None = None
                """Inbound route-map name."""
                route_map_out: str | None = None
                """Outbound route-map name."""
                rcf_in: str | None = None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None = None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute | None = None
                domain_remote: bool | None = None
                encapsulation: Annotated[str, ValidValues["vxlan", "mpls", "path-selection"]] | None = None
                """Transport encapsulation for the peer-group."""
                additional_paths: AdditionalPaths | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    activate: bool | None = None,
                    route_map_in: str | None = None,
                    route_map_out: str | None = None,
                    rcf_in: str | None = None,
                    rcf_out: str | None = None,
                    default_route: DefaultRoute | None = None,
                    domain_remote: bool | None = None,
                    encapsulation: Annotated[str, ValidValues["vxlan", "mpls", "path-selection"]] | None = None,
                    additional_paths: AdditionalPaths | None = None,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        default_route: default_route
                        domain_remote: domain_remote
                        encapsulation: Transport encapsulation for the peer-group.
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class EvpnHostflapDetection(AvdBase):
                _fields = ("_custom_data", "enabled", "window", "threshold", "expiry_timeout")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                window: Annotated[int, Max[4294967295]] | None = None
                """Time (in seconds) to detect a MAC duplication issue."""
                threshold: Annotated[int, Max[4294967295]] | None = None
                """Minimum number of MAC moves that indicate a MAC Duplication issue."""
                expiry_timeout: Annotated[int, Max[4294967295]] | None = None
                """Time (in seconds) to purge a MAC duplication issue."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    enabled: bool | None = None,
                    window: Annotated[int, Max[4294967295]] | None = None,
                    threshold: Annotated[int, Max[4294967295]] | None = None,
                    expiry_timeout: Annotated[int, Max[4294967295]] | None = None,
                ) -> None:
                    """
                    EvpnHostflapDetection.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        window: Time (in seconds) to detect a MAC duplication issue.
                        threshold: Minimum number of MAC moves that indicate a MAC Duplication issue.
                        expiry_timeout: Time (in seconds) to purge a MAC duplication issue.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NextHop(AvdBase):
                _fields = ("_custom_data", "resolution_disabled")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                resolution_disabled: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, resolution_disabled: bool | None = None) -> None:
                    """
                    NextHop.

                    Args:
                    -----
                        _custom_data: _custom_data
                        resolution_disabled: resolution_disabled

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Route(AvdBase):
                _fields = (
                    "_custom_data",
                    "import_match_failure_action",
                    "import_ethernet_segment_ip_mass_withdraw",
                    "import_overlay_index_gateway",
                    "export_ethernet_segment_ip_mass_withdraw",
                )
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                import_match_failure_action: Annotated[str, ValidValues["discard"]] | None = None
                import_ethernet_segment_ip_mass_withdraw: bool | None = None
                import_overlay_index_gateway: bool | None = None
                export_ethernet_segment_ip_mass_withdraw: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    import_match_failure_action: Annotated[str, ValidValues["discard"]] | None = None,
                    import_ethernet_segment_ip_mass_withdraw: bool | None = None,
                    import_overlay_index_gateway: bool | None = None,
                    export_ethernet_segment_ip_mass_withdraw: bool | None = None,
                ) -> None:
                    """
                    Route.

                    Args:
                    -----
                        _custom_data: _custom_data
                        import_match_failure_action: import_match_failure_action
                        import_ethernet_segment_ip_mass_withdraw: import_ethernet_segment_ip_mass_withdraw
                        import_overlay_index_gateway: import_overlay_index_gateway
                        export_ethernet_segment_ip_mass_withdraw: export_ethernet_segment_ip_mass_withdraw

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class BgpAdditionalPaths(AvdBase):
                class Send(AvdBase):
                    _fields = ("_custom_data", "any", "backup", "ecmp", "ecmp_limit", "limit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    any: bool | None = None
                    """Any eligible path."""
                    backup: bool | None = None
                    """Best path and installed backup path."""
                    ecmp: bool | None = None
                    """All paths in best path ECMP group."""
                    ecmp_limit: Annotated[int, Min[2], Max[64]] | None = None
                    """Amount of ECMP paths to send."""
                    limit: Annotated[int, Min[2], Max[64]] | None = None
                    """Amount of paths to send."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        any: bool | None = None,
                        backup: bool | None = None,
                        ecmp: bool | None = None,
                        ecmp_limit: Annotated[int, Min[2], Max[64]] | None = None,
                        limit: Annotated[int, Min[2], Max[64]] | None = None,
                    ) -> None:
                        """
                        Send.

                        Args:
                        -----
                            _custom_data: _custom_data
                            any: Any eligible path.
                            backup: Best path and installed backup path.
                            ecmp: All paths in best path ECMP group.
                            ecmp_limit: Amount of ECMP paths to send.
                            limit: Amount of paths to send.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "receive", "send")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                receive: bool | None = None
                """Receive multiple paths."""
                send: Send | None = None
                """Send multiple paths."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, receive: bool | None = None, send: Send | None = None) -> None:
                    """
                    BgpAdditionalPaths.

                    Args:
                    -----
                        _custom_data: _custom_data
                        receive: Receive multiple paths.
                        send: Send multiple paths.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Bgp(AvdBase):
                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "receive", "send", "send_limit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    receive: bool | None = None
                    """Enable or disable reception of additional-paths."""
                    send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: Annotated[int, Min[2], Max[64]] | None = None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        receive: bool | None = None,
                        send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                        send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "additional_paths")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                additional_paths: AdditionalPaths | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, additional_paths: AdditionalPaths | None = None) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Layer2FecInPlaceUpdate(AvdBase):
                _fields = ("_custom_data", "enabled", "timeout")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool = None
                timeout: Annotated[int, Max[300]] | None = None
                """In-place FEC update tracking timeout in seconds."""

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, timeout: Annotated[int, Max[300]] | None = None
                ) -> None:
                    """
                    Layer2FecInPlaceUpdate.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        timeout: In-place FEC update tracking timeout in seconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = (
                "_custom_data",
                "domain_identifier",
                "neighbor_default",
                "next_hop_mpls_resolution_ribs",
                "neighbors",
                "peer_groups",
                "evpn_hostflap_detection",
                "next_hop",
                "route",
                "next_hop_unchanged",
                "bgp_additional_paths",
                "bgp",
                "layer_2_fec_in_place_update",
            )
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            domain_identifier: str | None = None
            neighbor_default: NeighborDefault | None = None
            next_hop_mpls_resolution_ribs: list[NextHopMplsResolutionRibsItem] | None = None
            """
            Specify the RIBs used to resolve MPLS next-hops. The order of this list determines the order of RIB
            lookups.
            """
            neighbors: list[NeighborsItem] | None = None
            peer_groups: list[PeerGroupsItem] | None = None
            evpn_hostflap_detection: EvpnHostflapDetection | None = None
            next_hop: NextHop | None = None
            route: Route | None = None
            next_hop_unchanged: bool | None = None
            bgp_additional_paths: BgpAdditionalPaths | None = None
            """BGP additional-paths commands."""
            bgp: Bgp | None = None
            layer_2_fec_in_place_update: Layer2FecInPlaceUpdate | None = None
            """BGP layer-2 in-place FEC operation."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                domain_identifier: str | None = None,
                neighbor_default: NeighborDefault | None = None,
                next_hop_mpls_resolution_ribs: list[NextHopMplsResolutionRibsItem] | None = None,
                neighbors: list[NeighborsItem] | None = None,
                peer_groups: list[PeerGroupsItem] | None = None,
                evpn_hostflap_detection: EvpnHostflapDetection | None = None,
                next_hop: NextHop | None = None,
                route: Route | None = None,
                next_hop_unchanged: bool | None = None,
                bgp_additional_paths: BgpAdditionalPaths | None = None,
                bgp: Bgp | None = None,
                layer_2_fec_in_place_update: Layer2FecInPlaceUpdate | None = None,
            ) -> None:
                """
                AddressFamilyEvpn.

                Args:
                -----
                    _custom_data: _custom_data
                    domain_identifier: domain_identifier
                    neighbor_default: neighbor_default
                    next_hop_mpls_resolution_ribs:
                       Specify the RIBs used to resolve MPLS next-hops. The order of this list determines the order of RIB
                       lookups.
                    neighbors: neighbors
                    peer_groups: peer_groups
                    evpn_hostflap_detection: evpn_hostflap_detection
                    next_hop: next_hop
                    route: route
                    next_hop_unchanged: next_hop_unchanged
                    bgp_additional_paths: BGP additional-paths commands.
                    bgp: bgp
                    layer_2_fec_in_place_update: BGP layer-2 in-place FEC operation.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyRtc(AvdBase):
            class PeerGroupsItem(AvdBase):
                class DefaultRouteTarget(AvdBase):
                    _fields = ("_custom_data", "only", "encoding_origin_as_omit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    only: bool | None = None
                    encoding_origin_as_omit: str | None = None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, only: bool | None = None, encoding_origin_as_omit: str | None = None
                    ) -> None:
                        """
                        DefaultRouteTarget.

                        Args:
                        -----
                            _custom_data: _custom_data
                            only: only
                            encoding_origin_as_omit: encoding_origin_as_omit

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "name", "activate", "default_route_target")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Peer-group name."""
                activate: bool | None = None
                default_route_target: DefaultRouteTarget | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    activate: bool | None = None,
                    default_route_target: DefaultRouteTarget | None = None,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        default_route_target: default_route_target

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "peer_groups")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            peer_groups: list[PeerGroupsItem] | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, peer_groups: list[PeerGroupsItem] | None = None) -> None:
                """
                AddressFamilyRtc.

                Args:
                -----
                    _custom_data: _custom_data
                    peer_groups: peer_groups

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyIpv4(AvdBase):
            class NetworksItem(AvdBase):
                _fields = ("_custom_data", "prefix", "route_map")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                prefix: str = None
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                route_map: str | None = None
                """Route-map name."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, prefix: str = None, route_map: str | None = None) -> None:
                    """
                    NetworksItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                        route_map: Route-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Bgp(AvdBase):
                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "install", "install_ecmp_primary", "receive", "send", "send_limit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    install: bool | None = None
                    """Install BGP backup path."""
                    install_ecmp_primary: bool | None = None
                    """Allow additional path with ECMP primary path."""
                    receive: bool | None = None
                    """Enable or disable reception of additional-paths."""
                    send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: Annotated[int, Min[2], Max[64]] | None = None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        install: bool | None = None,
                        install_ecmp_primary: bool | None = None,
                        receive: bool | None = None,
                        send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                        send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            install: Install BGP backup path.
                            install_ecmp_primary: Allow additional path with ECMP primary path.
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "additional_paths", "redistribute_internal")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                additional_paths: AdditionalPaths | None = None
                redistribute_internal: bool | None = None
                """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    additional_paths: AdditionalPaths | None = None,
                    redistribute_internal: bool | None = None,
                ) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        additional_paths: additional_paths
                        redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroupsItem(AvdBase):
                class DefaultOriginate(AvdBase):
                    _fields = ("_custom_data", "always", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    always: bool | None = None
                    route_map: str | None = None
                    """Route-map name."""

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, always: bool | None = None, route_map: str | None = None) -> None:
                        """
                        DefaultOriginate.

                        Args:
                        -----
                            _custom_data: _custom_data
                            always: always
                            route_map: Route-map name.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "prefix_list", "receive", "send", "send_limit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    prefix_list: str | None = None
                    """Apply the configurations only to the routes matching the prefix list."""
                    receive: bool | None = None
                    """Enable or disable reception of additional-paths."""
                    send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: Annotated[int, Min[2], Max[64]] | None = None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        prefix_list: str | None = None,
                        receive: bool | None = None,
                        send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                        send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            prefix_list: Apply the configurations only to the routes matching the prefix list.
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NextHop(AvdBase):
                    class AddressFamilyIpv6(AvdBase):
                        _fields = ("_custom_data", "enabled", "originate")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        enabled: bool = None
                        originate: bool | None = None

                        def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, originate: bool | None = None) -> None:
                            """
                            AddressFamilyIpv6.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                originate: originate

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "address_family_ipv6")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    address_family_ipv6: AddressFamilyIpv6 | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, address_family_ipv6: AddressFamilyIpv6 | None = None) -> None:
                        """
                        NextHop.

                        Args:
                        -----
                            _custom_data: _custom_data
                            address_family_ipv6: address_family_ipv6

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = (
                    "_custom_data",
                    "name",
                    "activate",
                    "route_map_in",
                    "route_map_out",
                    "rcf_in",
                    "rcf_out",
                    "default_originate",
                    "prefix_list_in",
                    "prefix_list_out",
                    "additional_paths",
                    "next_hop",
                )
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Peer-group name."""
                activate: bool | None = None
                route_map_in: str | None = None
                """Inbound route-map name."""
                route_map_out: str | None = None
                """Outbound route-map name."""
                rcf_in: str | None = None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None = None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_originate: DefaultOriginate | None = None
                prefix_list_in: str | None = None
                """Inbound prefix-list name."""
                prefix_list_out: str | None = None
                """Outbound prefix-list name."""
                additional_paths: AdditionalPaths | None = None
                next_hop: NextHop | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    activate: bool | None = None,
                    route_map_in: str | None = None,
                    route_map_out: str | None = None,
                    rcf_in: str | None = None,
                    rcf_out: str | None = None,
                    default_originate: DefaultOriginate | None = None,
                    prefix_list_in: str | None = None,
                    prefix_list_out: str | None = None,
                    additional_paths: AdditionalPaths | None = None,
                    next_hop: NextHop | None = None,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        default_originate: default_originate
                        prefix_list_in: Inbound prefix-list name.
                        prefix_list_out: Outbound prefix-list name.
                        additional_paths: additional_paths
                        next_hop: next_hop

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborsItem(AvdBase):
                class DefaultOriginate(AvdBase):
                    _fields = ("_custom_data", "always", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    always: bool | None = None
                    route_map: str | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, always: bool | None = None, route_map: str | None = None) -> None:
                        """
                        DefaultOriginate.

                        Args:
                        -----
                            _custom_data: _custom_data
                            always: always
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "prefix_list", "receive", "send", "send_limit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    prefix_list: str | None = None
                    """Apply the configurations only to the routes matching the prefix list."""
                    receive: bool | None = None
                    """Enable or disable reception of additional-paths."""
                    send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: Annotated[int, Min[2], Max[64]] | None = None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        prefix_list: str | None = None,
                        receive: bool | None = None,
                        send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                        send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            prefix_list: Apply the configurations only to the routes matching the prefix list.
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = (
                    "_custom_data",
                    "ip_address",
                    "activate",
                    "route_map_in",
                    "route_map_out",
                    "rcf_in",
                    "rcf_out",
                    "prefix_list_in",
                    "prefix_list_out",
                    "default_originate",
                    "additional_paths",
                )
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ip_address: str = None
                activate: bool | None = None
                route_map_in: str | None = None
                """Inbound route-map name."""
                route_map_out: str | None = None
                """Outbound route-map name."""
                rcf_in: str | None = None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None = None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                prefix_list_in: str | None = None
                """Inbound prefix-list name."""
                prefix_list_out: str | None = None
                """Prefix-list name."""
                default_originate: DefaultOriginate | None = None
                additional_paths: AdditionalPaths | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    ip_address: str = None,
                    activate: bool | None = None,
                    route_map_in: str | None = None,
                    route_map_out: str | None = None,
                    rcf_in: str | None = None,
                    rcf_out: str | None = None,
                    prefix_list_in: str | None = None,
                    prefix_list_out: str | None = None,
                    default_originate: DefaultOriginate | None = None,
                    additional_paths: AdditionalPaths | None = None,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        prefix_list_in: Inbound prefix-list name.
                        prefix_list_out: Prefix-list name.
                        default_originate: default_originate
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RedistributeRoutesItem(AvdBase):
                _fields = ("_custom_data", "source_protocol", "route_map", "include_leaked", "rcf", "ospf_route_type")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                source_protocol: Annotated[
                    str, ValidValues["attached-host", "bgp", "connected", "dynamic", "isis", "ospf", "ospfv3", "rip", "static", "user"]
                ] = None
                route_map: str | None = None
                include_leaked: bool | None = None
                """Only applicable if `source_protocol` is one of `connected`, `static`, `isis`, `ospf`, `ospfv3`."""
                rcf: str | None = None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                Only applicable if `source_protocol` is one of `connected`,
                `static`, `isis`, `user`, `dynamic`.
                """
                ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]] | None = None
                """
                Routes learned by the OSPF protocol.
                The `ospf_route_type` is valid for source_protocols 'ospf' and
                'ospfv3'.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    source_protocol: Annotated[
                        str, ValidValues["attached-host", "bgp", "connected", "dynamic", "isis", "ospf", "ospfv3", "rip", "static", "user"]
                    ] = None,
                    route_map: str | None = None,
                    include_leaked: bool | None = None,
                    rcf: str | None = None,
                    ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]] | None = None,
                ) -> None:
                    """
                    RedistributeRoutesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_protocol: source_protocol
                        route_map: route_map
                        include_leaked: Only applicable if `source_protocol` is one of `connected`, `static`, `isis`, `ospf`, `ospfv3`.
                        rcf:
                           RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                           `route_map` and `rcf` are mutually
                           exclusive. `route_map` takes precedence.
                           Only applicable if `source_protocol` is one of `connected`,
                           `static`, `isis`, `user`, `dynamic`.
                        ospf_route_type:
                           Routes learned by the OSPF protocol.
                           The `ospf_route_type` is valid for source_protocols 'ospf' and
                           'ospfv3'.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "networks", "bgp", "peer_groups", "neighbors", "redistribute_routes")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            networks: list[NetworksItem] | None = None
            bgp: Bgp | None = None
            peer_groups: list[PeerGroupsItem] | None = None
            neighbors: list[NeighborsItem] | None = None
            redistribute_routes: list[RedistributeRoutesItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                networks: list[NetworksItem] | None = None,
                bgp: Bgp | None = None,
                peer_groups: list[PeerGroupsItem] | None = None,
                neighbors: list[NeighborsItem] | None = None,
                redistribute_routes: list[RedistributeRoutesItem] | None = None,
            ) -> None:
                """
                AddressFamilyIpv4.

                Args:
                -----
                    _custom_data: _custom_data
                    networks: networks
                    bgp: bgp
                    peer_groups: peer_groups
                    neighbors: neighbors
                    redistribute_routes: redistribute_routes

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyIpv4LabeledUnicast(AvdBase):
            class AigpSession(AvdBase):
                _fields = ("_custom_data", "confederation", "ebgp", "ibgp")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                confederation: bool | None = None
                ebgp: bool | None = None
                ibgp: bool | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, confederation: bool | None = None, ebgp: bool | None = None, ibgp: bool | None = None
                ) -> None:
                    """
                    AigpSession.

                    Args:
                    -----
                        _custom_data: _custom_data
                        confederation: confederation
                        ebgp: ebgp
                        ibgp: ibgp

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Bgp(AvdBase):
                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "receive", "send", "send_limit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    receive: bool | None = None
                    """Enable or disable reception of additional-paths."""
                    send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: Annotated[int, Min[2], Max[64]] | None = None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        receive: bool | None = None,
                        send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                        send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class MissingPolicy(AvdBase):
                    class DirectionIn(AvdBase):
                        _fields = ("_custom_data", "action", "include_community_list", "include_prefix_list", "include_sub_route_map")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        action: Annotated[str, ValidValues["deny", "permit", "deny-in-out"]] = None
                        """Missing policy action."""
                        include_community_list: bool | None = None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None = None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None = None
                        """Include sub-route-map references in missing policy decision."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            action: Annotated[str, ValidValues["deny", "permit", "deny-in-out"]] = None,
                            include_community_list: bool | None = None,
                            include_prefix_list: bool | None = None,
                            include_sub_route_map: bool | None = None,
                        ) -> None:
                            """
                            DirectionIn.

                            Args:
                            -----
                                _custom_data: _custom_data
                                action: Missing policy action.
                                include_community_list: Include community-list references in missing policy decision.
                                include_prefix_list: Include prefix-list references in missing policy decision.
                                include_sub_route_map: Include sub-route-map references in missing policy decision.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class DirectionOut(AvdBase):
                        _fields = ("_custom_data", "action", "include_community_list", "include_prefix_list", "include_sub_route_map")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        action: Annotated[str, ValidValues["deny", "permit", "deny-in-out"]] = None
                        """Missing policy action."""
                        include_community_list: bool | None = None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None = None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None = None
                        """Include sub-route-map references in missing policy decision."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            action: Annotated[str, ValidValues["deny", "permit", "deny-in-out"]] = None,
                            include_community_list: bool | None = None,
                            include_prefix_list: bool | None = None,
                            include_sub_route_map: bool | None = None,
                        ) -> None:
                            """
                            DirectionOut.

                            Args:
                            -----
                                _custom_data: _custom_data
                                action: Missing policy action.
                                include_community_list: Include community-list references in missing policy decision.
                                include_prefix_list: Include prefix-list references in missing policy decision.
                                include_sub_route_map: Include sub-route-map references in missing policy decision.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "direction_in", "direction_out")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    direction_in: DirectionIn | None = None
                    """Missing policy inbound direction."""
                    direction_out: DirectionOut | None = None
                    """Missing policy outbound direction."""

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, direction_in: DirectionIn | None = None, direction_out: DirectionOut | None = None
                    ) -> None:
                        """
                        MissingPolicy.

                        Args:
                        -----
                            _custom_data: _custom_data
                            direction_in: Missing policy inbound direction.
                            direction_out: Missing policy outbound direction.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "additional_paths", "missing_policy", "next_hop_unchanged")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                additional_paths: AdditionalPaths | None = None
                missing_policy: MissingPolicy | None = None
                """Missing policy configuration for all address-families."""
                next_hop_unchanged: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    additional_paths: AdditionalPaths | None = None,
                    missing_policy: MissingPolicy | None = None,
                    next_hop_unchanged: bool | None = None,
                ) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        additional_paths: additional_paths
                        missing_policy: Missing policy configuration for all address-families.
                        next_hop_unchanged: next_hop_unchanged

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborDefault(AvdBase):
                _fields = ("_custom_data", "next_hop_self")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                next_hop_self: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, next_hop_self: bool | None = None) -> None:
                    """
                    NeighborDefault.

                    Args:
                    -----
                        _custom_data: _custom_data
                        next_hop_self: next_hop_self

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroupsItem(AvdBase):
                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "receive", "send", "send_limit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    receive: bool | None = None
                    """Enable or disable reception of additional-paths."""
                    send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: Annotated[int, Min[2], Max[64]] | None = None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        receive: bool | None = None,
                        send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                        send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class GracefulRestartHelper(AvdBase):
                    _fields = ("_custom_data", "stale_route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    stale_route_map: str | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, stale_route_map: str | None = None) -> None:
                        """
                        GracefulRestartHelper.

                        Args:
                        -----
                            _custom_data: _custom_data
                            stale_route_map: stale_route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class MissingPolicy(AvdBase):
                    class DirectionIn(AvdBase):
                        _fields = ("_custom_data", "action", "include_community_list", "include_prefix_list", "include_sub_route_map")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        action: Annotated[str, ValidValues["deny", "permit", "deny-in-out"]] = None
                        """Missing policy action."""
                        include_community_list: bool | None = None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None = None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None = None
                        """Include sub-route-map references in missing policy decision."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            action: Annotated[str, ValidValues["deny", "permit", "deny-in-out"]] = None,
                            include_community_list: bool | None = None,
                            include_prefix_list: bool | None = None,
                            include_sub_route_map: bool | None = None,
                        ) -> None:
                            """
                            DirectionIn.

                            Args:
                            -----
                                _custom_data: _custom_data
                                action: Missing policy action.
                                include_community_list: Include community-list references in missing policy decision.
                                include_prefix_list: Include prefix-list references in missing policy decision.
                                include_sub_route_map: Include sub-route-map references in missing policy decision.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class DirectionOut(AvdBase):
                        _fields = ("_custom_data", "action", "include_community_list", "include_prefix_list", "include_sub_route_map")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        action: Annotated[str, ValidValues["deny", "permit", "deny-in-out"]] = None
                        """Missing policy action."""
                        include_community_list: bool | None = None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None = None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None = None
                        """Include sub-route-map references in missing policy decision."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            action: Annotated[str, ValidValues["deny", "permit", "deny-in-out"]] = None,
                            include_community_list: bool | None = None,
                            include_prefix_list: bool | None = None,
                            include_sub_route_map: bool | None = None,
                        ) -> None:
                            """
                            DirectionOut.

                            Args:
                            -----
                                _custom_data: _custom_data
                                action: Missing policy action.
                                include_community_list: Include community-list references in missing policy decision.
                                include_prefix_list: Include prefix-list references in missing policy decision.
                                include_sub_route_map: Include sub-route-map references in missing policy decision.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "direction_in", "direction_out")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    direction_in: DirectionIn | None = None
                    """Missing policy inbound direction."""
                    direction_out: DirectionOut | None = None
                    """Missing policy outbound direction."""

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, direction_in: DirectionIn | None = None, direction_out: DirectionOut | None = None
                    ) -> None:
                        """
                        MissingPolicy.

                        Args:
                        -----
                            _custom_data: _custom_data
                            direction_in: Missing policy inbound direction.
                            direction_out: Missing policy outbound direction.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NextHopResolution(AvdBase):
                    _fields = ("_custom_data", "v4_mapped_v6_translation")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    v4_mapped_v6_translation: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, v4_mapped_v6_translation: bool | None = None) -> None:
                        """
                        NextHopResolution.

                        Args:
                        -----
                            _custom_data: _custom_data
                            v4_mapped_v6_translation: v4_mapped_v6_translation

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = (
                    "_custom_data",
                    "name",
                    "activate",
                    "additional_paths",
                    "aigp_session",
                    "graceful_restart",
                    "graceful_restart_helper",
                    "maximum_advertised_routes",
                    "maximum_advertised_routes_warning_limit",
                    "missing_policy",
                    "multi_path",
                    "next_hop_resolution",
                    "next_hop_self",
                    "next_hop_self_source_interface",
                    "next_hop_self_v4_mapped_v6_source_interface",
                    "next_hop_unchanged",
                    "rcf_in",
                    "rcf_out",
                    "route_map_in",
                    "route_map_out",
                )
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Peer-group name."""
                activate: bool | None = None
                additional_paths: AdditionalPaths | None = None
                aigp_session: bool | None = None
                graceful_restart: bool | None = None
                graceful_restart_helper: GracefulRestartHelper | None = None
                maximum_advertised_routes: Annotated[int, Max[4294967294]] | None = None
                """Maximum number of routes (0 means unlimited)."""
                maximum_advertised_routes_warning_limit: str | None = None
                """
                Maximum number of routes after which a warning is issued (0 means never warn) or
                Percentage of
                maximum number of routes at which to warn ("<1-100> percent").
                """
                missing_policy: MissingPolicy | None = None
                """Missing policy configuration for BGP Labeled-Unicast neighbor."""
                multi_path: bool | None = None
                next_hop_resolution: NextHopResolution | None = None
                next_hop_self: bool | None = None
                next_hop_self_source_interface: str | None = None
                """Source interface name."""
                next_hop_self_v4_mapped_v6_source_interface: str | None = None
                """v4-mapped-v6 source interface name. Takes precedence over the next_hop_self_source_interface."""
                next_hop_unchanged: bool | None = None
                rcf_in: str | None = None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None = None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                route_map_in: str | None = None
                """Inbound route-map name."""
                route_map_out: str | None = None
                """Outbound route-map name."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    activate: bool | None = None,
                    additional_paths: AdditionalPaths | None = None,
                    aigp_session: bool | None = None,
                    graceful_restart: bool | None = None,
                    graceful_restart_helper: GracefulRestartHelper | None = None,
                    maximum_advertised_routes: Annotated[int, Max[4294967294]] | None = None,
                    maximum_advertised_routes_warning_limit: str | None = None,
                    missing_policy: MissingPolicy | None = None,
                    multi_path: bool | None = None,
                    next_hop_resolution: NextHopResolution | None = None,
                    next_hop_self: bool | None = None,
                    next_hop_self_source_interface: str | None = None,
                    next_hop_self_v4_mapped_v6_source_interface: str | None = None,
                    next_hop_unchanged: bool | None = None,
                    rcf_in: str | None = None,
                    rcf_out: str | None = None,
                    route_map_in: str | None = None,
                    route_map_out: str | None = None,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        additional_paths: additional_paths
                        aigp_session: aigp_session
                        graceful_restart: graceful_restart
                        graceful_restart_helper: graceful_restart_helper
                        maximum_advertised_routes: Maximum number of routes (0 means unlimited).
                        maximum_advertised_routes_warning_limit:
                           Maximum number of routes after which a warning is issued (0 means never warn) or
                           Percentage of
                           maximum number of routes at which to warn ("<1-100> percent").
                        missing_policy: Missing policy configuration for BGP Labeled-Unicast neighbor.
                        multi_path: multi_path
                        next_hop_resolution: next_hop_resolution
                        next_hop_self: next_hop_self
                        next_hop_self_source_interface: Source interface name.
                        next_hop_self_v4_mapped_v6_source_interface: v4-mapped-v6 source interface name. Takes precedence over the next_hop_self_source_interface.
                        next_hop_unchanged: next_hop_unchanged
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborsItem(AvdBase):
                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "receive", "send", "send_limit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    receive: bool | None = None
                    """Enable or disable reception of additional-paths."""
                    send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: Annotated[int, Min[2], Max[64]] | None = None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        receive: bool | None = None,
                        send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                        send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class GracefulRestartHelper(AvdBase):
                    _fields = ("_custom_data", "stale_route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    stale_route_map: str | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, stale_route_map: str | None = None) -> None:
                        """
                        GracefulRestartHelper.

                        Args:
                        -----
                            _custom_data: _custom_data
                            stale_route_map: stale_route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class MissingPolicy(AvdBase):
                    class DirectionIn(AvdBase):
                        _fields = ("_custom_data", "action", "include_community_list", "include_prefix_list", "include_sub_route_map")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        action: Annotated[str, ValidValues["deny", "permit", "deny-in-out"]] = None
                        """Missing policy action."""
                        include_community_list: bool | None = None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None = None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None = None
                        """Include sub-route-map references in missing policy decision."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            action: Annotated[str, ValidValues["deny", "permit", "deny-in-out"]] = None,
                            include_community_list: bool | None = None,
                            include_prefix_list: bool | None = None,
                            include_sub_route_map: bool | None = None,
                        ) -> None:
                            """
                            DirectionIn.

                            Args:
                            -----
                                _custom_data: _custom_data
                                action: Missing policy action.
                                include_community_list: Include community-list references in missing policy decision.
                                include_prefix_list: Include prefix-list references in missing policy decision.
                                include_sub_route_map: Include sub-route-map references in missing policy decision.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class DirectionOut(AvdBase):
                        _fields = ("_custom_data", "action", "include_community_list", "include_prefix_list", "include_sub_route_map")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        action: Annotated[str, ValidValues["deny", "permit", "deny-in-out"]] = None
                        """Missing policy action."""
                        include_community_list: bool | None = None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None = None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None = None
                        """Include sub-route-map references in missing policy decision."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            action: Annotated[str, ValidValues["deny", "permit", "deny-in-out"]] = None,
                            include_community_list: bool | None = None,
                            include_prefix_list: bool | None = None,
                            include_sub_route_map: bool | None = None,
                        ) -> None:
                            """
                            DirectionOut.

                            Args:
                            -----
                                _custom_data: _custom_data
                                action: Missing policy action.
                                include_community_list: Include community-list references in missing policy decision.
                                include_prefix_list: Include prefix-list references in missing policy decision.
                                include_sub_route_map: Include sub-route-map references in missing policy decision.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "direction_in", "direction_out")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    direction_in: DirectionIn | None = None
                    """Missing policy inbound direction."""
                    direction_out: DirectionOut | None = None
                    """Missing policy outbound direction."""

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, direction_in: DirectionIn | None = None, direction_out: DirectionOut | None = None
                    ) -> None:
                        """
                        MissingPolicy.

                        Args:
                        -----
                            _custom_data: _custom_data
                            direction_in: Missing policy inbound direction.
                            direction_out: Missing policy outbound direction.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NextHopResolution(AvdBase):
                    _fields = ("_custom_data", "v4_mapped_v6_translation")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    v4_mapped_v6_translation: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, v4_mapped_v6_translation: bool | None = None) -> None:
                        """
                        NextHopResolution.

                        Args:
                        -----
                            _custom_data: _custom_data
                            v4_mapped_v6_translation: v4_mapped_v6_translation

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = (
                    "_custom_data",
                    "ip_address",
                    "activate",
                    "additional_paths",
                    "aigp_session",
                    "graceful_restart",
                    "graceful_restart_helper",
                    "maximum_advertised_routes",
                    "maximum_advertised_routes_warning_limit",
                    "missing_policy",
                    "multi_path",
                    "next_hop_resolution",
                    "next_hop_self",
                    "next_hop_self_source_interface",
                    "next_hop_self_v4_mapped_v6_source_interface",
                    "next_hop_unchanged",
                    "rcf_in",
                    "rcf_out",
                    "route_map_in",
                    "route_map_out",
                )
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ip_address: str = None
                activate: bool | None = None
                additional_paths: AdditionalPaths | None = None
                aigp_session: bool | None = None
                graceful_restart: bool | None = None
                graceful_restart_helper: GracefulRestartHelper | None = None
                maximum_advertised_routes: Annotated[int, Max[4294967294]] | None = None
                """Maximum number of routes (0 means unlimited)."""
                maximum_advertised_routes_warning_limit: str | None = None
                """
                Maximum number of routes after which a warning is issued (0 means never warn) or
                Percentage of
                maximum number of routes at which to warn ("<1-100> percent").
                """
                missing_policy: MissingPolicy | None = None
                """Missing policy configuration for BGP Labeled-Unicast neighbor."""
                multi_path: bool | None = None
                next_hop_resolution: NextHopResolution | None = None
                next_hop_self: bool | None = None
                next_hop_self_source_interface: str | None = None
                """Source interface name."""
                next_hop_self_v4_mapped_v6_source_interface: str | None = None
                """v4-mapped-v6 source interface name. Takes precedence over the next_hop_self_source_interface."""
                next_hop_unchanged: bool | None = None
                rcf_in: str | None = None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None = None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                route_map_in: str | None = None
                """Inbound route-map name."""
                route_map_out: str | None = None
                """Outbound route-map name."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    ip_address: str = None,
                    activate: bool | None = None,
                    additional_paths: AdditionalPaths | None = None,
                    aigp_session: bool | None = None,
                    graceful_restart: bool | None = None,
                    graceful_restart_helper: GracefulRestartHelper | None = None,
                    maximum_advertised_routes: Annotated[int, Max[4294967294]] | None = None,
                    maximum_advertised_routes_warning_limit: str | None = None,
                    missing_policy: MissingPolicy | None = None,
                    multi_path: bool | None = None,
                    next_hop_resolution: NextHopResolution | None = None,
                    next_hop_self: bool | None = None,
                    next_hop_self_source_interface: str | None = None,
                    next_hop_self_v4_mapped_v6_source_interface: str | None = None,
                    next_hop_unchanged: bool | None = None,
                    rcf_in: str | None = None,
                    rcf_out: str | None = None,
                    route_map_in: str | None = None,
                    route_map_out: str | None = None,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        additional_paths: additional_paths
                        aigp_session: aigp_session
                        graceful_restart: graceful_restart
                        graceful_restart_helper: graceful_restart_helper
                        maximum_advertised_routes: Maximum number of routes (0 means unlimited).
                        maximum_advertised_routes_warning_limit:
                           Maximum number of routes after which a warning is issued (0 means never warn) or
                           Percentage of
                           maximum number of routes at which to warn ("<1-100> percent").
                        missing_policy: Missing policy configuration for BGP Labeled-Unicast neighbor.
                        multi_path: multi_path
                        next_hop_resolution: next_hop_resolution
                        next_hop_self: next_hop_self
                        next_hop_self_source_interface: Source interface name.
                        next_hop_self_v4_mapped_v6_source_interface: v4-mapped-v6 source interface name. Takes precedence over the next_hop_self_source_interface.
                        next_hop_unchanged: next_hop_unchanged
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NetworksItem(AvdBase):
                _fields = ("_custom_data", "prefix", "route_map")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                prefix: str = None
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                route_map: str | None = None
                """Route-map name."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, prefix: str = None, route_map: str | None = None) -> None:
                    """
                    NetworksItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                        route_map: Route-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NextHopsItem(AvdBase):
                _fields = ("_custom_data", "ip_address", "lfib_backup_ip_forwarding")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ip_address: str = None
                lfib_backup_ip_forwarding: bool | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, ip_address: str = None, lfib_backup_ip_forwarding: bool | None = None
                ) -> None:
                    """
                    NextHopsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        lfib_backup_ip_forwarding: lfib_backup_ip_forwarding

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NextHopResolutionRibsItem(AvdBase):
                _fields = ("_custom_data", "rib_type", "rib_name")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                rib_type: Annotated[str, ValidValues["system-connected", "tunnel-rib-colored", "tunnel-rib"]] = None
                """Type of RIB. For 'tunnel-rib', use 'rib_name' to specify the name of the Tunnel-RIB to use."""
                rib_name: str | None = None
                """The name of the tunnel-rib to use when using 'tunnel-rib' type."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    rib_type: Annotated[str, ValidValues["system-connected", "tunnel-rib-colored", "tunnel-rib"]] = None,
                    rib_name: str | None = None,
                ) -> None:
                    """
                    NextHopResolutionRibsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        rib_type: Type of RIB. For 'tunnel-rib', use 'rib_name' to specify the name of the Tunnel-RIB to use.
                        rib_name: The name of the tunnel-rib to use when using 'tunnel-rib' type.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class TunnelSourceProtocolsItem(AvdBase):
                _fields = ("_custom_data", "protocol", "rcf")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                protocol: Annotated[str, ValidValues["isis segment-routing", "ldp"]] = None
                rcf: str | None = None
                """
                Optional RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    protocol: Annotated[str, ValidValues["isis segment-routing", "ldp"]] = None,
                    rcf: str | None = None,
                ) -> None:
                    """
                    TunnelSourceProtocolsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        protocol: protocol
                        rcf:
                           Optional RCF function name with parenthesis.
                           Example: MyFunction(myarg).

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = (
                "_custom_data",
                "aigp_session",
                "bgp",
                "graceful_restart",
                "label_local_termination",
                "lfib_entry_installation_skipped",
                "neighbor_default",
                "peer_groups",
                "neighbors",
                "networks",
                "next_hops",
                "next_hop_resolution_ribs",
                "tunnel_source_protocols",
                "update_wait_for_convergence",
            )
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            aigp_session: AigpSession | None = None
            bgp: Bgp | None = None
            graceful_restart: bool | None = None
            label_local_termination: Annotated[str, ValidValues["explicit-null", "implicit-null"]] | None = None
            lfib_entry_installation_skipped: bool | None = None
            """Skip LFIB entry installation and next hop self route advertisements."""
            neighbor_default: NeighborDefault | None = None
            peer_groups: list[PeerGroupsItem] | None = None
            neighbors: list[NeighborsItem] | None = None
            networks: list[NetworksItem] | None = None
            next_hops: list[NextHopsItem] | None = None
            next_hop_resolution_ribs: list[NextHopResolutionRibsItem] | None = None
            """
            Specify the RIBs used to resolve next-hops. The order of this list determines the order of RIB
            lookups.
            """
            tunnel_source_protocols: list[TunnelSourceProtocolsItem] | None = None
            update_wait_for_convergence: bool | None = None
            """Wait for BGP to converge before sending out any route updates."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                aigp_session: AigpSession | None = None,
                bgp: Bgp | None = None,
                graceful_restart: bool | None = None,
                label_local_termination: Annotated[str, ValidValues["explicit-null", "implicit-null"]] | None = None,
                lfib_entry_installation_skipped: bool | None = None,
                neighbor_default: NeighborDefault | None = None,
                peer_groups: list[PeerGroupsItem] | None = None,
                neighbors: list[NeighborsItem] | None = None,
                networks: list[NetworksItem] | None = None,
                next_hops: list[NextHopsItem] | None = None,
                next_hop_resolution_ribs: list[NextHopResolutionRibsItem] | None = None,
                tunnel_source_protocols: list[TunnelSourceProtocolsItem] | None = None,
                update_wait_for_convergence: bool | None = None,
            ) -> None:
                """
                AddressFamilyIpv4LabeledUnicast.

                Args:
                -----
                    _custom_data: _custom_data
                    aigp_session: aigp_session
                    bgp: bgp
                    graceful_restart: graceful_restart
                    label_local_termination: label_local_termination
                    lfib_entry_installation_skipped: Skip LFIB entry installation and next hop self route advertisements.
                    neighbor_default: neighbor_default
                    peer_groups: peer_groups
                    neighbors: neighbors
                    networks: networks
                    next_hops: next_hops
                    next_hop_resolution_ribs:
                       Specify the RIBs used to resolve next-hops. The order of this list determines the order of RIB
                       lookups.
                    tunnel_source_protocols: tunnel_source_protocols
                    update_wait_for_convergence: Wait for BGP to converge before sending out any route updates.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyIpv4Multicast(AvdBase):
            class Bgp(AvdBase):
                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "receive")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    receive: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, receive: bool | None = None) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: receive

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "additional_paths")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                additional_paths: AdditionalPaths | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, additional_paths: AdditionalPaths | None = None) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroupsItem(AvdBase):
                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "receive")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    receive: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, receive: bool | None = None) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: receive

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "name", "activate", "route_map_in", "route_map_out", "additional_paths")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Peer-group name."""
                activate: bool | None = None
                route_map_in: str | None = None
                """Inbound route-map name."""
                route_map_out: str | None = None
                """Outbound route-map name."""
                additional_paths: AdditionalPaths | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    activate: bool | None = None,
                    route_map_in: str | None = None,
                    route_map_out: str | None = None,
                    additional_paths: AdditionalPaths | None = None,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborsItem(AvdBase):
                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "receive")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    receive: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, receive: bool | None = None) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: receive

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "ip_address", "activate", "route_map_in", "route_map_out", "additional_paths")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ip_address: str = None
                activate: bool | None = None
                route_map_in: str | None = None
                """Inbound route-map name."""
                route_map_out: str | None = None
                """Outbound route-map name."""
                additional_paths: AdditionalPaths | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    ip_address: str = None,
                    activate: bool | None = None,
                    route_map_in: str | None = None,
                    route_map_out: str | None = None,
                    additional_paths: AdditionalPaths | None = None,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Redistribute(AvdBase):
                class AttachedHost(AvdBase):
                    _fields = ("_custom_data", "enabled", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    route_map: str | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, route_map: str | None = None) -> None:
                        """
                        AttachedHost.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Connected(AvdBase):
                    _fields = ("_custom_data", "enabled", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    route_map: str | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, route_map: str | None = None) -> None:
                        """
                        Connected.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Isis(AvdBase):
                    _fields = ("_custom_data", "enabled", "isis_level", "route_map", "rcf", "include_leaked")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    isis_level: Annotated[str, ValidValues["level-1", "level-2", "level-1-2"]] | None = None
                    """Redistribute IS-IS route level."""
                    route_map: str | None = None
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None = None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        enabled: bool = None,
                        isis_level: Annotated[str, ValidValues["level-1", "level-2", "level-1-2"]] | None = None,
                        route_map: str | None = None,
                        rcf: str | None = None,
                        include_leaked: bool | None = None,
                    ) -> None:
                        """
                        Isis.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            isis_level: Redistribute IS-IS route level.
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Ospf(AvdBase):
                    class MatchExternal(AvdBase):
                        _fields = ("_custom_data", "enabled", "route_map")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        enabled: bool = None
                        route_map: str | None = None

                        def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, route_map: str | None = None) -> None:
                            """
                            MatchExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchInternal(AvdBase):
                        _fields = ("_custom_data", "enabled", "route_map")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        enabled: bool = None
                        route_map: str | None = None

                        def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, route_map: str | None = None) -> None:
                            """
                            MatchInternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchNssaExternal(AvdBase):
                        _fields = ("_custom_data", "enabled", "nssa_type", "route_map")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        enabled: bool = None
                        nssa_type: Annotated[int, ValidValues[1, 2]] | None = None
                        """NSSA External Type Number."""
                        route_map: str | None = None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            enabled: bool = None,
                            nssa_type: Annotated[int, ValidValues[1, 2]] | None = None,
                            route_map: str | None = None,
                        ) -> None:
                            """
                            MatchNssaExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                nssa_type: NSSA External Type Number.
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "enabled", "match_external", "match_internal", "match_nssa_external", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None
                    """Redistribute OSPF routes."""
                    match_external: MatchExternal | None = None
                    """Redistribute OSPF routes learned from external sources."""
                    match_internal: MatchInternal | None = None
                    """Redistribute OSPF routes learned from internal sources."""
                    match_nssa_external: MatchNssaExternal | None = None
                    """Redistribute OSPF routes learned from external NSSA sources."""
                    route_map: str | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        enabled: bool | None = None,
                        match_external: MatchExternal | None = None,
                        match_internal: MatchInternal | None = None,
                        match_nssa_external: MatchNssaExternal | None = None,
                        route_map: str | None = None,
                    ) -> None:
                        """
                        Ospf.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: Redistribute OSPF routes.
                            match_external: Redistribute OSPF routes learned from external sources.
                            match_internal: Redistribute OSPF routes learned from internal sources.
                            match_nssa_external: Redistribute OSPF routes learned from external NSSA sources.
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Ospfv3(AvdBase):
                    class MatchExternal(AvdBase):
                        _fields = ("_custom_data", "enabled", "route_map")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        enabled: bool = None
                        route_map: str | None = None

                        def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, route_map: str | None = None) -> None:
                            """
                            MatchExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchInternal(AvdBase):
                        _fields = ("_custom_data", "enabled", "route_map")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        enabled: bool = None
                        route_map: str | None = None

                        def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, route_map: str | None = None) -> None:
                            """
                            MatchInternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchNssaExternal(AvdBase):
                        _fields = ("_custom_data", "enabled", "nssa_type", "route_map")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        enabled: bool = None
                        nssa_type: Annotated[int, ValidValues[1, 2]] | None = None
                        """NSSA External Type Number."""
                        route_map: str | None = None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            enabled: bool = None,
                            nssa_type: Annotated[int, ValidValues[1, 2]] | None = None,
                            route_map: str | None = None,
                        ) -> None:
                            """
                            MatchNssaExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                nssa_type: NSSA External Type Number.
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "enabled", "match_external", "match_internal", "match_nssa_external", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None
                    """Redistribute OSPFv3 routes."""
                    match_external: MatchExternal | None = None
                    """Redistribute OSPFv3 routes learned from external sources."""
                    match_internal: MatchInternal | None = None
                    """Redistribute OSPFv3 routes learned from internal sources."""
                    match_nssa_external: MatchNssaExternal | None = None
                    """Redistribute OSPFv3 routes learned from external NSSA sources."""
                    route_map: str | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        enabled: bool | None = None,
                        match_external: MatchExternal | None = None,
                        match_internal: MatchInternal | None = None,
                        match_nssa_external: MatchNssaExternal | None = None,
                        route_map: str | None = None,
                    ) -> None:
                        """
                        Ospfv3.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: Redistribute OSPFv3 routes.
                            match_external: Redistribute OSPFv3 routes learned from external sources.
                            match_internal: Redistribute OSPFv3 routes learned from internal sources.
                            match_nssa_external: Redistribute OSPFv3 routes learned from external NSSA sources.
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Static(AvdBase):
                    _fields = ("_custom_data", "enabled", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    route_map: str | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, route_map: str | None = None) -> None:
                        """
                        Static.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "attached_host", "connected", "isis", "ospf", "ospfv3", "static")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                attached_host: AttachedHost | None = None
                connected: Connected | None = None
                isis: Isis | None = None
                ospf: Ospf | None = None
                ospfv3: Ospfv3 | None = None
                static: Static | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    attached_host: AttachedHost | None = None,
                    connected: Connected | None = None,
                    isis: Isis | None = None,
                    ospf: Ospf | None = None,
                    ospfv3: Ospfv3 | None = None,
                    static: Static | None = None,
                ) -> None:
                    """
                    Redistribute.

                    Args:
                    -----
                        _custom_data: _custom_data
                        attached_host: attached_host
                        connected: connected
                        isis: isis
                        ospf: ospf
                        ospfv3: ospfv3
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RedistributeRoutesItem(AvdBase):
                _fields = ("_custom_data", "source_protocol", "route_map", "include_leaked", "rcf", "ospf_route_type")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                source_protocol: str = None
                route_map: str | None = None
                include_leaked: bool | None = None
                """Only applicable if `source_protocol` is `isis`."""
                rcf: str | None = None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                Only applicable if `source_protocol` is `isis`.
                """
                ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]] | None = None
                """
                Routes learned by the OSPF protocol.
                The `ospf_route_type` is valid for source_protocols 'ospf' and
                'ospfv3'.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    source_protocol: str = None,
                    route_map: str | None = None,
                    include_leaked: bool | None = None,
                    rcf: str | None = None,
                    ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]] | None = None,
                ) -> None:
                    """
                    RedistributeRoutesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_protocol: source_protocol
                        route_map: route_map
                        include_leaked: Only applicable if `source_protocol` is `isis`.
                        rcf:
                           RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                           `route_map` and `rcf` are mutually
                           exclusive. `route_map` takes precedence.
                           Only applicable if `source_protocol` is `isis`.
                        ospf_route_type:
                           Routes learned by the OSPF protocol.
                           The `ospf_route_type` is valid for source_protocols 'ospf' and
                           'ospfv3'.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "bgp", "peer_groups", "neighbors", "redistribute", "redistribute_routes")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            bgp: Bgp | None = None
            peer_groups: list[PeerGroupsItem] | None = None
            neighbors: list[NeighborsItem] | None = None
            redistribute: Redistribute | None = None
            """Redistribute routes in to BGP."""
            redistribute_routes: list[RedistributeRoutesItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                bgp: Bgp | None = None,
                peer_groups: list[PeerGroupsItem] | None = None,
                neighbors: list[NeighborsItem] | None = None,
                redistribute: Redistribute | None = None,
                redistribute_routes: list[RedistributeRoutesItem] | None = None,
            ) -> None:
                """
                AddressFamilyIpv4Multicast.

                Args:
                -----
                    _custom_data: _custom_data
                    bgp: bgp
                    peer_groups: peer_groups
                    neighbors: neighbors
                    redistribute: Redistribute routes in to BGP.
                    redistribute_routes: redistribute_routes

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyIpv4SrTe(AvdBase):
            class NeighborsItem(AvdBase):
                _fields = ("_custom_data", "ip_address", "activate", "route_map_in", "route_map_out")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ip_address: str = None
                activate: bool | None = None
                route_map_in: str | None = None
                """Inbound route-map name."""
                route_map_out: str | None = None
                """Outbound route-map name."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    ip_address: str = None,
                    activate: bool | None = None,
                    route_map_in: str | None = None,
                    route_map_out: str | None = None,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroupsItem(AvdBase):
                _fields = ("_custom_data", "name", "activate", "route_map_in", "route_map_out")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Peer-group name."""
                activate: bool | None = None
                route_map_in: str | None = None
                """Inbound route-map name."""
                route_map_out: str | None = None
                """Outbound route-map name."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    activate: bool | None = None,
                    route_map_in: str | None = None,
                    route_map_out: str | None = None,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "neighbors", "peer_groups")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            neighbors: list[NeighborsItem] | None = None
            peer_groups: list[PeerGroupsItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                neighbors: list[NeighborsItem] | None = None,
                peer_groups: list[PeerGroupsItem] | None = None,
            ) -> None:
                """
                AddressFamilyIpv4SrTe.

                Args:
                -----
                    _custom_data: _custom_data
                    neighbors: neighbors
                    peer_groups: peer_groups

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyIpv6(AvdBase):
            class NetworksItem(AvdBase):
                _fields = ("_custom_data", "prefix", "route_map")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                prefix: str = None
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                route_map: str | None = None
                """Route-map name."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, prefix: str = None, route_map: str | None = None) -> None:
                    """
                    NetworksItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                        route_map: Route-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Bgp(AvdBase):
                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "install", "install_ecmp_primary", "receive", "send", "send_limit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    install: bool | None = None
                    """Install BGP backup path."""
                    install_ecmp_primary: bool | None = None
                    """Allow additional path with ECMP primary path."""
                    receive: bool | None = None
                    """Enable or disable reception of additional-paths."""
                    send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: Annotated[int, Min[2], Max[64]] | None = None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        install: bool | None = None,
                        install_ecmp_primary: bool | None = None,
                        receive: bool | None = None,
                        send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                        send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            install: Install BGP backup path.
                            install_ecmp_primary: Allow additional path with ECMP primary path.
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "redistribute_internal", "additional_paths")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                redistribute_internal: bool | None = None
                """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""
                additional_paths: AdditionalPaths | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    redistribute_internal: bool | None = None,
                    additional_paths: AdditionalPaths | None = None,
                ) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroupsItem(AvdBase):
                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "prefix_list", "receive", "send", "send_limit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    prefix_list: str | None = None
                    """Apply the configurations only to the routes matching the prefix list."""
                    receive: bool | None = None
                    """Enable or disable reception of additional-paths."""
                    send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: Annotated[int, Min[2], Max[64]] | None = None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        prefix_list: str | None = None,
                        receive: bool | None = None,
                        send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                        send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            prefix_list: Apply the configurations only to the routes matching the prefix list.
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = (
                    "_custom_data",
                    "name",
                    "activate",
                    "route_map_in",
                    "route_map_out",
                    "rcf_in",
                    "rcf_out",
                    "prefix_list_in",
                    "prefix_list_out",
                    "additional_paths",
                )
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Peer-group name."""
                activate: bool | None = None
                route_map_in: str | None = None
                """Inbound route-map name."""
                route_map_out: str | None = None
                """Outbound route-map name."""
                rcf_in: str | None = None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None = None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                prefix_list_in: str | None = None
                """Inbound prefix-list name."""
                prefix_list_out: str | None = None
                """Outbound prefix-list name."""
                additional_paths: AdditionalPaths | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    activate: bool | None = None,
                    route_map_in: str | None = None,
                    route_map_out: str | None = None,
                    rcf_in: str | None = None,
                    rcf_out: str | None = None,
                    prefix_list_in: str | None = None,
                    prefix_list_out: str | None = None,
                    additional_paths: AdditionalPaths | None = None,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        prefix_list_in: Inbound prefix-list name.
                        prefix_list_out: Outbound prefix-list name.
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborsItem(AvdBase):
                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "prefix_list", "receive", "send", "send_limit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    prefix_list: str | None = None
                    """Apply the configurations only to the routes matching the prefix list."""
                    receive: bool | None = None
                    """Enable or disable reception of additional-paths."""
                    send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: Annotated[int, Min[2], Max[64]] | None = None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        prefix_list: str | None = None,
                        receive: bool | None = None,
                        send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                        send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            prefix_list: Apply the configurations only to the routes matching the prefix list.
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = (
                    "_custom_data",
                    "ip_address",
                    "activate",
                    "route_map_in",
                    "route_map_out",
                    "rcf_in",
                    "rcf_out",
                    "prefix_list_in",
                    "prefix_list_out",
                    "additional_paths",
                )
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ip_address: str = None
                activate: bool | None = None
                route_map_in: str | None = None
                """Inbound route-map name."""
                route_map_out: str | None = None
                """Outbound route-map name."""
                rcf_in: str | None = None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None = None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                prefix_list_in: str | None = None
                """Inbound prefix-list name."""
                prefix_list_out: str | None = None
                """Outbound prefix-list name."""
                additional_paths: AdditionalPaths | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    ip_address: str = None,
                    activate: bool | None = None,
                    route_map_in: str | None = None,
                    route_map_out: str | None = None,
                    rcf_in: str | None = None,
                    rcf_out: str | None = None,
                    prefix_list_in: str | None = None,
                    prefix_list_out: str | None = None,
                    additional_paths: AdditionalPaths | None = None,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        prefix_list_in: Inbound prefix-list name.
                        prefix_list_out: Outbound prefix-list name.
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Redistribute(AvdBase):
                class AttachedHost(AvdBase):
                    _fields = ("_custom_data", "enabled", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    route_map: str | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, route_map: str | None = None) -> None:
                        """
                        AttachedHost.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Bgp(AvdBase):
                    _fields = ("_custom_data", "enabled", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    route_map: str | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, route_map: str | None = None) -> None:
                        """
                        Bgp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Connected(AvdBase):
                    _fields = ("_custom_data", "enabled", "route_map", "rcf", "include_leaked")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    route_map: str | None = None
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None = None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        enabled: bool = None,
                        route_map: str | None = None,
                        rcf: str | None = None,
                        include_leaked: bool | None = None,
                    ) -> None:
                        """
                        Connected.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Dhcp(AvdBase):
                    _fields = ("_custom_data", "enabled", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    route_map: str | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, route_map: str | None = None) -> None:
                        """
                        Dhcp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Dynamic(AvdBase):
                    _fields = ("_custom_data", "enabled", "route_map", "rcf")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    route_map: str | None = None
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, route_map: str | None = None, rcf: str | None = None
                    ) -> None:
                        """
                        Dynamic.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Isis(AvdBase):
                    _fields = ("_custom_data", "enabled", "isis_level", "route_map", "rcf", "include_leaked")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    isis_level: Annotated[str, ValidValues["level-1", "level-2", "level-1-2"]] | None = None
                    """Redistribute IS-IS route level."""
                    route_map: str | None = None
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None = None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        enabled: bool = None,
                        isis_level: Annotated[str, ValidValues["level-1", "level-2", "level-1-2"]] | None = None,
                        route_map: str | None = None,
                        rcf: str | None = None,
                        include_leaked: bool | None = None,
                    ) -> None:
                        """
                        Isis.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            isis_level: Redistribute IS-IS route level.
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Ospfv3(AvdBase):
                    class MatchExternal(AvdBase):
                        _fields = ("_custom_data", "enabled", "route_map", "include_leaked")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        enabled: bool = None
                        route_map: str | None = None
                        include_leaked: bool | None = None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            enabled: bool = None,
                            route_map: str | None = None,
                            include_leaked: bool | None = None,
                        ) -> None:
                            """
                            MatchExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchInternal(AvdBase):
                        _fields = ("_custom_data", "enabled", "route_map", "include_leaked")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        enabled: bool = None
                        route_map: str | None = None
                        include_leaked: bool | None = None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            enabled: bool = None,
                            route_map: str | None = None,
                            include_leaked: bool | None = None,
                        ) -> None:
                            """
                            MatchInternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchNssaExternal(AvdBase):
                        _fields = ("_custom_data", "enabled", "nssa_type", "route_map", "include_leaked")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        enabled: bool = None
                        nssa_type: Annotated[int, ValidValues[1, 2]] | None = None
                        """NSSA External Type Number."""
                        route_map: str | None = None
                        include_leaked: bool | None = None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            enabled: bool = None,
                            nssa_type: Annotated[int, ValidValues[1, 2]] | None = None,
                            route_map: str | None = None,
                            include_leaked: bool | None = None,
                        ) -> None:
                            """
                            MatchNssaExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                nssa_type: NSSA External Type Number.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "enabled", "match_external", "match_internal", "match_nssa_external", "route_map", "include_leaked")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None
                    """Redistribute OSPFv3 routes."""
                    match_external: MatchExternal | None = None
                    """Redistribute OSPFv3 routes learned from external sources."""
                    match_internal: MatchInternal | None = None
                    """Redistribute OSPFv3 routes learned from internal sources."""
                    match_nssa_external: MatchNssaExternal | None = None
                    """Redistribute OSPFv3 routes learned from external NSSA sources."""
                    route_map: str | None = None
                    include_leaked: bool | None = None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        enabled: bool | None = None,
                        match_external: MatchExternal | None = None,
                        match_internal: MatchInternal | None = None,
                        match_nssa_external: MatchNssaExternal | None = None,
                        route_map: str | None = None,
                        include_leaked: bool | None = None,
                    ) -> None:
                        """
                        Ospfv3.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: Redistribute OSPFv3 routes.
                            match_external: Redistribute OSPFv3 routes learned from external sources.
                            match_internal: Redistribute OSPFv3 routes learned from internal sources.
                            match_nssa_external: Redistribute OSPFv3 routes learned from external NSSA sources.
                            route_map: route_map
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Static(AvdBase):
                    _fields = ("_custom_data", "enabled", "route_map", "rcf", "include_leaked")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    route_map: str | None = None
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None = None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        enabled: bool = None,
                        route_map: str | None = None,
                        rcf: str | None = None,
                        include_leaked: bool | None = None,
                    ) -> None:
                        """
                        Static.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class User(AvdBase):
                    _fields = ("_custom_data", "enabled", "rcf")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, rcf: str | None = None) -> None:
                        """
                        User.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "attached_host", "bgp", "connected", "dhcp", "dynamic", "isis", "ospfv3", "static", "user")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                attached_host: AttachedHost | None = None
                bgp: Bgp | None = None
                connected: Connected | None = None
                dhcp: Dhcp | None = None
                dynamic: Dynamic | None = None
                isis: Isis | None = None
                ospfv3: Ospfv3 | None = None
                static: Static | None = None
                user: User | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    attached_host: AttachedHost | None = None,
                    bgp: Bgp | None = None,
                    connected: Connected | None = None,
                    dhcp: Dhcp | None = None,
                    dynamic: Dynamic | None = None,
                    isis: Isis | None = None,
                    ospfv3: Ospfv3 | None = None,
                    static: Static | None = None,
                    user: User | None = None,
                ) -> None:
                    """
                    Redistribute.

                    Args:
                    -----
                        _custom_data: _custom_data
                        attached_host: attached_host
                        bgp: bgp
                        connected: connected
                        dhcp: dhcp
                        dynamic: dynamic
                        isis: isis
                        ospfv3: ospfv3
                        static: static
                        user: user

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RedistributeRoutesItem(AvdBase):
                _fields = ("_custom_data", "source_protocol", "route_map", "include_leaked", "rcf", "ospf_route_type")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                source_protocol: str = None
                route_map: str | None = None
                include_leaked: bool | None = None
                rcf: str | None = None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                Only used if `source_protocol` is one of `connected`,
                `static`, `isis`, `user`, `dynamic`.
                """
                ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]] | None = None
                """
                Routes learned by the OSPF protocol.
                The `ospf_route_type` is valid for source_protocols 'ospfv3'.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    source_protocol: str = None,
                    route_map: str | None = None,
                    include_leaked: bool | None = None,
                    rcf: str | None = None,
                    ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]] | None = None,
                ) -> None:
                    """
                    RedistributeRoutesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_protocol: source_protocol
                        route_map: route_map
                        include_leaked: include_leaked
                        rcf:
                           RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                           `route_map` and `rcf` are mutually
                           exclusive. `route_map` takes precedence.
                           Only used if `source_protocol` is one of `connected`,
                           `static`, `isis`, `user`, `dynamic`.
                        ospf_route_type:
                           Routes learned by the OSPF protocol.
                           The `ospf_route_type` is valid for source_protocols 'ospfv3'.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "networks", "bgp", "peer_groups", "neighbors", "redistribute", "redistribute_routes")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            networks: list[NetworksItem] | None = None
            bgp: Bgp | None = None
            peer_groups: list[PeerGroupsItem] | None = None
            neighbors: list[NeighborsItem] | None = None
            redistribute: Redistribute | None = None
            """Redistribute routes in to BGP."""
            redistribute_routes: list[RedistributeRoutesItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                networks: list[NetworksItem] | None = None,
                bgp: Bgp | None = None,
                peer_groups: list[PeerGroupsItem] | None = None,
                neighbors: list[NeighborsItem] | None = None,
                redistribute: Redistribute | None = None,
                redistribute_routes: list[RedistributeRoutesItem] | None = None,
            ) -> None:
                """
                AddressFamilyIpv6.

                Args:
                -----
                    _custom_data: _custom_data
                    networks: networks
                    bgp: bgp
                    peer_groups: peer_groups
                    neighbors: neighbors
                    redistribute: Redistribute routes in to BGP.
                    redistribute_routes: redistribute_routes

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyIpv6Multicast(AvdBase):
            class Bgp(AvdBase):
                class MissingPolicy(AvdBase):
                    _fields = ("_custom_data", "direction_in_action", "direction_out_action")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None
                    direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                        direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                    ) -> None:
                        """
                        MissingPolicy.

                        Args:
                        -----
                            _custom_data: _custom_data
                            direction_in_action: direction_in_action
                            direction_out_action: direction_out_action

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "receive")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    receive: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, receive: bool | None = None) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: receive

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "missing_policy", "additional_paths")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                missing_policy: MissingPolicy | None = None
                additional_paths: AdditionalPaths | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    missing_policy: MissingPolicy | None = None,
                    additional_paths: AdditionalPaths | None = None,
                ) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        missing_policy: missing_policy
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborsItem(AvdBase):
                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "receive")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    receive: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, receive: bool | None = None) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: receive

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "ip_address", "activate", "route_map_in", "route_map_out", "additional_paths")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ip_address: str = None
                activate: bool | None = None
                route_map_in: str | None = None
                """Inbound route-map name."""
                route_map_out: str | None = None
                """Outbound route-map name."""
                additional_paths: AdditionalPaths | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    ip_address: str = None,
                    activate: bool | None = None,
                    route_map_in: str | None = None,
                    route_map_out: str | None = None,
                    additional_paths: AdditionalPaths | None = None,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroupsItem(AvdBase):
                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "receive")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    receive: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, receive: bool | None = None) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: receive

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "name", "activate", "additional_paths")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Peer-group name."""
                activate: bool | None = None
                additional_paths: AdditionalPaths | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    activate: bool | None = None,
                    additional_paths: AdditionalPaths | None = None,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NetworksItem(AvdBase):
                _fields = ("_custom_data", "prefix", "route_map")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                prefix: str = None
                """IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                route_map: str | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, prefix: str = None, route_map: str | None = None) -> None:
                    """
                    NetworksItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefix: IPv6 prefix "A:B:C:D:E:F:G:H/I".
                        route_map: route_map

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RedistributeRoutesItem(AvdBase):
                _fields = ("_custom_data", "source_protocol", "include_leaked", "route_map", "rcf", "ospf_route_type")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                source_protocol: Annotated[str, ValidValues["connected", "isis", "ospf", "ospfv3", "static"]] = None
                include_leaked: bool | None = None
                """Only applicable if `source_protocol` is `isis`."""
                route_map: str | None = None
                rcf: str | None = None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                Only applicable if `source_protocol` is `isis`.
                """
                ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]] | None = None
                """
                Routes learned by the OSPF protocol.
                The `ospf_route_type` is valid for source_protocols 'ospf' and
                'ospfv3'.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    source_protocol: Annotated[str, ValidValues["connected", "isis", "ospf", "ospfv3", "static"]] = None,
                    include_leaked: bool | None = None,
                    route_map: str | None = None,
                    rcf: str | None = None,
                    ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]] | None = None,
                ) -> None:
                    """
                    RedistributeRoutesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_protocol: source_protocol
                        include_leaked: Only applicable if `source_protocol` is `isis`.
                        route_map: route_map
                        rcf:
                           RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                           `route_map` and `rcf` are mutually
                           exclusive. `route_map` takes precedence.
                           Only applicable if `source_protocol` is `isis`.
                        ospf_route_type:
                           Routes learned by the OSPF protocol.
                           The `ospf_route_type` is valid for source_protocols 'ospf' and
                           'ospfv3'.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "bgp", "neighbors", "peer_groups", "networks", "redistribute_routes")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            bgp: Bgp | None = None
            neighbors: list[NeighborsItem] | None = None
            peer_groups: list[PeerGroupsItem] | None = None
            networks: list[NetworksItem] | None = None
            redistribute_routes: list[RedistributeRoutesItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                bgp: Bgp | None = None,
                neighbors: list[NeighborsItem] | None = None,
                peer_groups: list[PeerGroupsItem] | None = None,
                networks: list[NetworksItem] | None = None,
                redistribute_routes: list[RedistributeRoutesItem] | None = None,
            ) -> None:
                """
                AddressFamilyIpv6Multicast.

                Args:
                -----
                    _custom_data: _custom_data
                    bgp: bgp
                    neighbors: neighbors
                    peer_groups: peer_groups
                    networks: networks
                    redistribute_routes: redistribute_routes

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyIpv6SrTe(AvdBase):
            class NeighborsItem(AvdBase):
                _fields = ("_custom_data", "ip_address", "activate", "route_map_in", "route_map_out")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ip_address: str = None
                activate: bool | None = None
                route_map_in: str | None = None
                """Inbound route-map name."""
                route_map_out: str | None = None
                """Outbound route-map name."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    ip_address: str = None,
                    activate: bool | None = None,
                    route_map_in: str | None = None,
                    route_map_out: str | None = None,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroupsItem(AvdBase):
                _fields = ("_custom_data", "name", "activate", "route_map_in", "route_map_out")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Peer-group name."""
                activate: bool | None = None
                route_map_in: str | None = None
                """Inbound route-map name."""
                route_map_out: str | None = None
                """Outbound route-map name."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    activate: bool | None = None,
                    route_map_in: str | None = None,
                    route_map_out: str | None = None,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "neighbors", "peer_groups")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            neighbors: list[NeighborsItem] | None = None
            peer_groups: list[PeerGroupsItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                neighbors: list[NeighborsItem] | None = None,
                peer_groups: list[PeerGroupsItem] | None = None,
            ) -> None:
                """
                AddressFamilyIpv6SrTe.

                Args:
                -----
                    _custom_data: _custom_data
                    neighbors: neighbors
                    peer_groups: peer_groups

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyLinkState(AvdBase):
            class Bgp(AvdBase):
                class MissingPolicy(AvdBase):
                    _fields = ("_custom_data", "direction_in_action", "direction_out_action")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None
                    direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                        direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                    ) -> None:
                        """
                        MissingPolicy.

                        Args:
                        -----
                            _custom_data: _custom_data
                            direction_in_action: direction_in_action
                            direction_out_action: direction_out_action

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "missing_policy")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                missing_policy: MissingPolicy | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, missing_policy: MissingPolicy | None = None) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        missing_policy: missing_policy

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroupsItem(AvdBase):
                class MissingPolicy(AvdBase):
                    _fields = ("_custom_data", "direction_in_action", "direction_out_action")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None
                    direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                        direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                    ) -> None:
                        """
                        MissingPolicy.

                        Args:
                        -----
                            _custom_data: _custom_data
                            direction_in_action: direction_in_action
                            direction_out_action: direction_out_action

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "name", "activate", "missing_policy")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Peer-group name."""
                activate: bool | None = None
                missing_policy: MissingPolicy | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    activate: bool | None = None,
                    missing_policy: MissingPolicy | None = None,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        missing_policy: missing_policy

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborsItem(AvdBase):
                class MissingPolicy(AvdBase):
                    _fields = ("_custom_data", "direction_in_action", "direction_out_action")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None
                    direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                        direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                    ) -> None:
                        """
                        MissingPolicy.

                        Args:
                        -----
                            _custom_data: _custom_data
                            direction_in_action: direction_in_action
                            direction_out_action: direction_out_action

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "ip_address", "activate", "missing_policy")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ip_address: str = None
                activate: bool | None = None
                missing_policy: MissingPolicy | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    ip_address: str = None,
                    activate: bool | None = None,
                    missing_policy: MissingPolicy | None = None,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        missing_policy: missing_policy

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PathSelection(AvdBase):
                class Roles(AvdBase):
                    _fields = ("_custom_data", "producer", "consumer", "propagator")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    producer: bool | None = None
                    consumer: bool | None = None
                    propagator: bool | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        producer: bool | None = None,
                        consumer: bool | None = None,
                        propagator: bool | None = None,
                    ) -> None:
                        """
                        Roles.

                        Args:
                        -----
                            _custom_data: _custom_data
                            producer: producer
                            consumer: consumer
                            propagator: propagator

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "roles")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                roles: Roles | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, roles: Roles | None = None) -> None:
                    """
                    PathSelection.

                    Args:
                    -----
                        _custom_data: _custom_data
                        roles: roles

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "bgp", "peer_groups", "neighbors", "path_selection")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            bgp: Bgp | None = None
            peer_groups: list[PeerGroupsItem] | None = None
            neighbors: list[NeighborsItem] | None = None
            path_selection: PathSelection | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                bgp: Bgp | None = None,
                peer_groups: list[PeerGroupsItem] | None = None,
                neighbors: list[NeighborsItem] | None = None,
                path_selection: PathSelection | None = None,
            ) -> None:
                """
                AddressFamilyLinkState.

                Args:
                -----
                    _custom_data: _custom_data
                    bgp: bgp
                    peer_groups: peer_groups
                    neighbors: neighbors
                    path_selection: path_selection

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyFlowSpecIpv4(AvdBase):
            class Bgp(AvdBase):
                class MissingPolicy(AvdBase):
                    _fields = ("_custom_data", "direction_in_action", "direction_out_action")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None
                    direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                        direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                    ) -> None:
                        """
                        MissingPolicy.

                        Args:
                        -----
                            _custom_data: _custom_data
                            direction_in_action: direction_in_action
                            direction_out_action: direction_out_action

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "missing_policy")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                missing_policy: MissingPolicy | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, missing_policy: MissingPolicy | None = None) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        missing_policy: missing_policy

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborsItem(AvdBase):
                _fields = ("_custom_data", "ip_address", "activate")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ip_address: str = None
                activate: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, ip_address: str = None, activate: bool | None = None) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroupsItem(AvdBase):
                _fields = ("_custom_data", "name", "activate")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Peer-group name."""
                activate: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, activate: bool | None = None) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "bgp", "neighbors", "peer_groups")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            bgp: Bgp | None = None
            neighbors: list[NeighborsItem] | None = None
            peer_groups: list[PeerGroupsItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                bgp: Bgp | None = None,
                neighbors: list[NeighborsItem] | None = None,
                peer_groups: list[PeerGroupsItem] | None = None,
            ) -> None:
                """
                AddressFamilyFlowSpecIpv4.

                Args:
                -----
                    _custom_data: _custom_data
                    bgp: bgp
                    neighbors: neighbors
                    peer_groups: peer_groups

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyFlowSpecIpv6(AvdBase):
            class Bgp(AvdBase):
                class MissingPolicy(AvdBase):
                    _fields = ("_custom_data", "direction_in_action", "direction_out_action")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None
                    direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                        direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                    ) -> None:
                        """
                        MissingPolicy.

                        Args:
                        -----
                            _custom_data: _custom_data
                            direction_in_action: direction_in_action
                            direction_out_action: direction_out_action

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "missing_policy")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                missing_policy: MissingPolicy | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, missing_policy: MissingPolicy | None = None) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        missing_policy: missing_policy

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborsItem(AvdBase):
                _fields = ("_custom_data", "ip_address", "activate")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ip_address: str = None
                activate: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, ip_address: str = None, activate: bool | None = None) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroupsItem(AvdBase):
                _fields = ("_custom_data", "name", "activate")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Peer-group name."""
                activate: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, activate: bool | None = None) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "bgp", "neighbors", "peer_groups")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            bgp: Bgp | None = None
            neighbors: list[NeighborsItem] | None = None
            peer_groups: list[PeerGroupsItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                bgp: Bgp | None = None,
                neighbors: list[NeighborsItem] | None = None,
                peer_groups: list[PeerGroupsItem] | None = None,
            ) -> None:
                """
                AddressFamilyFlowSpecIpv6.

                Args:
                -----
                    _custom_data: _custom_data
                    bgp: bgp
                    neighbors: neighbors
                    peer_groups: peer_groups

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyPathSelection(AvdBase):
            class Bgp(AvdBase):
                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "receive", "send", "send_limit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    receive: bool | None = None
                    """Enable or disable reception of additional-paths."""
                    send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: Annotated[int, Min[2], Max[64]] | None = None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        receive: bool | None = None,
                        send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                        send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "additional_paths")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                additional_paths: AdditionalPaths | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, additional_paths: AdditionalPaths | None = None) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborsItem(AvdBase):
                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "receive", "send", "send_limit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    receive: bool | None = None
                    """Enable or disable reception of additional-paths."""
                    send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: Annotated[int, Min[2], Max[64]] | None = None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        receive: bool | None = None,
                        send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                        send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "ip_address", "activate", "additional_paths")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ip_address: str = None
                activate: bool | None = None
                additional_paths: AdditionalPaths | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    ip_address: str = None,
                    activate: bool | None = None,
                    additional_paths: AdditionalPaths | None = None,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroupsItem(AvdBase):
                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "receive", "send", "send_limit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    receive: bool | None = None
                    """Enable or disable reception of additional-paths."""
                    send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: Annotated[int, Min[2], Max[64]] | None = None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        receive: bool | None = None,
                        send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                        send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "name", "activate", "additional_paths")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Peer-group name."""
                activate: bool | None = None
                additional_paths: AdditionalPaths | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    activate: bool | None = None,
                    additional_paths: AdditionalPaths | None = None,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "bgp", "neighbors", "peer_groups")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            bgp: Bgp | None = None
            neighbors: list[NeighborsItem] | None = None
            peer_groups: list[PeerGroupsItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                bgp: Bgp | None = None,
                neighbors: list[NeighborsItem] | None = None,
                peer_groups: list[PeerGroupsItem] | None = None,
            ) -> None:
                """
                AddressFamilyPathSelection.

                Args:
                -----
                    _custom_data: _custom_data
                    bgp: bgp
                    neighbors: neighbors
                    peer_groups: peer_groups

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyVpnIpv4(AvdBase):
            class PeerGroupsItem(AvdBase):
                class DefaultRoute(AvdBase):
                    _fields = ("_custom_data", "enabled", "rcf", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None = None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, rcf: str | None = None, route_map: str | None = None
                    ) -> None:
                        """
                        DefaultRoute.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "name", "activate", "route_map_in", "route_map_out", "rcf_in", "rcf_out", "default_route")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Peer-group name."""
                activate: bool | None = None
                route_map_in: str | None = None
                """Inbound route-map name."""
                route_map_out: str | None = None
                """Outbound route-map name."""
                rcf_in: str | None = None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None = None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    activate: bool | None = None,
                    route_map_in: str | None = None,
                    route_map_out: str | None = None,
                    rcf_in: str | None = None,
                    rcf_out: str | None = None,
                    default_route: DefaultRoute | None = None,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        default_route: default_route

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Route(AvdBase):
                _fields = ("_custom_data", "import_match_failure_action")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                import_match_failure_action: Annotated[str, ValidValues["discard"]] | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, import_match_failure_action: Annotated[str, ValidValues["discard"]] | None = None
                ) -> None:
                    """
                    Route.

                    Args:
                    -----
                        _custom_data: _custom_data
                        import_match_failure_action: import_match_failure_action

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborsItem(AvdBase):
                class DefaultRoute(AvdBase):
                    _fields = ("_custom_data", "enabled", "rcf", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None = None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, rcf: str | None = None, route_map: str | None = None
                    ) -> None:
                        """
                        DefaultRoute.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "ip_address", "activate", "route_map_in", "route_map_out", "rcf_in", "rcf_out", "default_route")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ip_address: str = None
                activate: bool | None = None
                route_map_in: str | None = None
                """Inbound route-map name."""
                route_map_out: str | None = None
                """Outbound route-map name."""
                rcf_in: str | None = None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None = None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    ip_address: str = None,
                    activate: bool | None = None,
                    route_map_in: str | None = None,
                    route_map_out: str | None = None,
                    rcf_in: str | None = None,
                    rcf_out: str | None = None,
                    default_route: DefaultRoute | None = None,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        default_route: default_route

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborDefaultEncapsulationMplsNextHopSelf(AvdBase):
                _fields = ("_custom_data", "source_interface")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                source_interface: str | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, source_interface: str | None = None) -> None:
                    """
                    NeighborDefaultEncapsulationMplsNextHopSelf.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_interface: source_interface

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "domain_identifier", "peer_groups", "route", "neighbors", "neighbor_default_encapsulation_mpls_next_hop_self")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            domain_identifier: str | None = None
            peer_groups: list[PeerGroupsItem] | None = None
            route: Route | None = None
            neighbors: list[NeighborsItem] | None = None
            neighbor_default_encapsulation_mpls_next_hop_self: NeighborDefaultEncapsulationMplsNextHopSelf | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                domain_identifier: str | None = None,
                peer_groups: list[PeerGroupsItem] | None = None,
                route: Route | None = None,
                neighbors: list[NeighborsItem] | None = None,
                neighbor_default_encapsulation_mpls_next_hop_self: NeighborDefaultEncapsulationMplsNextHopSelf | None = None,
            ) -> None:
                """
                AddressFamilyVpnIpv4.

                Args:
                -----
                    _custom_data: _custom_data
                    domain_identifier: domain_identifier
                    peer_groups: peer_groups
                    route: route
                    neighbors: neighbors
                    neighbor_default_encapsulation_mpls_next_hop_self: neighbor_default_encapsulation_mpls_next_hop_self

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyVpnIpv6(AvdBase):
            class PeerGroupsItem(AvdBase):
                class DefaultRoute(AvdBase):
                    _fields = ("_custom_data", "enabled", "rcf", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None = None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, rcf: str | None = None, route_map: str | None = None
                    ) -> None:
                        """
                        DefaultRoute.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "name", "activate", "route_map_in", "route_map_out", "rcf_in", "rcf_out", "default_route")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Peer-group name."""
                activate: bool | None = None
                route_map_in: str | None = None
                """Inbound route-map name."""
                route_map_out: str | None = None
                """Outbound route-map name."""
                rcf_in: str | None = None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None = None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    activate: bool | None = None,
                    route_map_in: str | None = None,
                    route_map_out: str | None = None,
                    rcf_in: str | None = None,
                    rcf_out: str | None = None,
                    default_route: DefaultRoute | None = None,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        default_route: default_route

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Route(AvdBase):
                _fields = ("_custom_data", "import_match_failure_action")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                import_match_failure_action: Annotated[str, ValidValues["discard"]] | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, import_match_failure_action: Annotated[str, ValidValues["discard"]] | None = None
                ) -> None:
                    """
                    Route.

                    Args:
                    -----
                        _custom_data: _custom_data
                        import_match_failure_action: import_match_failure_action

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborsItem(AvdBase):
                class DefaultRoute(AvdBase):
                    _fields = ("_custom_data", "enabled", "rcf", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None = None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, rcf: str | None = None, route_map: str | None = None
                    ) -> None:
                        """
                        DefaultRoute.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "ip_address", "activate", "route_map_in", "route_map_out", "rcf_in", "rcf_out", "default_route")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ip_address: str = None
                activate: bool | None = None
                route_map_in: str | None = None
                """Inbound route-map name."""
                route_map_out: str | None = None
                """Outbound route-map name."""
                rcf_in: str | None = None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None = None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    ip_address: str = None,
                    activate: bool | None = None,
                    route_map_in: str | None = None,
                    route_map_out: str | None = None,
                    rcf_in: str | None = None,
                    rcf_out: str | None = None,
                    default_route: DefaultRoute | None = None,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        default_route: default_route

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborDefaultEncapsulationMplsNextHopSelf(AvdBase):
                _fields = ("_custom_data", "source_interface")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                source_interface: str | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, source_interface: str | None = None) -> None:
                    """
                    NeighborDefaultEncapsulationMplsNextHopSelf.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_interface: source_interface

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "domain_identifier", "peer_groups", "route", "neighbors", "neighbor_default_encapsulation_mpls_next_hop_self")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            domain_identifier: str | None = None
            peer_groups: list[PeerGroupsItem] | None = None
            route: Route | None = None
            neighbors: list[NeighborsItem] | None = None
            neighbor_default_encapsulation_mpls_next_hop_self: NeighborDefaultEncapsulationMplsNextHopSelf | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                domain_identifier: str | None = None,
                peer_groups: list[PeerGroupsItem] | None = None,
                route: Route | None = None,
                neighbors: list[NeighborsItem] | None = None,
                neighbor_default_encapsulation_mpls_next_hop_self: NeighborDefaultEncapsulationMplsNextHopSelf | None = None,
            ) -> None:
                """
                AddressFamilyVpnIpv6.

                Args:
                -----
                    _custom_data: _custom_data
                    domain_identifier: domain_identifier
                    peer_groups: peer_groups
                    route: route
                    neighbors: neighbors
                    neighbor_default_encapsulation_mpls_next_hop_self: neighbor_default_encapsulation_mpls_next_hop_self

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrfsItem(AvdBase):
            class Bgp(AvdBase):
                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "install", "install_ecmp_primary", "receive", "send", "send_limit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    install: bool | None = None
                    """Install BGP backup path."""
                    install_ecmp_primary: bool | None = None
                    """Allow additional path with ECMP primary path."""
                    receive: bool | None = None
                    """Enable or disable reception of additional-paths."""
                    send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: Annotated[int, Min[2], Max[64]] | None = None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        install: bool | None = None,
                        install_ecmp_primary: bool | None = None,
                        receive: bool | None = None,
                        send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                        send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            install: Install BGP backup path.
                            install_ecmp_primary: Allow additional path with ECMP primary path.
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "redistribute_internal", "additional_paths")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                redistribute_internal: bool | None = None
                """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""
                additional_paths: AdditionalPaths | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    redistribute_internal: bool | None = None,
                    additional_paths: AdditionalPaths | None = None,
                ) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class EvpnMulticastAddressFamily(AvdBase):
                class Ipv4(AvdBase):
                    _fields = ("_custom_data", "transit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    transit: bool | None = None
                    """Enable EVPN multicast transit mode."""

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, transit: bool | None = None) -> None:
                        """
                        Ipv4.

                        Args:
                        -----
                            _custom_data: _custom_data
                            transit: Enable EVPN multicast transit mode.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "ipv4")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ipv4: Ipv4 | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, ipv4: Ipv4 | None = None) -> None:
                    """
                    EvpnMulticastAddressFamily.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ipv4: ipv4

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class EvpnMulticastGatewayDrElection(AvdBase):
                _fields = ("_custom_data", "algorithm", "preference_value")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                algorithm: Annotated[str, ValidValues["hrw", "modulus", "preference"]] = None
                """
                DR election algorithms:
                  hrw: Default selection based on highest random weight.
                  modulus:
                Selection based on VLAN ID modulo number of candidates.
                  preference: Selection based on a
                configured preference value.
                """
                preference_value: Annotated[int, Max[65535]] | None = None
                """Required when `algorithm` is `preference`."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    algorithm: Annotated[str, ValidValues["hrw", "modulus", "preference"]] = None,
                    preference_value: Annotated[int, Max[65535]] | None = None,
                ) -> None:
                    """
                    EvpnMulticastGatewayDrElection.

                    Args:
                    -----
                        _custom_data: _custom_data
                        algorithm:
                           DR election algorithms:
                             hrw: Default selection based on highest random weight.
                             modulus:
                           Selection based on VLAN ID modulo number of candidates.
                             preference: Selection based on a
                           configured preference value.
                        preference_value: Required when `algorithm` is `preference`.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class DefaultRouteExportsItem(AvdBase):
                _fields = ("_custom_data", "address_family", "always", "route_map", "rcf")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                address_family: Annotated[str, ValidValues["evpn", "vpn-ipv4", "vpn-ipv6"]] = None
                always: bool | None = None
                route_map: str | None = None
                rcf: str | None = None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    address_family: Annotated[str, ValidValues["evpn", "vpn-ipv4", "vpn-ipv6"]] = None,
                    always: bool | None = None,
                    route_map: str | None = None,
                    rcf: str | None = None,
                ) -> None:
                    """
                    DefaultRouteExportsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        address_family: address_family
                        always: always
                        route_map: route_map
                        rcf:
                           RCF function name with parenthesis.
                           Example: MyFunction(myarg).

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RouteTargets(AvdBase):
                class ImportItem(AvdBase):
                    _fields = ("_custom_data", "address_family", "route_targets", "route_map", "rcf", "vpn_route_filter_rcf")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    address_family: str = None
                    route_targets: list[str] | None = None
                    route_map: str | None = None
                    """Only applicable if `address_family` is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`."""
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    Only applicable if `address_family`
                    is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                    """
                    vpn_route_filter_rcf: str | None = None
                    """
                    RCF function name with parenthesis for filtering VPN routes. Also requires `rcf` to be set.
                    Example:
                    MyFunction(myarg).
                    Only applicable if `address_family` is one of `vpn-ipv4` or `vpn-ipv6`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        address_family: str = None,
                        route_targets: list[str] | None = None,
                        route_map: str | None = None,
                        rcf: str | None = None,
                        vpn_route_filter_rcf: str | None = None,
                    ) -> None:
                        """
                        ImportItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            address_family: address_family
                            route_targets: route_targets
                            route_map: Only applicable if `address_family` is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               Only applicable if `address_family`
                               is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                            vpn_route_filter_rcf:
                               RCF function name with parenthesis for filtering VPN routes. Also requires `rcf` to be set.

                        Example:
                               MyFunction(myarg).
                               Only applicable if `address_family` is one of `vpn-ipv4` or `vpn-ipv6`.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class ExportItem(AvdBase):
                    _fields = ("_custom_data", "address_family", "route_targets", "route_map", "rcf", "vpn_route_filter_rcf")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    address_family: str = None
                    route_targets: list[str] | None = None
                    route_map: str | None = None
                    """Only applicable if `address_family` is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`."""
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    Only applicable if `address_family`
                    is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                    """
                    vpn_route_filter_rcf: str | None = None
                    """
                    RCF function name with parenthesis for filtering VPN routes. Also requires `rcf` to be set.
                    Example:
                    MyFunction(myarg).
                    Only applicable if `address_family` is one of `vpn-ipv4` or `vpn-ipv6`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        address_family: str = None,
                        route_targets: list[str] | None = None,
                        route_map: str | None = None,
                        rcf: str | None = None,
                        vpn_route_filter_rcf: str | None = None,
                    ) -> None:
                        """
                        ExportItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            address_family: address_family
                            route_targets: route_targets
                            route_map: Only applicable if `address_family` is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               Only applicable if `address_family`
                               is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                            vpn_route_filter_rcf:
                               RCF function name with parenthesis for filtering VPN routes. Also requires `rcf` to be set.

                        Example:
                               MyFunction(myarg).
                               Only applicable if `address_family` is one of `vpn-ipv4` or `vpn-ipv6`.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "field_import", "export")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                field_import: list[ImportItem] | None = None
                export: list[ExportItem] | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, field_import: list[ImportItem] | None = None, export: list[ExportItem] | None = None
                ) -> None:
                    """
                    RouteTargets.

                    Args:
                    -----
                        _custom_data: _custom_data
                        field_import: field_import
                        export: export

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NetworksItem(AvdBase):
                _fields = ("_custom_data", "prefix", "route_map")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                prefix: str = None
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                route_map: str | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, prefix: str = None, route_map: str | None = None) -> None:
                    """
                    NetworksItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                        route_map: route_map

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Updates(AvdBase):
                _fields = ("_custom_data", "wait_for_convergence", "wait_install")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                wait_for_convergence: bool | None = None
                """
                Disables FIB updates and route advertisement when the BGP instance is initiated until the BGP
                convergence state is reached.
                """
                wait_install: bool | None = None
                """
                Do not advertise reachability to a prefix until that prefix has been installed in hardware.
                This
                will eliminate any temporary black holes due to a BGP speaker advertising reachability to a prefix
                that may not yet be installed into the forwarding plane.
                """

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, wait_for_convergence: bool | None = None, wait_install: bool | None = None
                ) -> None:
                    """
                    Updates.

                    Args:
                    -----
                        _custom_data: _custom_data
                        wait_for_convergence:
                           Disables FIB updates and route advertisement when the BGP instance is initiated until the BGP
                           convergence state is reached.
                        wait_install:
                           Do not advertise reachability to a prefix until that prefix has been installed in hardware.
                           This
                           will eliminate any temporary black holes due to a BGP speaker advertising reachability to a prefix
                           that may not yet be installed into the forwarding plane.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class ListenRangesItem(AvdBase):
                _fields = ("_custom_data", "prefix", "peer_id_include_router_id", "peer_group", "peer_filter", "remote_as")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                prefix: str | None = None
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                peer_id_include_router_id: bool | None = None
                """Include router ID as part of peer filter."""
                peer_group: str | None = None
                """Peer-group name."""
                peer_filter: str | None = None
                """
                Peer-filter name.
                note: `peer_filter`` or `remote_as` is required but mutually exclusive.
                If both
                are defined, peer_filter takes precedence.
                """
                remote_as: str | None = None
                """
                BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                For asdot notation in
                YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                number.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    prefix: str | None = None,
                    peer_id_include_router_id: bool | None = None,
                    peer_group: str | None = None,
                    peer_filter: str | None = None,
                    remote_as: str | None = None,
                ) -> None:
                    """
                    ListenRangesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                        peer_id_include_router_id: Include router ID as part of peer filter.
                        peer_group: Peer-group name.
                        peer_filter:
                           Peer-filter name.
                           note: `peer_filter`` or `remote_as` is required but mutually exclusive.
                           If both
                           are defined, peer_filter takes precedence.
                        remote_as:
                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                           For asdot notation in
                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                           number.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborsItem(AvdBase):
                class RemovePrivateAs(AvdBase):
                    _fields = ("_custom_data", "enabled", "all", "replace_as")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None
                    all: bool | None = None
                    replace_as: bool | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        enabled: bool | None = None,
                        all: bool | None = None,
                        replace_as: bool | None = None,
                    ) -> None:
                        """
                        RemovePrivateAs.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            all: all
                            replace_as: replace_as

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class RemovePrivateAsIngress(AvdBase):
                    _fields = ("_custom_data", "enabled", "replace_as")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None
                    replace_as: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, replace_as: bool | None = None) -> None:
                        """
                        RemovePrivateAsIngress.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            replace_as: replace_as

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class AsPath(AvdBase):
                    _fields = ("_custom_data", "remote_as_replace_out", "prepend_own_disabled")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    remote_as_replace_out: bool | None = None
                    """Replace AS number with local AS number."""
                    prepend_own_disabled: bool | None = None
                    """Disable prepending own AS number to AS path."""

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, remote_as_replace_out: bool | None = None, prepend_own_disabled: bool | None = None
                    ) -> None:
                        """
                        AsPath.

                        Args:
                        -----
                            _custom_data: _custom_data
                            remote_as_replace_out: Replace AS number with local AS number.
                            prepend_own_disabled: Disable prepending own AS number to AS path.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class BfdTimers(AvdBase):
                    _fields = ("_custom_data", "interval", "min_rx", "multiplier")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    interval: Annotated[int, Min[50], Max[60000]] = None
                    """Interval in milliseconds."""
                    min_rx: Annotated[int, Min[50], Max[60000]] = None
                    """Rate in milliseconds."""
                    multiplier: Annotated[int, Min[3], Max[50]] = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        interval: Annotated[int, Min[50], Max[60000]] = None,
                        min_rx: Annotated[int, Min[50], Max[60000]] = None,
                        multiplier: Annotated[int, Min[3], Max[50]] = None,
                    ) -> None:
                        """
                        BfdTimers.

                        Args:
                        -----
                            _custom_data: _custom_data
                            interval: Interval in milliseconds.
                            min_rx: Rate in milliseconds.
                            multiplier: multiplier

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class RibInPrePolicyRetain(AvdBase):
                    _fields = ("_custom_data", "enabled", "all")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None
                    all: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, all: bool | None = None) -> None:
                        """
                        RibInPrePolicyRetain.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            all: all

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class AllowasIn(AvdBase):
                    _fields = ("_custom_data", "enabled", "times")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None
                    times: Annotated[int, Min[1], Max[10]] | None = None
                    """Number of local ASNs allowed in a BGP update."""

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, times: Annotated[int, Min[1], Max[10]] | None = None
                    ) -> None:
                        """
                        AllowasIn.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            times: Number of local ASNs allowed in a BGP update.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class DefaultOriginate(AvdBase):
                    _fields = ("_custom_data", "enabled", "always", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None
                    always: bool | None = None
                    route_map: str | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        enabled: bool | None = None,
                        always: bool | None = None,
                        route_map: str | None = None,
                    ) -> None:
                        """
                        DefaultOriginate.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            always: always
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class AdditionalPaths(AvdBase):
                    _fields = ("_custom_data", "receive", "send", "send_limit")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    receive: bool | None = None
                    """Enable or disable reception of additional-paths."""
                    send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: Annotated[int, Min[2], Max[64]] | None = None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        receive: bool | None = None,
                        send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                        send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = (
                    "_custom_data",
                    "ip_address",
                    "peer_group",
                    "remote_as",
                    "password",
                    "passive",
                    "remove_private_as",
                    "remove_private_as_ingress",
                    "weight",
                    "local_as",
                    "as_path",
                    "description",
                    "route_reflector_client",
                    "ebgp_multihop",
                    "next_hop_self",
                    "shutdown",
                    "bfd",
                    "bfd_timers",
                    "timers",
                    "rib_in_pre_policy_retain",
                    "send_community",
                    "maximum_routes",
                    "maximum_routes_warning_limit",
                    "maximum_routes_warning_only",
                    "allowas_in",
                    "default_originate",
                    "update_source",
                    "route_map_in",
                    "route_map_out",
                    "additional_paths",
                )
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ip_address: str = None
                peer_group: str | None = None
                """Peer-group name."""
                remote_as: str | None = None
                """
                BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                For asdot notation in
                YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                number.
                """
                password: str | None = None
                passive: bool | None = None
                remove_private_as: RemovePrivateAs | None = None
                """Remove private AS numbers in outbound AS path."""
                remove_private_as_ingress: RemovePrivateAsIngress | None = None
                weight: Annotated[int, Max[65535]] | None = None
                local_as: str | None = None
                """
                BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                For asdot notation in
                YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                number.
                """
                as_path: AsPath | None = None
                """BGP AS-PATH options."""
                description: str | None = None
                route_reflector_client: bool | None = None
                ebgp_multihop: Annotated[int, Min[1], Max[255]] | None = None
                """Time-to-live in range of hops."""
                next_hop_self: bool | None = None
                shutdown: bool | None = None
                bfd: bool | None = None
                """Enable BFD."""
                bfd_timers: BfdTimers | None = None
                """Override default BFD timers. BFD must be enabled with `bfd: true`."""
                timers: str | None = None
                """BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>"."""
                rib_in_pre_policy_retain: RibInPrePolicyRetain | None = None
                send_community: str | None = None
                """'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'."""
                maximum_routes: int | None = None
                maximum_routes_warning_limit: str | None = None
                """
                Maximum number of routes after which a warning is issued (0 means never warn) or
                Percentage of
                maximum number of routes at which to warn ("<1-100> percent").
                """
                maximum_routes_warning_only: bool | None = None
                allowas_in: AllowasIn | None = None
                default_originate: DefaultOriginate | None = None
                update_source: str | None = None
                route_map_in: str | None = None
                """Inbound route-map name."""
                route_map_out: str | None = None
                """Outbound route-map name."""
                additional_paths: AdditionalPaths | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    ip_address: str = None,
                    peer_group: str | None = None,
                    remote_as: str | None = None,
                    password: str | None = None,
                    passive: bool | None = None,
                    remove_private_as: RemovePrivateAs | None = None,
                    remove_private_as_ingress: RemovePrivateAsIngress | None = None,
                    weight: Annotated[int, Max[65535]] | None = None,
                    local_as: str | None = None,
                    as_path: AsPath | None = None,
                    description: str | None = None,
                    route_reflector_client: bool | None = None,
                    ebgp_multihop: Annotated[int, Min[1], Max[255]] | None = None,
                    next_hop_self: bool | None = None,
                    shutdown: bool | None = None,
                    bfd: bool | None = None,
                    bfd_timers: BfdTimers | None = None,
                    timers: str | None = None,
                    rib_in_pre_policy_retain: RibInPrePolicyRetain | None = None,
                    send_community: str | None = None,
                    maximum_routes: int | None = None,
                    maximum_routes_warning_limit: str | None = None,
                    maximum_routes_warning_only: bool | None = None,
                    allowas_in: AllowasIn | None = None,
                    default_originate: DefaultOriginate | None = None,
                    update_source: str | None = None,
                    route_map_in: str | None = None,
                    route_map_out: str | None = None,
                    additional_paths: AdditionalPaths | None = None,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        peer_group: Peer-group name.
                        remote_as:
                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                           For asdot notation in
                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                           number.
                        password: password
                        passive: passive
                        remove_private_as: Remove private AS numbers in outbound AS path.
                        remove_private_as_ingress: remove_private_as_ingress
                        weight: weight
                        local_as:
                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                           For asdot notation in
                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                           number.
                        as_path: BGP AS-PATH options.
                        description: description
                        route_reflector_client: route_reflector_client
                        ebgp_multihop: Time-to-live in range of hops.
                        next_hop_self: next_hop_self
                        shutdown: shutdown
                        bfd: Enable BFD.
                        bfd_timers: Override default BFD timers. BFD must be enabled with `bfd: true`.
                        timers: BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>".
                        rib_in_pre_policy_retain: rib_in_pre_policy_retain
                        send_community: 'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'.
                        maximum_routes: maximum_routes
                        maximum_routes_warning_limit:
                           Maximum number of routes after which a warning is issued (0 means never warn) or
                           Percentage of
                           maximum number of routes at which to warn ("<1-100> percent").
                        maximum_routes_warning_only: maximum_routes_warning_only
                        allowas_in: allowas_in
                        default_originate: default_originate
                        update_source: update_source
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborInterfacesItem(AvdBase):
                _fields = ("_custom_data", "name", "remote_as", "peer_group", "peer_filter", "description")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Interface name."""
                remote_as: str | None = None
                """
                BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                For asdot notation in
                YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                number.
                """
                peer_group: str | None = None
                """Peer-group name."""
                peer_filter: str | None = None
                """Peer-filter name."""
                description: str | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    remote_as: str | None = None,
                    peer_group: str | None = None,
                    peer_filter: str | None = None,
                    description: str | None = None,
                ) -> None:
                    """
                    NeighborInterfacesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Interface name.
                        remote_as:
                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                           For asdot notation in
                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                           number.
                        peer_group: Peer-group name.
                        peer_filter: Peer-filter name.
                        description: description

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Redistribute(AvdBase):
                class AttachedHost(AvdBase):
                    _fields = ("_custom_data", "enabled", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    route_map: str | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, route_map: str | None = None) -> None:
                        """
                        AttachedHost.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Bgp(AvdBase):
                    _fields = ("_custom_data", "enabled", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    route_map: str | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, route_map: str | None = None) -> None:
                        """
                        Bgp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Connected(AvdBase):
                    _fields = ("_custom_data", "enabled", "route_map", "rcf", "include_leaked")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    route_map: str | None = None
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None = None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        enabled: bool = None,
                        route_map: str | None = None,
                        rcf: str | None = None,
                        include_leaked: bool | None = None,
                    ) -> None:
                        """
                        Connected.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Dynamic(AvdBase):
                    _fields = ("_custom_data", "enabled", "route_map", "rcf")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    route_map: str | None = None
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, route_map: str | None = None, rcf: str | None = None
                    ) -> None:
                        """
                        Dynamic.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Isis(AvdBase):
                    _fields = ("_custom_data", "enabled", "isis_level", "route_map", "rcf", "include_leaked")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    isis_level: Annotated[str, ValidValues["level-1", "level-2", "level-1-2"]] | None = None
                    """Redistribute IS-IS route level."""
                    route_map: str | None = None
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None = None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        enabled: bool = None,
                        isis_level: Annotated[str, ValidValues["level-1", "level-2", "level-1-2"]] | None = None,
                        route_map: str | None = None,
                        rcf: str | None = None,
                        include_leaked: bool | None = None,
                    ) -> None:
                        """
                        Isis.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            isis_level: Redistribute IS-IS route level.
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Ospf(AvdBase):
                    class MatchExternal(AvdBase):
                        _fields = ("_custom_data", "enabled", "route_map", "include_leaked")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        enabled: bool = None
                        route_map: str | None = None
                        include_leaked: bool | None = None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            enabled: bool = None,
                            route_map: str | None = None,
                            include_leaked: bool | None = None,
                        ) -> None:
                            """
                            MatchExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchInternal(AvdBase):
                        _fields = ("_custom_data", "enabled", "route_map", "include_leaked")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        enabled: bool = None
                        route_map: str | None = None
                        include_leaked: bool | None = None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            enabled: bool = None,
                            route_map: str | None = None,
                            include_leaked: bool | None = None,
                        ) -> None:
                            """
                            MatchInternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchNssaExternal(AvdBase):
                        _fields = ("_custom_data", "enabled", "nssa_type", "route_map", "include_leaked")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        enabled: bool = None
                        nssa_type: Annotated[int, ValidValues[1, 2]] | None = None
                        """NSSA External Type Number."""
                        route_map: str | None = None
                        include_leaked: bool | None = None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            enabled: bool = None,
                            nssa_type: Annotated[int, ValidValues[1, 2]] | None = None,
                            route_map: str | None = None,
                            include_leaked: bool | None = None,
                        ) -> None:
                            """
                            MatchNssaExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                nssa_type: NSSA External Type Number.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "enabled", "match_external", "match_internal", "match_nssa_external", "route_map", "include_leaked")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None
                    """Redistribute OSPF routes."""
                    match_external: MatchExternal | None = None
                    """Redistribute OSPF routes learned from external sources."""
                    match_internal: MatchInternal | None = None
                    """Redistribute OSPF routes learned from internal sources."""
                    match_nssa_external: MatchNssaExternal | None = None
                    """Redistribute OSPF routes learned from external NSSA sources."""
                    route_map: str | None = None
                    include_leaked: bool | None = None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        enabled: bool | None = None,
                        match_external: MatchExternal | None = None,
                        match_internal: MatchInternal | None = None,
                        match_nssa_external: MatchNssaExternal | None = None,
                        route_map: str | None = None,
                        include_leaked: bool | None = None,
                    ) -> None:
                        """
                        Ospf.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: Redistribute OSPF routes.
                            match_external: Redistribute OSPF routes learned from external sources.
                            match_internal: Redistribute OSPF routes learned from internal sources.
                            match_nssa_external: Redistribute OSPF routes learned from external NSSA sources.
                            route_map: route_map
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Ospfv3(AvdBase):
                    class MatchExternal(AvdBase):
                        _fields = ("_custom_data", "enabled", "route_map", "include_leaked")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        enabled: bool = None
                        route_map: str | None = None
                        include_leaked: bool | None = None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            enabled: bool = None,
                            route_map: str | None = None,
                            include_leaked: bool | None = None,
                        ) -> None:
                            """
                            MatchExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchInternal(AvdBase):
                        _fields = ("_custom_data", "enabled", "route_map", "include_leaked")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        enabled: bool = None
                        route_map: str | None = None
                        include_leaked: bool | None = None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            enabled: bool = None,
                            route_map: str | None = None,
                            include_leaked: bool | None = None,
                        ) -> None:
                            """
                            MatchInternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchNssaExternal(AvdBase):
                        _fields = ("_custom_data", "enabled", "nssa_type", "route_map", "include_leaked")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        enabled: bool = None
                        nssa_type: Annotated[int, ValidValues[1, 2]] | None = None
                        """NSSA External Type Number."""
                        route_map: str | None = None
                        include_leaked: bool | None = None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            enabled: bool = None,
                            nssa_type: Annotated[int, ValidValues[1, 2]] | None = None,
                            route_map: str | None = None,
                            include_leaked: bool | None = None,
                        ) -> None:
                            """
                            MatchNssaExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                nssa_type: NSSA External Type Number.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "enabled", "match_external", "match_internal", "match_nssa_external", "route_map", "include_leaked")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None
                    """Redistribute OSPFv3 routes."""
                    match_external: MatchExternal | None = None
                    """Redistribute OSPFv3 routes learned from external sources."""
                    match_internal: MatchInternal | None = None
                    """Redistribute OSPFv3 routes learned from internal sources."""
                    match_nssa_external: MatchNssaExternal | None = None
                    """Redistribute OSPFv3 routes learned from external NSSA sources."""
                    route_map: str | None = None
                    include_leaked: bool | None = None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        enabled: bool | None = None,
                        match_external: MatchExternal | None = None,
                        match_internal: MatchInternal | None = None,
                        match_nssa_external: MatchNssaExternal | None = None,
                        route_map: str | None = None,
                        include_leaked: bool | None = None,
                    ) -> None:
                        """
                        Ospfv3.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: Redistribute OSPFv3 routes.
                            match_external: Redistribute OSPFv3 routes learned from external sources.
                            match_internal: Redistribute OSPFv3 routes learned from internal sources.
                            match_nssa_external: Redistribute OSPFv3 routes learned from external NSSA sources.
                            route_map: route_map
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Rip(AvdBase):
                    _fields = ("_custom_data", "enabled", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    route_map: str | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, route_map: str | None = None) -> None:
                        """
                        Rip.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Static(AvdBase):
                    _fields = ("_custom_data", "enabled", "route_map", "rcf", "include_leaked")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    route_map: str | None = None
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None = None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        enabled: bool = None,
                        route_map: str | None = None,
                        rcf: str | None = None,
                        include_leaked: bool | None = None,
                    ) -> None:
                        """
                        Static.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class User(AvdBase):
                    _fields = ("_custom_data", "enabled", "rcf")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, rcf: str | None = None) -> None:
                        """
                        User.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "attached_host", "bgp", "connected", "dynamic", "isis", "ospf", "ospfv3", "rip", "static", "user")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                attached_host: AttachedHost | None = None
                bgp: Bgp | None = None
                connected: Connected | None = None
                dynamic: Dynamic | None = None
                isis: Isis | None = None
                ospf: Ospf | None = None
                ospfv3: Ospfv3 | None = None
                rip: Rip | None = None
                static: Static | None = None
                user: User | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    attached_host: AttachedHost | None = None,
                    bgp: Bgp | None = None,
                    connected: Connected | None = None,
                    dynamic: Dynamic | None = None,
                    isis: Isis | None = None,
                    ospf: Ospf | None = None,
                    ospfv3: Ospfv3 | None = None,
                    rip: Rip | None = None,
                    static: Static | None = None,
                    user: User | None = None,
                ) -> None:
                    """
                    Redistribute.

                    Args:
                    -----
                        _custom_data: _custom_data
                        attached_host: attached_host
                        bgp: bgp
                        connected: connected
                        dynamic: dynamic
                        isis: isis
                        ospf: ospf
                        ospfv3: ospfv3
                        rip: rip
                        static: static
                        user: user

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RedistributeRoutesItem(AvdBase):
                _fields = ("_custom_data", "source_protocol", "route_map", "include_leaked", "rcf", "ospf_route_type")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                source_protocol: str = None
                route_map: str | None = None
                include_leaked: bool | None = None
                rcf: str | None = None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                Only applicable if `source_protocol` is one of `connected`,
                `dynamic`, `isis`, `static` and `user`.
                """
                ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]] | None = None
                """
                Routes learned by the OSPF protocol.
                The `ospf_route_type` is valid for source_protocols 'ospf' and
                'ospfv3'.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    source_protocol: str = None,
                    route_map: str | None = None,
                    include_leaked: bool | None = None,
                    rcf: str | None = None,
                    ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]] | None = None,
                ) -> None:
                    """
                    RedistributeRoutesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_protocol: source_protocol
                        route_map: route_map
                        include_leaked: include_leaked
                        rcf:
                           RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                           `route_map` and `rcf` are mutually
                           exclusive. `route_map` takes precedence.
                           Only applicable if `source_protocol` is one of `connected`,
                           `dynamic`, `isis`, `static` and `user`.
                        ospf_route_type:
                           Routes learned by the OSPF protocol.
                           The `ospf_route_type` is valid for source_protocols 'ospf' and
                           'ospfv3'.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AggregateAddressesItem(AvdBase):
                _fields = ("_custom_data", "prefix", "advertise_only", "as_set", "summary_only", "attribute_map", "match_map")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                prefix: str = None
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                advertise_only: bool | None = None
                as_set: bool | None = None
                summary_only: bool | None = None
                attribute_map: str | None = None
                match_map: str | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    prefix: str = None,
                    advertise_only: bool | None = None,
                    as_set: bool | None = None,
                    summary_only: bool | None = None,
                    attribute_map: str | None = None,
                    match_map: str | None = None,
                ) -> None:
                    """
                    AggregateAddressesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                        advertise_only: advertise_only
                        as_set: as_set
                        summary_only: summary_only
                        attribute_map: attribute_map
                        match_map: match_map

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AddressFamilyIpv4(AvdBase):
                class Bgp(AvdBase):
                    class MissingPolicy(AvdBase):
                        _fields = ("_custom_data", "direction_in_action", "direction_out_action")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None
                        direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                            direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                        ) -> None:
                            """
                            MissingPolicy.

                            Args:
                            -----
                                _custom_data: _custom_data
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class AdditionalPaths(AvdBase):
                        _fields = ("_custom_data", "install", "install_ecmp_primary", "receive", "send", "send_limit")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        install: bool | None = None
                        """Install BGP backup path."""
                        install_ecmp_primary: bool | None = None
                        """Allow additional path with ECMP primary path."""
                        receive: bool | None = None
                        """Enable or disable reception of additional-paths."""
                        send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                        """
                        Select an option to send multiple paths for same prefix through bgp updates.
                        any: Send any eligible
                        path.
                        backup: Best path and installed backup path.
                        ecmp: All paths in best path ECMP group.
                        limit:
                        Limit to n eligible paths.
                        disabled: Disable sending any paths.
                        """
                        send_limit: Annotated[int, Min[2], Max[64]] | None = None
                        """
                        Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                        `ecmp`.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            install: bool | None = None,
                            install_ecmp_primary: bool | None = None,
                            receive: bool | None = None,
                            send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                            send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                        ) -> None:
                            """
                            AdditionalPaths.

                            Args:
                            -----
                                _custom_data: _custom_data
                                install: Install BGP backup path.
                                install_ecmp_primary: Allow additional path with ECMP primary path.
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "missing_policy", "additional_paths", "redistribute_internal")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    missing_policy: MissingPolicy | None = None
                    additional_paths: AdditionalPaths | None = None
                    redistribute_internal: bool | None = None
                    """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        missing_policy: MissingPolicy | None = None,
                        additional_paths: AdditionalPaths | None = None,
                        redistribute_internal: bool | None = None,
                    ) -> None:
                        """
                        Bgp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            missing_policy: missing_policy
                            additional_paths: additional_paths
                            redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NeighborsItem(AvdBase):
                    class NextHop(AvdBase):
                        class AddressFamilyIpv6(AvdBase):
                            _fields = ("_custom_data", "enabled", "originate")
                            _required_fields = ()
                            _custom_data: dict[str, Any] | None = None
                            enabled: bool = None
                            originate: bool | None = None

                            def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, originate: bool | None = None) -> None:
                                """
                                AddressFamilyIpv6.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    originate: originate

                                """
                                for arg, arg_value in locals().items():
                                    if arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields = ("_custom_data", "address_family_ipv6")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        address_family_ipv6: AddressFamilyIpv6 | None = None

                        def __init__(self, *, _custom_data: dict[str, Any] | None = None, address_family_ipv6: AddressFamilyIpv6 | None = None) -> None:
                            """
                            NextHop.

                            Args:
                            -----
                                _custom_data: _custom_data
                                address_family_ipv6: address_family_ipv6

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class AdditionalPaths(AvdBase):
                        _fields = ("_custom_data", "receive", "send", "send_limit")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        receive: bool | None = None
                        """Enable or disable reception of additional-paths."""
                        send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                        """
                        Select an option to send multiple paths for same prefix through bgp updates.
                        any: Send any eligible
                        path.
                        backup: Best path and installed backup path.
                        ecmp: All paths in best path ECMP group.
                        limit:
                        Limit to n eligible paths.
                        disabled: Disable sending any paths.
                        """
                        send_limit: Annotated[int, Min[2], Max[64]] | None = None
                        """
                        Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                        `ecmp`.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            receive: bool | None = None,
                            send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                            send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                        ) -> None:
                            """
                            AdditionalPaths.

                            Args:
                            -----
                                _custom_data: _custom_data
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = (
                        "_custom_data",
                        "ip_address",
                        "activate",
                        "route_map_in",
                        "route_map_out",
                        "rcf_in",
                        "rcf_out",
                        "prefix_list_in",
                        "prefix_list_out",
                        "next_hop",
                        "additional_paths",
                    )
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    ip_address: str = None
                    activate: bool | None = None
                    route_map_in: str | None = None
                    """Inbound route-map name."""
                    route_map_out: str | None = None
                    """Outbound route-map name."""
                    rcf_in: str | None = None
                    """
                    Inbound RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    rcf_out: str | None = None
                    """
                    Outbound RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    prefix_list_in: str | None = None
                    """Inbound prefix-list name."""
                    prefix_list_out: str | None = None
                    """Outbound prefix-list name."""
                    next_hop: NextHop | None = None
                    additional_paths: AdditionalPaths | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        ip_address: str = None,
                        activate: bool | None = None,
                        route_map_in: str | None = None,
                        route_map_out: str | None = None,
                        rcf_in: str | None = None,
                        rcf_out: str | None = None,
                        prefix_list_in: str | None = None,
                        prefix_list_out: str | None = None,
                        next_hop: NextHop | None = None,
                        additional_paths: AdditionalPaths | None = None,
                    ) -> None:
                        """
                        NeighborsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            prefix_list_in: Inbound prefix-list name.
                            prefix_list_out: Outbound prefix-list name.
                            next_hop: next_hop
                            additional_paths: additional_paths

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NetworksItem(AvdBase):
                    _fields = ("_custom_data", "prefix", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    prefix: str = None
                    """IPv4 prefix "A.B.C.D/E"."""
                    route_map: str | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, prefix: str = None, route_map: str | None = None) -> None:
                        """
                        NetworksItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            prefix: IPv4 prefix "A.B.C.D/E".
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class RedistributeRoutesItem(AvdBase):
                    _fields = ("_custom_data", "source_protocol", "route_map", "include_leaked", "rcf", "ospf_route_type")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    source_protocol: Annotated[
                        str, ValidValues["attached-host", "bgp", "connected", "dynamic", "isis", "ospf", "ospfv3", "rip", "static", "user"]
                    ] = None
                    route_map: str | None = None
                    include_leaked: bool | None = None
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    Only applicable if `source_protocol` is one of `connected`,
                    `dynamic`, `isis`, `static` and `user`.
                    """
                    ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]] | None = None
                    """
                    Routes learned by the OSPF protocol.
                    The `ospf_route_type` is valid for source_protocols 'ospf' and
                    'ospfv3'.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        source_protocol: Annotated[
                            str, ValidValues["attached-host", "bgp", "connected", "dynamic", "isis", "ospf", "ospfv3", "rip", "static", "user"]
                        ] = None,
                        route_map: str | None = None,
                        include_leaked: bool | None = None,
                        rcf: str | None = None,
                        ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]]
                        | None = None,
                    ) -> None:
                        """
                        RedistributeRoutesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source_protocol: source_protocol
                            route_map: route_map
                            include_leaked: include_leaked
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                               Only applicable if `source_protocol` is one of `connected`,
                               `dynamic`, `isis`, `static` and `user`.
                            ospf_route_type:
                               Routes learned by the OSPF protocol.
                               The `ospf_route_type` is valid for source_protocols 'ospf' and
                               'ospfv3'.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "bgp", "neighbors", "networks", "redistribute_routes")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                bgp: Bgp | None = None
                neighbors: list[NeighborsItem] | None = None
                networks: list[NetworksItem] | None = None
                redistribute_routes: list[RedistributeRoutesItem] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    bgp: Bgp | None = None,
                    neighbors: list[NeighborsItem] | None = None,
                    networks: list[NetworksItem] | None = None,
                    redistribute_routes: list[RedistributeRoutesItem] | None = None,
                ) -> None:
                    """
                    AddressFamilyIpv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        bgp: bgp
                        neighbors: neighbors
                        networks: networks
                        redistribute_routes: redistribute_routes

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AddressFamilyIpv6(AvdBase):
                class Bgp(AvdBase):
                    class MissingPolicy(AvdBase):
                        _fields = ("_custom_data", "direction_in_action", "direction_out_action")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None
                        direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                            direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                        ) -> None:
                            """
                            MissingPolicy.

                            Args:
                            -----
                                _custom_data: _custom_data
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class AdditionalPaths(AvdBase):
                        _fields = ("_custom_data", "install", "install_ecmp_primary", "receive", "send", "send_limit")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        install: bool | None = None
                        """Install BGP backup path."""
                        install_ecmp_primary: bool | None = None
                        """Allow additional path with ECMP primary path."""
                        receive: bool | None = None
                        """Enable or disable reception of additional-paths."""
                        send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                        """
                        Select an option to send multiple paths for same prefix through bgp updates.
                        any: Send any eligible
                        path.
                        backup: Best path and installed backup path.
                        ecmp: All paths in best path ECMP group.
                        limit:
                        Limit to n eligible paths.
                        disabled: Disable sending any paths.
                        """
                        send_limit: Annotated[int, Min[2], Max[64]] | None = None
                        """
                        Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                        `ecmp`.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            install: bool | None = None,
                            install_ecmp_primary: bool | None = None,
                            receive: bool | None = None,
                            send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                            send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                        ) -> None:
                            """
                            AdditionalPaths.

                            Args:
                            -----
                                _custom_data: _custom_data
                                install: Install BGP backup path.
                                install_ecmp_primary: Allow additional path with ECMP primary path.
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "missing_policy", "additional_paths", "redistribute_internal")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    missing_policy: MissingPolicy | None = None
                    additional_paths: AdditionalPaths | None = None
                    redistribute_internal: bool | None = None
                    """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        missing_policy: MissingPolicy | None = None,
                        additional_paths: AdditionalPaths | None = None,
                        redistribute_internal: bool | None = None,
                    ) -> None:
                        """
                        Bgp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            missing_policy: missing_policy
                            additional_paths: additional_paths
                            redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NeighborsItem(AvdBase):
                    class AdditionalPaths(AvdBase):
                        _fields = ("_custom_data", "receive", "send", "send_limit")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        receive: bool | None = None
                        """Enable or disable reception of additional-paths."""
                        send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None
                        """
                        Select an option to send multiple paths for same prefix through bgp updates.
                        any: Send any eligible
                        path.
                        backup: Best path and installed backup path.
                        ecmp: All paths in best path ECMP group.
                        limit:
                        Limit to n eligible paths.
                        disabled: Disable sending any paths.
                        """
                        send_limit: Annotated[int, Min[2], Max[64]] | None = None
                        """
                        Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                        `ecmp`.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            receive: bool | None = None,
                            send: Annotated[str, ValidValues["any", "backup", "ecmp", "limit", "disabled"]] | None = None,
                            send_limit: Annotated[int, Min[2], Max[64]] | None = None,
                        ) -> None:
                            """
                            AdditionalPaths.

                            Args:
                            -----
                                _custom_data: _custom_data
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = (
                        "_custom_data",
                        "ip_address",
                        "activate",
                        "route_map_in",
                        "route_map_out",
                        "rcf_in",
                        "rcf_out",
                        "prefix_list_in",
                        "prefix_list_out",
                        "additional_paths",
                    )
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    ip_address: str = None
                    activate: bool | None = None
                    route_map_in: str | None = None
                    """Inbound route-map name."""
                    route_map_out: str | None = None
                    """Outbound route-map name."""
                    rcf_in: str | None = None
                    """
                    Inbound RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    rcf_out: str | None = None
                    """
                    Outbound RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    prefix_list_in: str | None = None
                    """Inbound prefix-list name."""
                    prefix_list_out: str | None = None
                    """Outbound prefix-list name."""
                    additional_paths: AdditionalPaths | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        ip_address: str = None,
                        activate: bool | None = None,
                        route_map_in: str | None = None,
                        route_map_out: str | None = None,
                        rcf_in: str | None = None,
                        rcf_out: str | None = None,
                        prefix_list_in: str | None = None,
                        prefix_list_out: str | None = None,
                        additional_paths: AdditionalPaths | None = None,
                    ) -> None:
                        """
                        NeighborsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            prefix_list_in: Inbound prefix-list name.
                            prefix_list_out: Outbound prefix-list name.
                            additional_paths: additional_paths

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NetworksItem(AvdBase):
                    _fields = ("_custom_data", "prefix", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    prefix: str = None
                    """IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                    route_map: str | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, prefix: str = None, route_map: str | None = None) -> None:
                        """
                        NetworksItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            prefix: IPv6 prefix "A:B:C:D:E:F:G:H/I".
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class RedistributeRoutesItem(AvdBase):
                    _fields = ("_custom_data", "source_protocol", "route_map", "include_leaked", "rcf", "ospf_route_type")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    source_protocol: Annotated[str, ValidValues["attached-host", "bgp", "connected", "dhcp", "dynamic", "isis", "ospfv3", "static", "user"]] = (
                        None
                    )
                    route_map: str | None = None
                    include_leaked: bool | None = None
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    Only applicable if `source_protocol` is one of `connected`,
                    `dynamic`, `isis`, `static` and `user`.
                    """
                    ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]] | None = None
                    """
                    Routes learned by the OSPF protocol.
                    The `ospf_route_type` is valid for source_protocols 'ospfv3'.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        source_protocol: Annotated[
                            str, ValidValues["attached-host", "bgp", "connected", "dhcp", "dynamic", "isis", "ospfv3", "static", "user"]
                        ] = None,
                        route_map: str | None = None,
                        include_leaked: bool | None = None,
                        rcf: str | None = None,
                        ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]]
                        | None = None,
                    ) -> None:
                        """
                        RedistributeRoutesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source_protocol: source_protocol
                            route_map: route_map
                            include_leaked: include_leaked
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                               Only applicable if `source_protocol` is one of `connected`,
                               `dynamic`, `isis`, `static` and `user`.
                            ospf_route_type:
                               Routes learned by the OSPF protocol.
                               The `ospf_route_type` is valid for source_protocols 'ospfv3'.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "bgp", "neighbors", "networks", "redistribute_routes")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                bgp: Bgp | None = None
                neighbors: list[NeighborsItem] | None = None
                networks: list[NetworksItem] | None = None
                redistribute_routes: list[RedistributeRoutesItem] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    bgp: Bgp | None = None,
                    neighbors: list[NeighborsItem] | None = None,
                    networks: list[NetworksItem] | None = None,
                    redistribute_routes: list[RedistributeRoutesItem] | None = None,
                ) -> None:
                    """
                    AddressFamilyIpv6.

                    Args:
                    -----
                        _custom_data: _custom_data
                        bgp: bgp
                        neighbors: neighbors
                        networks: networks
                        redistribute_routes: redistribute_routes

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AddressFamilyIpv4Multicast(AvdBase):
                class Bgp(AvdBase):
                    class MissingPolicy(AvdBase):
                        _fields = ("_custom_data", "direction_in_action", "direction_out_action")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None
                        direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                            direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                        ) -> None:
                            """
                            MissingPolicy.

                            Args:
                            -----
                                _custom_data: _custom_data
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class AdditionalPaths(AvdBase):
                        _fields = ("_custom_data", "receive")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        receive: bool | None = None

                        def __init__(self, *, _custom_data: dict[str, Any] | None = None, receive: bool | None = None) -> None:
                            """
                            AdditionalPaths.

                            Args:
                            -----
                                _custom_data: _custom_data
                                receive: receive

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "missing_policy", "additional_paths")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    missing_policy: MissingPolicy | None = None
                    additional_paths: AdditionalPaths | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        missing_policy: MissingPolicy | None = None,
                        additional_paths: AdditionalPaths | None = None,
                    ) -> None:
                        """
                        Bgp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            missing_policy: missing_policy
                            additional_paths: additional_paths

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NeighborsItem(AvdBase):
                    class AdditionalPaths(AvdBase):
                        _fields = ("_custom_data", "receive")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        receive: bool | None = None

                        def __init__(self, *, _custom_data: dict[str, Any] | None = None, receive: bool | None = None) -> None:
                            """
                            AdditionalPaths.

                            Args:
                            -----
                                _custom_data: _custom_data
                                receive: receive

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "ip_address", "activate", "route_map_in", "route_map_out", "additional_paths")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    ip_address: str = None
                    activate: bool | None = None
                    route_map_in: str | None = None
                    """Inbound route-map name."""
                    route_map_out: str | None = None
                    """Outbound route-map name."""
                    additional_paths: AdditionalPaths | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        ip_address: str = None,
                        activate: bool | None = None,
                        route_map_in: str | None = None,
                        route_map_out: str | None = None,
                        additional_paths: AdditionalPaths | None = None,
                    ) -> None:
                        """
                        NeighborsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            additional_paths: additional_paths

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NetworksItem(AvdBase):
                    _fields = ("_custom_data", "prefix", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    prefix: str = None
                    """IPv6 prefix "A.B.C.D/E"."""
                    route_map: str | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, prefix: str = None, route_map: str | None = None) -> None:
                        """
                        NetworksItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            prefix: IPv6 prefix "A.B.C.D/E".
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class RedistributeRoutesItem(AvdBase):
                    _fields = ("_custom_data", "source_protocol", "route_map", "include_leaked", "rcf", "ospf_route_type")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    source_protocol: Annotated[str, ValidValues["attached-host", "connected", "isis", "ospf", "ospfv3", "static"]] = None
                    route_map: str | None = None
                    include_leaked: bool | None = None
                    """Only applicable if `source_protocol` is `isis`."""
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    Only applicable if `source_protocol` is `isis`.
                    """
                    ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]] | None = None
                    """
                    Routes learned by the OSPF protocol.
                    The `ospf_route_type` is valid for source_protocols 'ospf' and
                    'ospfv3'.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        source_protocol: Annotated[str, ValidValues["attached-host", "connected", "isis", "ospf", "ospfv3", "static"]] = None,
                        route_map: str | None = None,
                        include_leaked: bool | None = None,
                        rcf: str | None = None,
                        ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]]
                        | None = None,
                    ) -> None:
                        """
                        RedistributeRoutesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source_protocol: source_protocol
                            route_map: route_map
                            include_leaked: Only applicable if `source_protocol` is `isis`.
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                               Only applicable if `source_protocol` is `isis`.
                            ospf_route_type:
                               Routes learned by the OSPF protocol.
                               The `ospf_route_type` is valid for source_protocols 'ospf' and
                               'ospfv3'.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "bgp", "neighbors", "networks", "redistribute_routes")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                bgp: Bgp | None = None
                neighbors: list[NeighborsItem] | None = None
                networks: list[NetworksItem] | None = None
                redistribute_routes: list[RedistributeRoutesItem] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    bgp: Bgp | None = None,
                    neighbors: list[NeighborsItem] | None = None,
                    networks: list[NetworksItem] | None = None,
                    redistribute_routes: list[RedistributeRoutesItem] | None = None,
                ) -> None:
                    """
                    AddressFamilyIpv4Multicast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        bgp: bgp
                        neighbors: neighbors
                        networks: networks
                        redistribute_routes: redistribute_routes

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AddressFamilyIpv6Multicast(AvdBase):
                class Bgp(AvdBase):
                    class MissingPolicy(AvdBase):
                        _fields = ("_custom_data", "direction_in_action", "direction_out_action")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None
                        direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                            direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                        ) -> None:
                            """
                            MissingPolicy.

                            Args:
                            -----
                                _custom_data: _custom_data
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class AdditionalPaths(AvdBase):
                        _fields = ("_custom_data", "receive")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        receive: bool | None = None

                        def __init__(self, *, _custom_data: dict[str, Any] | None = None, receive: bool | None = None) -> None:
                            """
                            AdditionalPaths.

                            Args:
                            -----
                                _custom_data: _custom_data
                                receive: receive

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "missing_policy", "additional_paths")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    missing_policy: MissingPolicy | None = None
                    additional_paths: AdditionalPaths | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        missing_policy: MissingPolicy | None = None,
                        additional_paths: AdditionalPaths | None = None,
                    ) -> None:
                        """
                        Bgp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            missing_policy: missing_policy
                            additional_paths: additional_paths

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NeighborsItem(AvdBase):
                    class AdditionalPaths(AvdBase):
                        _fields = ("_custom_data", "receive")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        receive: bool | None = None

                        def __init__(self, *, _custom_data: dict[str, Any] | None = None, receive: bool | None = None) -> None:
                            """
                            AdditionalPaths.

                            Args:
                            -----
                                _custom_data: _custom_data
                                receive: receive

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "ip_address", "activate", "route_map_in", "route_map_out", "additional_paths")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    ip_address: str = None
                    activate: bool | None = None
                    route_map_in: str | None = None
                    """Inbound route-map name."""
                    route_map_out: str | None = None
                    """Outbound route-map name."""
                    additional_paths: AdditionalPaths | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        ip_address: str = None,
                        activate: bool | None = None,
                        route_map_in: str | None = None,
                        route_map_out: str | None = None,
                        additional_paths: AdditionalPaths | None = None,
                    ) -> None:
                        """
                        NeighborsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            additional_paths: additional_paths

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NetworksItem(AvdBase):
                    _fields = ("_custom_data", "prefix", "route_map")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    prefix: str = None
                    """IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                    route_map: str | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, prefix: str = None, route_map: str | None = None) -> None:
                        """
                        NetworksItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            prefix: IPv6 prefix "A:B:C:D:E:F:G:H/I".
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class RedistributeRoutesItem(AvdBase):
                    _fields = ("_custom_data", "source_protocol", "route_map", "include_leaked", "rcf", "ospf_route_type")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    source_protocol: Annotated[str, ValidValues["connected", "isis", "ospf", "ospfv3", "static"]] = None
                    route_map: str | None = None
                    include_leaked: bool | None = None
                    """Only applicable if `source_protocol` is `isis`."""
                    rcf: str | None = None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    Only applicable if `source_protocol` is `isis`.
                    """
                    ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]] | None = None
                    """
                    Routes learned by the OSPF protocol.
                    The `ospf_route_type` is valid for source_protocols 'ospf' and
                    'ospfv3'.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        source_protocol: Annotated[str, ValidValues["connected", "isis", "ospf", "ospfv3", "static"]] = None,
                        route_map: str | None = None,
                        include_leaked: bool | None = None,
                        rcf: str | None = None,
                        ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external", "nssa-external 1", "nssa-external 2"]]
                        | None = None,
                    ) -> None:
                        """
                        RedistributeRoutesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source_protocol: source_protocol
                            route_map: route_map
                            include_leaked: Only applicable if `source_protocol` is `isis`.
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                               Only applicable if `source_protocol` is `isis`.
                            ospf_route_type:
                               Routes learned by the OSPF protocol.
                               The `ospf_route_type` is valid for source_protocols 'ospf' and
                               'ospfv3'.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "bgp", "neighbors", "networks", "redistribute_routes")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                bgp: Bgp | None = None
                neighbors: list[NeighborsItem] | None = None
                networks: list[NetworksItem] | None = None
                redistribute_routes: list[RedistributeRoutesItem] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    bgp: Bgp | None = None,
                    neighbors: list[NeighborsItem] | None = None,
                    networks: list[NetworksItem] | None = None,
                    redistribute_routes: list[RedistributeRoutesItem] | None = None,
                ) -> None:
                    """
                    AddressFamilyIpv6Multicast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        bgp: bgp
                        neighbors: neighbors
                        networks: networks
                        redistribute_routes: redistribute_routes

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AddressFamilyFlowSpecIpv4(AvdBase):
                class Bgp(AvdBase):
                    class MissingPolicy(AvdBase):
                        _fields = ("_custom_data", "direction_in_action", "direction_out_action")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None
                        direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                            direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                        ) -> None:
                            """
                            MissingPolicy.

                            Args:
                            -----
                                _custom_data: _custom_data
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "missing_policy")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    missing_policy: MissingPolicy | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, missing_policy: MissingPolicy | None = None) -> None:
                        """
                        Bgp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            missing_policy: missing_policy

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NeighborsItem(AvdBase):
                    _fields = ("_custom_data", "ip_address", "activate")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    ip_address: str = None
                    activate: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, ip_address: str = None, activate: bool | None = None) -> None:
                        """
                        NeighborsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            ip_address: ip_address
                            activate: activate

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "bgp", "neighbors")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                bgp: Bgp | None = None
                neighbors: list[NeighborsItem] | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, bgp: Bgp | None = None, neighbors: list[NeighborsItem] | None = None) -> None:
                    """
                    AddressFamilyFlowSpecIpv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        bgp: bgp
                        neighbors: neighbors

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AddressFamilyFlowSpecIpv6(AvdBase):
                class Bgp(AvdBase):
                    class MissingPolicy(AvdBase):
                        _fields = ("_custom_data", "direction_in_action", "direction_out_action")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None
                        direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            direction_in_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                            direction_out_action: Annotated[str, ValidValues["deny", "deny-in-out", "permit"]] | None = None,
                        ) -> None:
                            """
                            MissingPolicy.

                            Args:
                            -----
                                _custom_data: _custom_data
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "missing_policy")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    missing_policy: MissingPolicy | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, missing_policy: MissingPolicy | None = None) -> None:
                        """
                        Bgp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            missing_policy: missing_policy

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NeighborsItem(AvdBase):
                    _fields = ("_custom_data", "ip_address", "activate")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    ip_address: str = None
                    activate: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, ip_address: str = None, activate: bool | None = None) -> None:
                        """
                        NeighborsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            ip_address: ip_address
                            activate: activate

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "bgp", "neighbors")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                bgp: Bgp | None = None
                neighbors: list[NeighborsItem] | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, bgp: Bgp | None = None, neighbors: list[NeighborsItem] | None = None) -> None:
                    """
                    AddressFamilyFlowSpecIpv6.

                    Args:
                    -----
                        _custom_data: _custom_data
                        bgp: bgp
                        neighbors: neighbors

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = (
                "_custom_data",
                "name",
                "bgp",
                "rd",
                "evpn_multicast",
                "evpn_multicast_address_family",
                "evpn_multicast_gateway_dr_election",
                "default_route_exports",
                "route_targets",
                "router_id",
                "timers",
                "networks",
                "updates",
                "listen_ranges",
                "neighbors",
                "neighbor_interfaces",
                "redistribute",
                "redistribute_routes",
                "aggregate_addresses",
                "address_family_ipv4",
                "address_family_ipv6",
                "address_family_ipv4_multicast",
                "address_family_ipv6_multicast",
                "address_family_flow_spec_ipv4",
                "address_family_flow_spec_ipv6",
                "eos_cli",
            )
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """VRF name."""
            bgp: Bgp | None = None
            rd: str | None = None
            """Route distinguisher."""
            evpn_multicast: bool | None = None
            evpn_multicast_address_family: EvpnMulticastAddressFamily | None = None
            """Enable per-AF EVPN multicast settings."""
            evpn_multicast_gateway_dr_election: EvpnMulticastGatewayDrElection | None = None
            default_route_exports: list[DefaultRouteExportsItem] | None = None
            """Enable default-originate per VRF/address-family."""
            route_targets: RouteTargets | None = None
            router_id: str | None = None
            """in IP address format A.B.C.D."""
            timers: str | None = None
            """BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>"."""
            networks: list[NetworksItem] | None = None
            updates: Updates | None = None
            listen_ranges: list[ListenRangesItem] | None = None
            """
            Improved "listen_ranges" data model to support multiple listen ranges and additional filter
            capabilities.
            """
            neighbors: list[NeighborsItem] | None = None
            neighbor_interfaces: list[NeighborInterfacesItem] | None = None
            redistribute: Redistribute | None = None
            """Redistribute routes in to BGP."""
            redistribute_routes: list[RedistributeRoutesItem] | None = None
            aggregate_addresses: list[AggregateAddressesItem] | None = None
            address_family_ipv4: AddressFamilyIpv4 | None = None
            address_family_ipv6: AddressFamilyIpv6 | None = None
            address_family_ipv4_multicast: AddressFamilyIpv4Multicast | None = None
            address_family_ipv6_multicast: AddressFamilyIpv6Multicast | None = None
            address_family_flow_spec_ipv4: AddressFamilyFlowSpecIpv4 | None = None
            address_family_flow_spec_ipv6: AddressFamilyFlowSpecIpv6 | None = None
            eos_cli: str | None = None
            """
            Multiline EOS CLI rendered directly on the Router BGP, VRF definition in the final EOS
            configuration.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                bgp: Bgp | None = None,
                rd: str | None = None,
                evpn_multicast: bool | None = None,
                evpn_multicast_address_family: EvpnMulticastAddressFamily | None = None,
                evpn_multicast_gateway_dr_election: EvpnMulticastGatewayDrElection | None = None,
                default_route_exports: list[DefaultRouteExportsItem] | None = None,
                route_targets: RouteTargets | None = None,
                router_id: str | None = None,
                timers: str | None = None,
                networks: list[NetworksItem] | None = None,
                updates: Updates | None = None,
                listen_ranges: list[ListenRangesItem] | None = None,
                neighbors: list[NeighborsItem] | None = None,
                neighbor_interfaces: list[NeighborInterfacesItem] | None = None,
                redistribute: Redistribute | None = None,
                redistribute_routes: list[RedistributeRoutesItem] | None = None,
                aggregate_addresses: list[AggregateAddressesItem] | None = None,
                address_family_ipv4: AddressFamilyIpv4 | None = None,
                address_family_ipv6: AddressFamilyIpv6 | None = None,
                address_family_ipv4_multicast: AddressFamilyIpv4Multicast | None = None,
                address_family_ipv6_multicast: AddressFamilyIpv6Multicast | None = None,
                address_family_flow_spec_ipv4: AddressFamilyFlowSpecIpv4 | None = None,
                address_family_flow_spec_ipv6: AddressFamilyFlowSpecIpv6 | None = None,
                eos_cli: str | None = None,
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF name.
                    bgp: bgp
                    rd: Route distinguisher.
                    evpn_multicast: evpn_multicast
                    evpn_multicast_address_family: Enable per-AF EVPN multicast settings.
                    evpn_multicast_gateway_dr_election: evpn_multicast_gateway_dr_election
                    default_route_exports: Enable default-originate per VRF/address-family.
                    route_targets: route_targets
                    router_id: in IP address format A.B.C.D.
                    timers: BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>".
                    networks: networks
                    updates: updates
                    listen_ranges:
                       Improved "listen_ranges" data model to support multiple listen ranges and additional filter
                       capabilities.
                    neighbors: neighbors
                    neighbor_interfaces: neighbor_interfaces
                    redistribute: Redistribute routes in to BGP.
                    redistribute_routes: redistribute_routes
                    aggregate_addresses: aggregate_addresses
                    address_family_ipv4: address_family_ipv4
                    address_family_ipv6: address_family_ipv6
                    address_family_ipv4_multicast: address_family_ipv4_multicast
                    address_family_ipv6_multicast: address_family_ipv6_multicast
                    address_family_flow_spec_ipv4: address_family_flow_spec_ipv4
                    address_family_flow_spec_ipv6: address_family_flow_spec_ipv6
                    eos_cli:
                       Multiline EOS CLI rendered directly on the Router BGP, VRF definition in the final EOS
                       configuration.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SessionTrackersItem(AvdBase):
            _fields = ("_custom_data", "name", "recovery_delay")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Name of session tracker."""
            recovery_delay: Annotated[int, Min[1], Max[3600]] | None = None
            """Recovery delay in seconds."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, name: str = None, recovery_delay: Annotated[int, Min[1], Max[3600]] | None = None
            ) -> None:
                """
                SessionTrackersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Name of session tracker.
                    recovery_delay: Recovery delay in seconds.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "field_as",
            "as_notation",
            "router_id",
            "distance",
            "graceful_restart",
            "graceful_restart_helper",
            "maximum_paths",
            "updates",
            "bgp_cluster_id",
            "bgp_defaults",
            "bgp",
            "listen_ranges",
            "peer_groups",
            "neighbors",
            "neighbor_interfaces",
            "aggregate_addresses",
            "redistribute_routes",
            "vlan_aware_bundles",
            "vlans",
            "vpws",
            "address_family_evpn",
            "address_family_rtc",
            "address_family_ipv4",
            "address_family_ipv4_labeled_unicast",
            "address_family_ipv4_multicast",
            "address_family_ipv4_sr_te",
            "address_family_ipv6",
            "address_family_ipv6_multicast",
            "address_family_ipv6_sr_te",
            "address_family_link_state",
            "address_family_flow_spec_ipv4",
            "address_family_flow_spec_ipv6",
            "address_family_path_selection",
            "address_family_vpn_ipv4",
            "address_family_vpn_ipv6",
            "vrfs",
            "session_trackers",
            "eos_cli",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        field_as: str | None = None
        """
        BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
        For asdot notation in
        YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
        number.
        """
        as_notation: Annotated[str, ValidValues["asdot", "asplain"]] | None = None
        """
        BGP AS can be deplayed in the asplain <1-4294967295> or asdot notation "<1-65535>.<0-65535>". This
        flag indicates which mode is preferred - asplain is the default.
        """
        router_id: str | None = None
        """In IP address format A.B.C.D."""
        distance: Distance | None = None
        graceful_restart: GracefulRestart | None = None
        graceful_restart_helper: GracefulRestartHelper | None = None
        maximum_paths: MaximumPaths | None = None
        updates: Updates | None = None
        bgp_cluster_id: str | None = None
        """IP Address A.B.C.D."""
        bgp_defaults: list[str] | None = None
        """BGP command as string."""
        bgp: Bgp | None = None
        listen_ranges: list[ListenRangesItem] | None = None
        """
        Improved "listen_ranges" data model to support multiple listen ranges and additional filter
        capabilities.
        """
        peer_groups: list[PeerGroupsItem] | None = None
        neighbors: list[NeighborsItem] | None = None
        neighbor_interfaces: list[NeighborInterfacesItem] | None = None
        aggregate_addresses: list[AggregateAddressesItem] | None = None
        redistribute_routes: list[RedistributeRoutesItem] | None = None
        vlan_aware_bundles: list[VlanAwareBundlesItem] | None = None
        vlans: list[VlansItem] | None = None
        vpws: list[VpwsItem] | None = None
        address_family_evpn: AddressFamilyEvpn | None = None
        address_family_rtc: AddressFamilyRtc | None = None
        address_family_ipv4: AddressFamilyIpv4 | None = None
        address_family_ipv4_labeled_unicast: AddressFamilyIpv4LabeledUnicast | None = None
        address_family_ipv4_multicast: AddressFamilyIpv4Multicast | None = None
        address_family_ipv4_sr_te: AddressFamilyIpv4SrTe | None = None
        address_family_ipv6: AddressFamilyIpv6 | None = None
        address_family_ipv6_multicast: AddressFamilyIpv6Multicast | None = None
        address_family_ipv6_sr_te: AddressFamilyIpv6SrTe | None = None
        address_family_link_state: AddressFamilyLinkState | None = None
        address_family_flow_spec_ipv4: AddressFamilyFlowSpecIpv4 | None = None
        address_family_flow_spec_ipv6: AddressFamilyFlowSpecIpv6 | None = None
        address_family_path_selection: AddressFamilyPathSelection | None = None
        address_family_vpn_ipv4: AddressFamilyVpnIpv4 | None = None
        address_family_vpn_ipv6: AddressFamilyVpnIpv6 | None = None
        vrfs: list[VrfsItem] | None = None
        session_trackers: list[SessionTrackersItem] | None = None
        eos_cli: str | None = None
        """Multiline EOS CLI rendered directly on the Router BGP in the final EOS configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            field_as: str | None = None,
            as_notation: Annotated[str, ValidValues["asdot", "asplain"]] | None = None,
            router_id: str | None = None,
            distance: Distance | None = None,
            graceful_restart: GracefulRestart | None = None,
            graceful_restart_helper: GracefulRestartHelper | None = None,
            maximum_paths: MaximumPaths | None = None,
            updates: Updates | None = None,
            bgp_cluster_id: str | None = None,
            bgp_defaults: list[str] | None = None,
            bgp: Bgp | None = None,
            listen_ranges: list[ListenRangesItem] | None = None,
            peer_groups: list[PeerGroupsItem] | None = None,
            neighbors: list[NeighborsItem] | None = None,
            neighbor_interfaces: list[NeighborInterfacesItem] | None = None,
            aggregate_addresses: list[AggregateAddressesItem] | None = None,
            redistribute_routes: list[RedistributeRoutesItem] | None = None,
            vlan_aware_bundles: list[VlanAwareBundlesItem] | None = None,
            vlans: list[VlansItem] | None = None,
            vpws: list[VpwsItem] | None = None,
            address_family_evpn: AddressFamilyEvpn | None = None,
            address_family_rtc: AddressFamilyRtc | None = None,
            address_family_ipv4: AddressFamilyIpv4 | None = None,
            address_family_ipv4_labeled_unicast: AddressFamilyIpv4LabeledUnicast | None = None,
            address_family_ipv4_multicast: AddressFamilyIpv4Multicast | None = None,
            address_family_ipv4_sr_te: AddressFamilyIpv4SrTe | None = None,
            address_family_ipv6: AddressFamilyIpv6 | None = None,
            address_family_ipv6_multicast: AddressFamilyIpv6Multicast | None = None,
            address_family_ipv6_sr_te: AddressFamilyIpv6SrTe | None = None,
            address_family_link_state: AddressFamilyLinkState | None = None,
            address_family_flow_spec_ipv4: AddressFamilyFlowSpecIpv4 | None = None,
            address_family_flow_spec_ipv6: AddressFamilyFlowSpecIpv6 | None = None,
            address_family_path_selection: AddressFamilyPathSelection | None = None,
            address_family_vpn_ipv4: AddressFamilyVpnIpv4 | None = None,
            address_family_vpn_ipv6: AddressFamilyVpnIpv6 | None = None,
            vrfs: list[VrfsItem] | None = None,
            session_trackers: list[SessionTrackersItem] | None = None,
            eos_cli: str | None = None,
        ) -> None:
            """
            RouterBgp.

            Args:
            -----
                _custom_data: _custom_data
                field_as:
                   BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                   For asdot notation in
                   YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                   number.
                as_notation:
                   BGP AS can be deplayed in the asplain <1-4294967295> or asdot notation "<1-65535>.<0-65535>". This
                   flag indicates which mode is preferred - asplain is the default.
                router_id: In IP address format A.B.C.D.
                distance: distance
                graceful_restart: graceful_restart
                graceful_restart_helper: graceful_restart_helper
                maximum_paths: maximum_paths
                updates: updates
                bgp_cluster_id: IP Address A.B.C.D.
                bgp_defaults: BGP command as string.
                bgp: bgp
                listen_ranges:
                   Improved "listen_ranges" data model to support multiple listen ranges and additional filter
                   capabilities.
                peer_groups: peer_groups
                neighbors: neighbors
                neighbor_interfaces: neighbor_interfaces
                aggregate_addresses: aggregate_addresses
                redistribute_routes: redistribute_routes
                vlan_aware_bundles: vlan_aware_bundles
                vlans: vlans
                vpws: vpws
                address_family_evpn: address_family_evpn
                address_family_rtc: address_family_rtc
                address_family_ipv4: address_family_ipv4
                address_family_ipv4_labeled_unicast: address_family_ipv4_labeled_unicast
                address_family_ipv4_multicast: address_family_ipv4_multicast
                address_family_ipv4_sr_te: address_family_ipv4_sr_te
                address_family_ipv6: address_family_ipv6
                address_family_ipv6_multicast: address_family_ipv6_multicast
                address_family_ipv6_sr_te: address_family_ipv6_sr_te
                address_family_link_state: address_family_link_state
                address_family_flow_spec_ipv4: address_family_flow_spec_ipv4
                address_family_flow_spec_ipv6: address_family_flow_spec_ipv6
                address_family_path_selection: address_family_path_selection
                address_family_vpn_ipv4: address_family_vpn_ipv4
                address_family_vpn_ipv6: address_family_vpn_ipv6
                vrfs: vrfs
                session_trackers: session_trackers
                eos_cli: Multiline EOS CLI rendered directly on the Router BGP in the final EOS configuration.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterGeneral(AvdBase):
        class RouterId(AvdBase):
            _fields = ("_custom_data", "ipv4", "ipv6")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv4: str | None = None
            """IPv4 Address."""
            ipv6: str | None = None
            """IPv6 Address."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, ipv4: str | None = None, ipv6: str | None = None) -> None:
                """
                RouterId.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: IPv4 Address.
                    ipv6: IPv6 Address.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrfsItem(AvdBase):
            class LeakRoutesItem(AvdBase):
                _fields = ("_custom_data", "source_vrf", "subscribe_policy")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                source_vrf: str | None = None
                subscribe_policy: str | None = None
                """Route-Map Policy."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, source_vrf: str | None = None, subscribe_policy: str | None = None) -> None:
                    """
                    LeakRoutesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_vrf: source_vrf
                        subscribe_policy: Route-Map Policy.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Routes(AvdBase):
                class DynamicPrefixListsItem(AvdBase):
                    _fields = ("_custom_data", "name")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    name: str | None = None
                    """Dynamic Prefix List Name."""

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None) -> None:
                        """
                        DynamicPrefixListsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: Dynamic Prefix List Name.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "dynamic_prefix_lists")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                dynamic_prefix_lists: list[DynamicPrefixListsItem] | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, dynamic_prefix_lists: list[DynamicPrefixListsItem] | None = None) -> None:
                    """
                    Routes.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dynamic_prefix_lists: dynamic_prefix_lists

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "leak_routes", "routes")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Destination-VRF."""
            leak_routes: list[LeakRoutesItem] | None = None
            routes: Routes | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                leak_routes: list[LeakRoutesItem] | None = None,
                routes: Routes | None = None,
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Destination-VRF.
                    leak_routes: leak_routes
                    routes: routes

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ControlFunctions(AvdBase):
            class CodeUnitsItem(AvdBase):
                _fields = ("_custom_data", "name", "content")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Name of the code unit."""
                content: str = None
                """
                Content of route control function.
                e.g.
                function ACCEPT_ALL() {
                  return true;
                  }
                EOF
                """

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, content: str = None) -> None:
                    """
                    CodeUnitsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Name of the code unit.
                        content:
                           Content of route control function.
                           e.g.
                           function ACCEPT_ALL() {
                             return true;
                             }
                           EOF

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "code_units")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            code_units: list[CodeUnitsItem] | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, code_units: list[CodeUnitsItem] | None = None) -> None:
                """
                ControlFunctions.

                Args:
                -----
                    _custom_data: _custom_data
                    code_units: code_units

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "router_id", "nexthop_fast_failover", "vrfs", "control_functions")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        router_id: RouterId | None = None
        nexthop_fast_failover: bool | None = False
        vrfs: list[VrfsItem] | None = None
        control_functions: ControlFunctions | None = None
        """
        Routing control functions (RCF) used to filter and update routes from a peer or during
        redistributions.
        Warning:
        This configuration cannot be pushed with `eos_config_deploy_eapi`, because
        of limitations in `arista.eos` and `ansible.netcommon` plugins.
        The configuration can be pushed via
        CloudVision with `eos_config_deploy_cvp` or `cv_deploy`.
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            router_id: RouterId | None = None,
            nexthop_fast_failover: bool | None = False,
            vrfs: list[VrfsItem] | None = None,
            control_functions: ControlFunctions | None = None,
        ) -> None:
            """
            RouterGeneral.

            Args:
            -----
                _custom_data: _custom_data
                router_id: router_id
                nexthop_fast_failover: nexthop_fast_failover
                vrfs: vrfs
                control_functions:
                   Routing control functions (RCF) used to filter and update routes from a peer or during
                   redistributions.

            Warning:
                   This configuration cannot be pushed with `eos_config_deploy_eapi`, because
                   of limitations in `arista.eos` and `ansible.netcommon` plugins.
                   The configuration can be pushed via
                   CloudVision with `eos_config_deploy_cvp` or `cv_deploy`.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterIgmp(AvdBase):
        class VrfsItem(AvdBase):
            _fields = ("_custom_data", "name", "host_proxy_match_mroute")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """VRF name."""
            host_proxy_match_mroute: Annotated[str, ValidValues["all", "iif"]] | None = None
            """
            Specify conditions for sending IGMP joins for host-proxy.
            'iif' will enable igmp host-proxy to work
            in iif aware.
            'all' will enable igmp host-proxy to work in iif unaware mode (EOS default).
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                host_proxy_match_mroute: Annotated[str, ValidValues["all", "iif"]] | None = None,
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF name.
                    host_proxy_match_mroute:
                       Specify conditions for sending IGMP joins for host-proxy.
                       'iif' will enable igmp host-proxy to work
                       in iif aware.
                       'all' will enable igmp host-proxy to work in iif unaware mode (EOS default).

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "host_proxy_match_mroute", "ssm_aware", "vrfs")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        host_proxy_match_mroute: Annotated[str, ValidValues["all", "iif"]] | None = None
        """
        Specify conditions for sending IGMP joins for host-proxy.
        'iif' will enable igmp host-proxy to work
        in iif aware.
        'all' will enable igmp host-proxy to work in iif unaware mode (EOS default).
        """
        ssm_aware: bool | None = None
        vrfs: list[VrfsItem] | None = None
        """
        Configure IGMP in a VRF.
        VRF 'default' is not supported in EOS, please see keys directly under
        'router_igmp'.
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            host_proxy_match_mroute: Annotated[str, ValidValues["all", "iif"]] | None = None,
            ssm_aware: bool | None = None,
            vrfs: list[VrfsItem] | None = None,
        ) -> None:
            """
            RouterIgmp.

            Args:
            -----
                _custom_data: _custom_data
                host_proxy_match_mroute:
                   Specify conditions for sending IGMP joins for host-proxy.
                   'iif' will enable igmp host-proxy to work
                   in iif aware.
                   'all' will enable igmp host-proxy to work in iif unaware mode (EOS default).
                ssm_aware: ssm_aware
                vrfs:
                   Configure IGMP in a VRF.
                   VRF 'default' is not supported in EOS, please see keys directly under
                   'router_igmp'.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterInternetExit(AvdBase):
        class PoliciesItem(AvdBase):
            class ExitGroupsItem(AvdBase):
                _fields = ("_custom_data", "name")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None) -> None:
                    """
                    ExitGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "exit_groups")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            exit_groups: list[ExitGroupsItem] | None = None
            """
            The exit groups that are configured under a policy are strictly ordered, meaning an exit group
            appearing first has more priority than the exit group that follows it.
            """

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, exit_groups: list[ExitGroupsItem] | None = None) -> None:
                """
                PoliciesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    exit_groups:
                       The exit groups that are configured under a policy are strictly ordered, meaning an exit group
                       appearing first has more priority than the exit group that follows it.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ExitGroupsItem(AvdBase):
            class LocalConnectionsItem(AvdBase):
                _fields = ("_custom_data", "name")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None) -> None:
                    """
                    LocalConnectionsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "fib_default", "local_connections")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            fib_default: bool | None = None
            """
            Fib default exit indicates that the flows that select this exit will follow the default route
            available in the VRF of the flow.
            """
            local_connections: list[LocalConnectionsItem] | None = None
            """
            Local connections refer to connections configured under the `router_service_insertion`.
            The service-
            insertion module reports the health of the connection and the exit will qualify for use only when it
            is healthy.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                fib_default: bool | None = None,
                local_connections: list[LocalConnectionsItem] | None = None,
            ) -> None:
                """
                ExitGroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    fib_default:
                       Fib default exit indicates that the flows that select this exit will follow the default route
                       available in the VRF of the flow.
                    local_connections:
                       Local connections refer to connections configured under the `router_service_insertion`.
                       The service-
                       insertion module reports the health of the connection and the exit will qualify for use only when it
                       is healthy.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "policies", "exit_groups")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        policies: list[PoliciesItem] | None = None
        """Internet-exit policy represent a policy which can be attached to a virtual topology profile."""
        exit_groups: list[ExitGroupsItem] | None = None
        """
        Exit groups represent a group of exit options (connections).
        Traffic flows are load balanced in a
        round robin fashion across all the members (exits) of the exit-group.
        """

        def __init__(
            self, *, _custom_data: dict[str, Any] | None = None, policies: list[PoliciesItem] | None = None, exit_groups: list[ExitGroupsItem] | None = None
        ) -> None:
            """
            RouterInternetExit.

            Args:
            -----
                _custom_data: _custom_data
                policies: Internet-exit policy represent a policy which can be attached to a virtual topology profile.
                exit_groups:
                   Exit groups represent a group of exit options (connections).
                   Traffic flows are load balanced in a
                   round robin fashion across all the members (exits) of the exit-group.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterIsis(AvdBase):
        class Timers(AvdBase):
            class LocalConvergence(AvdBase):
                _fields = ("_custom_data", "protected_prefixes", "delay")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                protected_prefixes: bool | None = None
                delay: int | None = 10000
                """Delay in milliseconds."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, protected_prefixes: bool | None = None, delay: int | None = 10000) -> None:
                    """
                    LocalConvergence.

                    Args:
                    -----
                        _custom_data: _custom_data
                        protected_prefixes: protected_prefixes
                        delay: Delay in milliseconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "local_convergence")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            local_convergence: LocalConvergence | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, local_convergence: LocalConvergence | None = None) -> None:
                """
                Timers.

                Args:
                -----
                    _custom_data: _custom_data
                    local_convergence: local_convergence

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SetOverloadBit(AvdBase):
            class OnStartup(AvdBase):
                class WaitForBgp(AvdBase):
                    _fields = ("_custom_data", "enabled", "timeout")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None
                    timeout: int | None = None
                    """Number of seconds."""

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, timeout: int | None = None) -> None:
                        """
                        WaitForBgp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            timeout: Number of seconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "delay", "wait_for_bgp")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                delay: int | None = None
                """Number of seconds."""
                wait_for_bgp: WaitForBgp | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, delay: int | None = None, wait_for_bgp: WaitForBgp | None = None) -> None:
                    """
                    OnStartup.

                    Args:
                    -----
                        _custom_data: _custom_data
                        delay: Number of seconds.
                        wait_for_bgp: wait_for_bgp

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "enabled", "on_startup")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool | None = None
            on_startup: OnStartup | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, on_startup: OnStartup | None = None) -> None:
                """
                SetOverloadBit.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    on_startup: on_startup

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Authentication(AvdBase):
            class Both(AvdBase):
                class KeyIdsItem(AvdBase):
                    _fields = ("_custom_data", "id", "algorithm", "key_type", "key", "rfc_5310")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    id: Annotated[int, Min[1], Max[65535]] = None
                    """Configure authentication key-id."""
                    algorithm: Annotated[str, ValidValues["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None
                    key_type: Annotated[str, ValidValues["0", "7", "8a"]] = None
                    """Configure authentication key type."""
                    key: str = None
                    """Password string."""
                    rfc_5310: bool | None = None
                    """SHA digest computation according to rfc5310."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        id: Annotated[int, Min[1], Max[65535]] = None,
                        algorithm: Annotated[str, ValidValues["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None,
                        key_type: Annotated[str, ValidValues["0", "7", "8a"]] = None,
                        key: str = None,
                        rfc_5310: bool | None = None,
                    ) -> None:
                        """
                        KeyIdsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: Configure authentication key-id.
                            algorithm: algorithm
                            key_type: Configure authentication key type.
                            key: Password string.
                            rfc_5310: SHA digest computation according to rfc5310.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Sha(AvdBase):
                    _fields = ("_custom_data", "key_id")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    key_id: Annotated[int, Min[1], Max[65535]] = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, key_id: Annotated[int, Min[1], Max[65535]] = None) -> None:
                        """
                        Sha.

                        Args:
                        -----
                            _custom_data: _custom_data
                            key_id: key_id

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class SharedSecret(AvdBase):
                    _fields = ("_custom_data", "profile", "algorithm")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    profile: str = None
                    algorithm: Annotated[str, ValidValues["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        profile: str = None,
                        algorithm: Annotated[str, ValidValues["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None,
                    ) -> None:
                        """
                        SharedSecret.

                        Args:
                        -----
                            _custom_data: _custom_data
                            profile: profile
                            algorithm: algorithm

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "key_type", "key", "key_ids", "mode", "sha", "shared_secret", "rx_disabled")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                key_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = None
                """Configure authentication key type."""
                key: str | None = None
                """Password string. `key_type` is required for this setting."""
                key_ids: list[KeyIdsItem] | None = None
                mode: Annotated[str, ValidValues["md5", "sha", "text", "shared-secret"]] | None = None
                """Authentication mode."""
                sha: Sha | None = None
                """Required settings for authentication mode 'sha'."""
                shared_secret: SharedSecret | None = None
                """Required settings for authentication mode 'shared_secret'."""
                rx_disabled: bool | None = None
                """Disable authentication check on the receive side."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    key_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = None,
                    key: str | None = None,
                    key_ids: list[KeyIdsItem] | None = None,
                    mode: Annotated[str, ValidValues["md5", "sha", "text", "shared-secret"]] | None = None,
                    sha: Sha | None = None,
                    shared_secret: SharedSecret | None = None,
                    rx_disabled: bool | None = None,
                ) -> None:
                    """
                    Both.

                    Args:
                    -----
                        _custom_data: _custom_data
                        key_type: Configure authentication key type.
                        key: Password string. `key_type` is required for this setting.
                        key_ids: key_ids
                        mode: Authentication mode.
                        sha: Required settings for authentication mode 'sha'.
                        shared_secret: Required settings for authentication mode 'shared_secret'.
                        rx_disabled: Disable authentication check on the receive side.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Level1(AvdBase):
                class KeyIdsItem(AvdBase):
                    _fields = ("_custom_data", "id", "algorithm", "key_type", "key", "rfc_5310")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    id: Annotated[int, Min[1], Max[65535]] = None
                    """Configure authentication key-id."""
                    algorithm: Annotated[str, ValidValues["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None
                    key_type: Annotated[str, ValidValues["0", "7", "8a"]] = None
                    """Configure authentication key type."""
                    key: str = None
                    """Password string."""
                    rfc_5310: bool | None = None
                    """SHA digest computation according to rfc5310."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        id: Annotated[int, Min[1], Max[65535]] = None,
                        algorithm: Annotated[str, ValidValues["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None,
                        key_type: Annotated[str, ValidValues["0", "7", "8a"]] = None,
                        key: str = None,
                        rfc_5310: bool | None = None,
                    ) -> None:
                        """
                        KeyIdsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: Configure authentication key-id.
                            algorithm: algorithm
                            key_type: Configure authentication key type.
                            key: Password string.
                            rfc_5310: SHA digest computation according to rfc5310.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Sha(AvdBase):
                    _fields = ("_custom_data", "key_id")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    key_id: Annotated[int, Min[1], Max[65535]] = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, key_id: Annotated[int, Min[1], Max[65535]] = None) -> None:
                        """
                        Sha.

                        Args:
                        -----
                            _custom_data: _custom_data
                            key_id: key_id

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class SharedSecret(AvdBase):
                    _fields = ("_custom_data", "profile", "algorithm")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    profile: str = None
                    algorithm: Annotated[str, ValidValues["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        profile: str = None,
                        algorithm: Annotated[str, ValidValues["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None,
                    ) -> None:
                        """
                        SharedSecret.

                        Args:
                        -----
                            _custom_data: _custom_data
                            profile: profile
                            algorithm: algorithm

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "key_type", "key", "key_ids", "mode", "sha", "shared_secret", "rx_disabled")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                key_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = None
                """Configure authentication key type."""
                key: str | None = None
                """Password string. `key_type` is required for this setting."""
                key_ids: list[KeyIdsItem] | None = None
                mode: Annotated[str, ValidValues["md5", "sha", "text", "shared-secret"]] | None = None
                """Authentication mode."""
                sha: Sha | None = None
                """Required settings for authentication mode 'sha'."""
                shared_secret: SharedSecret | None = None
                """Required settings for authentication mode 'shared_secret'."""
                rx_disabled: bool | None = None
                """Disable authentication check on the receive side."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    key_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = None,
                    key: str | None = None,
                    key_ids: list[KeyIdsItem] | None = None,
                    mode: Annotated[str, ValidValues["md5", "sha", "text", "shared-secret"]] | None = None,
                    sha: Sha | None = None,
                    shared_secret: SharedSecret | None = None,
                    rx_disabled: bool | None = None,
                ) -> None:
                    """
                    Level1.

                    Args:
                    -----
                        _custom_data: _custom_data
                        key_type: Configure authentication key type.
                        key: Password string. `key_type` is required for this setting.
                        key_ids: key_ids
                        mode: Authentication mode.
                        sha: Required settings for authentication mode 'sha'.
                        shared_secret: Required settings for authentication mode 'shared_secret'.
                        rx_disabled: Disable authentication check on the receive side.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Level2(AvdBase):
                class KeyIdsItem(AvdBase):
                    _fields = ("_custom_data", "id", "algorithm", "key_type", "key", "rfc_5310")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    id: Annotated[int, Min[1], Max[65535]] = None
                    """Configure authentication key-id."""
                    algorithm: Annotated[str, ValidValues["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None
                    key_type: Annotated[str, ValidValues["0", "7", "8a"]] = None
                    """Configure authentication key type."""
                    key: str = None
                    """Password string."""
                    rfc_5310: bool | None = None
                    """SHA digest computation according to rfc5310."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        id: Annotated[int, Min[1], Max[65535]] = None,
                        algorithm: Annotated[str, ValidValues["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None,
                        key_type: Annotated[str, ValidValues["0", "7", "8a"]] = None,
                        key: str = None,
                        rfc_5310: bool | None = None,
                    ) -> None:
                        """
                        KeyIdsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: Configure authentication key-id.
                            algorithm: algorithm
                            key_type: Configure authentication key type.
                            key: Password string.
                            rfc_5310: SHA digest computation according to rfc5310.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Sha(AvdBase):
                    _fields = ("_custom_data", "key_id")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    key_id: Annotated[int, Min[1], Max[65535]] = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, key_id: Annotated[int, Min[1], Max[65535]] = None) -> None:
                        """
                        Sha.

                        Args:
                        -----
                            _custom_data: _custom_data
                            key_id: key_id

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class SharedSecret(AvdBase):
                    _fields = ("_custom_data", "profile", "algorithm")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    profile: str = None
                    algorithm: Annotated[str, ValidValues["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        profile: str = None,
                        algorithm: Annotated[str, ValidValues["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None,
                    ) -> None:
                        """
                        SharedSecret.

                        Args:
                        -----
                            _custom_data: _custom_data
                            profile: profile
                            algorithm: algorithm

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "key_type", "key", "key_ids", "mode", "sha", "shared_secret", "rx_disabled")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                key_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = None
                """Configure authentication key type."""
                key: str | None = None
                """Password string. `key_type` is required for this setting."""
                key_ids: list[KeyIdsItem] | None = None
                mode: Annotated[str, ValidValues["md5", "sha", "text", "shared-secret"]] | None = None
                """Authentication mode."""
                sha: Sha | None = None
                """Required settings for authentication mode 'sha'."""
                shared_secret: SharedSecret | None = None
                """Required settings for authentication mode 'shared_secret'."""
                rx_disabled: bool | None = None
                """Disable authentication check on the receive side."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    key_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = None,
                    key: str | None = None,
                    key_ids: list[KeyIdsItem] | None = None,
                    mode: Annotated[str, ValidValues["md5", "sha", "text", "shared-secret"]] | None = None,
                    sha: Sha | None = None,
                    shared_secret: SharedSecret | None = None,
                    rx_disabled: bool | None = None,
                ) -> None:
                    """
                    Level2.

                    Args:
                    -----
                        _custom_data: _custom_data
                        key_type: Configure authentication key type.
                        key: Password string. `key_type` is required for this setting.
                        key_ids: key_ids
                        mode: Authentication mode.
                        sha: Required settings for authentication mode 'sha'.
                        shared_secret: Required settings for authentication mode 'shared_secret'.
                        rx_disabled: Disable authentication check on the receive side.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "both", "level_1", "level_2")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            both: Both | None = None
            """
            Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
            'level_2' settings.
            """
            level_1: Level1 | None = None
            """Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings."""
            level_2: Level2 | None = None
            """Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, both: Both | None = None, level_1: Level1 | None = None, level_2: Level2 | None = None
            ) -> None:
                """
                Authentication.

                Args:
                -----
                    _custom_data: _custom_data
                    both:
                       Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
                       'level_2' settings.
                    level_1: Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings.
                    level_2: Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Advertise(AvdBase):
            _fields = ("_custom_data", "passive_only")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            passive_only: bool | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, passive_only: bool | None = None) -> None:
                """
                Advertise.

                Args:
                -----
                    _custom_data: _custom_data
                    passive_only: passive_only

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class RedistributeRoutesItem(AvdBase):
            _fields = ("_custom_data", "source_protocol", "route_map", "include_leaked", "ospf_route_type")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            source_protocol: Annotated[str, ValidValues["bgp", "connected", "isis", "ospf", "ospfv3", "static"]] = None
            route_map: str | None = None
            """Route-map name."""
            include_leaked: bool | None = None
            ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external"]] | None = None
            """ospf_route_type is required with source_protocols 'ospf' and 'ospfv3'."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                source_protocol: Annotated[str, ValidValues["bgp", "connected", "isis", "ospf", "ospfv3", "static"]] = None,
                route_map: str | None = None,
                include_leaked: bool | None = None,
                ospf_route_type: Annotated[str, ValidValues["external", "internal", "nssa-external"]] | None = None,
            ) -> None:
                """
                RedistributeRoutesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    source_protocol: source_protocol
                    route_map: Route-map name.
                    include_leaked: include_leaked
                    ospf_route_type: ospf_route_type is required with source_protocols 'ospf' and 'ospfv3'.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyIpv4(AvdBase):
            class FastRerouteTiLfa(AvdBase):
                class Srlg(AvdBase):
                    _fields = ("_custom_data", "enable", "strict")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enable: bool | None = None
                    strict: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, enable: bool | None = None, strict: bool | None = None) -> None:
                        """
                        Srlg.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enable: enable
                            strict: strict

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "mode", "level", "srlg")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                mode: Annotated[str, ValidValues["link-protection", "node-protection"]] | None = None
                level: Annotated[str, ValidValues["level-1", "level-2"]] | None = None
                srlg: Srlg | None = None
                """Shared Risk Link Group."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    mode: Annotated[str, ValidValues["link-protection", "node-protection"]] | None = None,
                    level: Annotated[str, ValidValues["level-1", "level-2"]] | None = None,
                    srlg: Srlg | None = None,
                ) -> None:
                    """
                    FastRerouteTiLfa.

                    Args:
                    -----
                        _custom_data: _custom_data
                        mode: mode
                        level: level
                        srlg: Shared Risk Link Group.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class TunnelSourceLabeledUnicast(AvdBase):
                _fields = ("_custom_data", "enabled", "rcf")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                rcf: str | None = None
                """Route Control Function."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, rcf: str | None = None) -> None:
                    """
                    TunnelSourceLabeledUnicast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        rcf: Route Control Function.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "enabled", "maximum_paths", "bfd_all_interfaces", "fast_reroute_ti_lfa", "tunnel_source_labeled_unicast")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool = None
            maximum_paths: Annotated[int, Min[1], Max[128]] | None = None
            bfd_all_interfaces: bool | None = None
            """Enable BFD on all interfaces."""
            fast_reroute_ti_lfa: FastRerouteTiLfa | None = None
            tunnel_source_labeled_unicast: TunnelSourceLabeledUnicast | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enabled: bool = None,
                maximum_paths: Annotated[int, Min[1], Max[128]] | None = None,
                bfd_all_interfaces: bool | None = None,
                fast_reroute_ti_lfa: FastRerouteTiLfa | None = None,
                tunnel_source_labeled_unicast: TunnelSourceLabeledUnicast | None = None,
            ) -> None:
                """
                AddressFamilyIpv4.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    maximum_paths: maximum_paths
                    bfd_all_interfaces: Enable BFD on all interfaces.
                    fast_reroute_ti_lfa: fast_reroute_ti_lfa
                    tunnel_source_labeled_unicast: tunnel_source_labeled_unicast

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyIpv6(AvdBase):
            class FastRerouteTiLfa(AvdBase):
                class Srlg(AvdBase):
                    _fields = ("_custom_data", "enable", "strict")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enable: bool | None = None
                    strict: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, enable: bool | None = None, strict: bool | None = None) -> None:
                        """
                        Srlg.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enable: enable
                            strict: strict

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "mode", "level", "srlg")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                mode: Annotated[str, ValidValues["link-protection", "node-protection"]] | None = None
                level: Annotated[str, ValidValues["level-1", "level-2"]] | None = None
                """Optional, default is to protect all levels."""
                srlg: Srlg | None = None
                """Shared Risk Link Group."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    mode: Annotated[str, ValidValues["link-protection", "node-protection"]] | None = None,
                    level: Annotated[str, ValidValues["level-1", "level-2"]] | None = None,
                    srlg: Srlg | None = None,
                ) -> None:
                    """
                    FastRerouteTiLfa.

                    Args:
                    -----
                        _custom_data: _custom_data
                        mode: mode
                        level: Optional, default is to protect all levels.
                        srlg: Shared Risk Link Group.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "enabled", "maximum_paths", "bfd_all_interfaces", "fast_reroute_ti_lfa")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool = None
            maximum_paths: Annotated[int, Min[1], Max[128]] | None = None
            bfd_all_interfaces: bool | None = None
            """Enable BFD on all interfaces."""
            fast_reroute_ti_lfa: FastRerouteTiLfa | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enabled: bool = None,
                maximum_paths: Annotated[int, Min[1], Max[128]] | None = None,
                bfd_all_interfaces: bool | None = None,
                fast_reroute_ti_lfa: FastRerouteTiLfa | None = None,
            ) -> None:
                """
                AddressFamilyIpv6.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    maximum_paths: maximum_paths
                    bfd_all_interfaces: Enable BFD on all interfaces.
                    fast_reroute_ti_lfa: fast_reroute_ti_lfa

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SegmentRoutingMpls(AvdBase):
            class PrefixSegmentsItem(AvdBase):
                _fields = ("_custom_data", "prefix", "index")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                prefix: str | None = None
                index: int | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, prefix: str | None = None, index: int | None = None) -> None:
                    """
                    PrefixSegmentsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefix: prefix
                        index: index

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "enabled", "router_id", "prefix_segments")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool | None = None
            router_id: str | None = None
            prefix_segments: list[PrefixSegmentsItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enabled: bool | None = None,
                router_id: str | None = None,
                prefix_segments: list[PrefixSegmentsItem] | None = None,
            ) -> None:
                """
                SegmentRoutingMpls.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    router_id: router_id
                    prefix_segments: prefix_segments

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SpfInterval(AvdBase):
            _fields = ("_custom_data", "interval", "interval_unit", "wait_interval", "hold_interval")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            interval: int | None = None
            """
            Maximum interval between two SPFs in seconds or milliseconds.
            Range in seconds: <1-300>
            Range in
            milliseconds: <1-300000>
            """
            interval_unit: Annotated[str, ValidValues["seconds", "milliseconds"]] | None = None
            """If interval unit is not defined EOS takes `seconds` by default."""
            wait_interval: Annotated[int, Min[1], Max[300000]] | None = None
            """Initial wait interval for SPF in milliseconds."""
            hold_interval: Annotated[int, Min[1], Max[300000]] | None = None
            """Hold interval between the first and second SPF runs in milliseconds."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                interval: int | None = None,
                interval_unit: Annotated[str, ValidValues["seconds", "milliseconds"]] | None = None,
                wait_interval: Annotated[int, Min[1], Max[300000]] | None = None,
                hold_interval: Annotated[int, Min[1], Max[300000]] | None = None,
            ) -> None:
                """
                SpfInterval.

                Args:
                -----
                    _custom_data: _custom_data
                    interval:
                       Maximum interval between two SPFs in seconds or milliseconds.
                       Range in seconds: <1-300>
                       Range in
                       milliseconds: <1-300000>
                    interval_unit: If interval unit is not defined EOS takes `seconds` by default.
                    wait_interval: Initial wait interval for SPF in milliseconds.
                    hold_interval: Hold interval between the first and second SPF runs in milliseconds.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class GracefulRestart(AvdBase):
            class T2(AvdBase):
                _fields = ("_custom_data", "level_1_wait_time", "level_2_wait_time")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                level_1_wait_time: Annotated[int, Min[5], Max[300]] | None = None
                """Level-1 LSP database sync wait time in seconds."""
                level_2_wait_time: Annotated[int, Min[5], Max[300]] | None = None
                """Level-2 LSP database sync wait time in seconds."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    level_1_wait_time: Annotated[int, Min[5], Max[300]] | None = None,
                    level_2_wait_time: Annotated[int, Min[5], Max[300]] | None = None,
                ) -> None:
                    """
                    T2.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level_1_wait_time: Level-1 LSP database sync wait time in seconds.
                        level_2_wait_time: Level-2 LSP database sync wait time in seconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "enabled", "restart_hold_time", "t2")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool | None = None
            restart_hold_time: Annotated[int, Min[5], Max[300]] | None = None
            """Number of seconds."""
            t2: T2 | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enabled: bool | None = None,
                restart_hold_time: Annotated[int, Min[5], Max[300]] | None = None,
                t2: T2 | None = None,
            ) -> None:
                """
                GracefulRestart.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    restart_hold_time: Number of seconds.
                    t2: t2

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "instance",
            "net",
            "router_id",
            "is_type",
            "log_adjacency_changes",
            "mpls_ldp_sync_default",
            "timers",
            "set_overload_bit",
            "authentication",
            "advertise",
            "redistribute_routes",
            "address_family_ipv4",
            "address_family_ipv6",
            "segment_routing_mpls",
            "spf_interval",
            "graceful_restart",
            "eos_cli",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        instance: str = None
        """ISIS Instance Name."""
        net: str | None = None
        """CLNS Address like "49.0001.0001.0000.0001.00"."""
        router_id: str | None = None
        """IPv4 Address."""
        is_type: Annotated[str, ValidValues["level-1", "level-1-2", "level-2"]] | None = None
        log_adjacency_changes: bool | None = None
        mpls_ldp_sync_default: bool | None = None
        timers: Timers | None = None
        set_overload_bit: SetOverloadBit | None = None
        authentication: Authentication | None = None
        advertise: Advertise | None = None
        redistribute_routes: list[RedistributeRoutesItem] | None = None
        address_family_ipv4: AddressFamilyIpv4 | None = None
        address_family_ipv6: AddressFamilyIpv6 | None = None
        segment_routing_mpls: SegmentRoutingMpls | None = None
        spf_interval: SpfInterval | None = None
        graceful_restart: GracefulRestart | None = None
        eos_cli: str | None = None
        """Multiline EOS CLI rendered directly on the router isis in the final EOS configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            instance: str = None,
            net: str | None = None,
            router_id: str | None = None,
            is_type: Annotated[str, ValidValues["level-1", "level-1-2", "level-2"]] | None = None,
            log_adjacency_changes: bool | None = None,
            mpls_ldp_sync_default: bool | None = None,
            timers: Timers | None = None,
            set_overload_bit: SetOverloadBit | None = None,
            authentication: Authentication | None = None,
            advertise: Advertise | None = None,
            redistribute_routes: list[RedistributeRoutesItem] | None = None,
            address_family_ipv4: AddressFamilyIpv4 | None = None,
            address_family_ipv6: AddressFamilyIpv6 | None = None,
            segment_routing_mpls: SegmentRoutingMpls | None = None,
            spf_interval: SpfInterval | None = None,
            graceful_restart: GracefulRestart | None = None,
            eos_cli: str | None = None,
        ) -> None:
            """
            RouterIsis.

            Args:
            -----
                _custom_data: _custom_data
                instance: ISIS Instance Name.
                net: CLNS Address like "49.0001.0001.0000.0001.00".
                router_id: IPv4 Address.
                is_type: is_type
                log_adjacency_changes: log_adjacency_changes
                mpls_ldp_sync_default: mpls_ldp_sync_default
                timers: timers
                set_overload_bit: set_overload_bit
                authentication: authentication
                advertise: advertise
                redistribute_routes: redistribute_routes
                address_family_ipv4: address_family_ipv4
                address_family_ipv6: address_family_ipv6
                segment_routing_mpls: segment_routing_mpls
                spf_interval: spf_interval
                graceful_restart: graceful_restart
                eos_cli: Multiline EOS CLI rendered directly on the router isis in the final EOS configuration.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterL2Vpn(AvdBase):
        class ArpProxy(AvdBase):
            _fields = ("_custom_data", "prefix_list")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            prefix_list: str | None = None
            """Prefix-list name. ARP Proxying is disabled for IPv4 addresses defined in the prefix-list."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, prefix_list: str | None = None) -> None:
                """
                ArpProxy.

                Args:
                -----
                    _custom_data: _custom_data
                    prefix_list: Prefix-list name. ARP Proxying is disabled for IPv4 addresses defined in the prefix-list.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class NdProxy(AvdBase):
            _fields = ("_custom_data", "prefix_list")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            prefix_list: str | None = None
            """
            Prefix-list name. Neighbor Discovery Proxying is disabled for IPv6 addresses defined in the prefix-
            list.
            """

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, prefix_list: str | None = None) -> None:
                """
                NdProxy.

                Args:
                -----
                    _custom_data: _custom_data
                    prefix_list:
                       Prefix-list name. Neighbor Discovery Proxying is disabled for IPv6 addresses defined in the prefix-
                       list.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "arp_learning_bridged",
            "arp_proxy",
            "arp_selective_install",
            "nd_learning_bridged",
            "nd_proxy",
            "nd_rs_flooding_disabled",
            "virtual_router_nd_ra_flooding_disabled",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        arp_learning_bridged: bool | None = None
        arp_proxy: ArpProxy | None = None
        arp_selective_install: bool | None = None
        nd_learning_bridged: bool | None = None
        nd_proxy: NdProxy | None = None
        nd_rs_flooding_disabled: bool | None = None
        virtual_router_nd_ra_flooding_disabled: bool | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            arp_learning_bridged: bool | None = None,
            arp_proxy: ArpProxy | None = None,
            arp_selective_install: bool | None = None,
            nd_learning_bridged: bool | None = None,
            nd_proxy: NdProxy | None = None,
            nd_rs_flooding_disabled: bool | None = None,
            virtual_router_nd_ra_flooding_disabled: bool | None = None,
        ) -> None:
            """
            RouterL2Vpn.

            Args:
            -----
                _custom_data: _custom_data
                arp_learning_bridged: arp_learning_bridged
                arp_proxy: arp_proxy
                arp_selective_install: arp_selective_install
                nd_learning_bridged: nd_learning_bridged
                nd_proxy: nd_proxy
                nd_rs_flooding_disabled: nd_rs_flooding_disabled
                virtual_router_nd_ra_flooding_disabled: virtual_router_nd_ra_flooding_disabled

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterMsdp(AvdBase):
        class GroupLimitsItem(AvdBase):
            _fields = ("_custom_data", "source_prefix", "limit")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            source_prefix: str = None
            """Source address prefix."""
            limit: Annotated[int, Max[40000]] = None
            """Limit for SAs matching the source address prefix."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, source_prefix: str = None, limit: Annotated[int, Max[40000]] = None) -> None:
                """
                GroupLimitsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    source_prefix: Source address prefix.
                    limit: Limit for SAs matching the source address prefix.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PeersItem(AvdBase):
            class DefaultPeer(AvdBase):
                _fields = ("_custom_data", "enabled", "prefix_list")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                prefix_list: str | None = None
                """Prefix list to filter source of SA messages."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, prefix_list: str | None = None) -> None:
                    """
                    DefaultPeer.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        prefix_list: Prefix list to filter source of SA messages.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class MeshGroupsItem(AvdBase):
                _fields = ("_custom_data", "name")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Mesh group name."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None) -> None:
                    """
                    MeshGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Mesh group name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Keepalive(AvdBase):
                _fields = ("_custom_data", "keepalive_timer", "hold_timer")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                keepalive_timer: Annotated[int, Min[1], Max[65535]] = None
                hold_timer: Annotated[int, Min[1], Max[65535]] = None
                """Must be greater than keepalive timer."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    keepalive_timer: Annotated[int, Min[1], Max[65535]] = None,
                    hold_timer: Annotated[int, Min[1], Max[65535]] = None,
                ) -> None:
                    """
                    Keepalive.

                    Args:
                    -----
                        _custom_data: _custom_data
                        keepalive_timer: keepalive_timer
                        hold_timer: Must be greater than keepalive timer.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class SaFilter(AvdBase):
                _fields = ("_custom_data", "in_list", "out_list")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                in_list: str | None = None
                """ACL to filter inbound SA messages."""
                out_list: str | None = None
                """ACL to filter outbound SA messages."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, in_list: str | None = None, out_list: str | None = None) -> None:
                    """
                    SaFilter.

                    Args:
                    -----
                        _custom_data: _custom_data
                        in_list: ACL to filter inbound SA messages.
                        out_list: ACL to filter outbound SA messages.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = (
                "_custom_data",
                "ipv4_address",
                "default_peer",
                "local_interface",
                "description",
                "disabled",
                "sa_limit",
                "mesh_groups",
                "keepalive",
                "sa_filter",
            )
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv4_address: str = None
            """Peer IP Address."""
            default_peer: DefaultPeer | None = None
            local_interface: str | None = None
            description: str | None = None
            disabled: bool | None = None
            """Disable the MSDP peer."""
            sa_limit: Annotated[int, Max[40000]] | None = None
            """Maximum number of SA messages allowed in cache."""
            mesh_groups: list[MeshGroupsItem] | None = None
            keepalive: Keepalive | None = None
            sa_filter: SaFilter | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                ipv4_address: str = None,
                default_peer: DefaultPeer | None = None,
                local_interface: str | None = None,
                description: str | None = None,
                disabled: bool | None = None,
                sa_limit: Annotated[int, Max[40000]] | None = None,
                mesh_groups: list[MeshGroupsItem] | None = None,
                keepalive: Keepalive | None = None,
                sa_filter: SaFilter | None = None,
            ) -> None:
                """
                PeersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4_address: Peer IP Address.
                    default_peer: default_peer
                    local_interface: local_interface
                    description: description
                    disabled: Disable the MSDP peer.
                    sa_limit: Maximum number of SA messages allowed in cache.
                    mesh_groups: mesh_groups
                    keepalive: keepalive
                    sa_filter: sa_filter

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrfsItem(AvdBase):
            class GroupLimitsItem(AvdBase):
                _fields = ("_custom_data", "source_prefix", "limit")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                source_prefix: str = None
                """Source address prefix."""
                limit: Annotated[int, Max[40000]] = None
                """Limit for SAs matching the source address prefix."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, source_prefix: str = None, limit: Annotated[int, Max[40000]] = None) -> None:
                    """
                    GroupLimitsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_prefix: Source address prefix.
                        limit: Limit for SAs matching the source address prefix.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeersItem(AvdBase):
                class DefaultPeer(AvdBase):
                    _fields = ("_custom_data", "enabled", "prefix_list")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None
                    prefix_list: str | None = None
                    """Prefix list to filter source of SA messages."""

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, prefix_list: str | None = None) -> None:
                        """
                        DefaultPeer.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            prefix_list: Prefix list to filter source of SA messages.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class MeshGroupsItem(AvdBase):
                    _fields = ("_custom_data", "name")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    name: str = None
                    """Mesh group name."""

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None) -> None:
                        """
                        MeshGroupsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: Mesh group name.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Keepalive(AvdBase):
                    _fields = ("_custom_data", "keepalive_timer", "hold_timer")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    keepalive_timer: Annotated[int, Min[1], Max[65535]] = None
                    hold_timer: Annotated[int, Min[1], Max[65535]] = None
                    """Must be greater than keepalive timer."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        keepalive_timer: Annotated[int, Min[1], Max[65535]] = None,
                        hold_timer: Annotated[int, Min[1], Max[65535]] = None,
                    ) -> None:
                        """
                        Keepalive.

                        Args:
                        -----
                            _custom_data: _custom_data
                            keepalive_timer: keepalive_timer
                            hold_timer: Must be greater than keepalive timer.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class SaFilter(AvdBase):
                    _fields = ("_custom_data", "in_list", "out_list")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    in_list: str | None = None
                    """ACL to filter inbound SA messages."""
                    out_list: str | None = None
                    """ACL to filter outbound SA messages."""

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, in_list: str | None = None, out_list: str | None = None) -> None:
                        """
                        SaFilter.

                        Args:
                        -----
                            _custom_data: _custom_data
                            in_list: ACL to filter inbound SA messages.
                            out_list: ACL to filter outbound SA messages.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = (
                    "_custom_data",
                    "ipv4_address",
                    "default_peer",
                    "local_interface",
                    "description",
                    "disabled",
                    "sa_limit",
                    "mesh_groups",
                    "keepalive",
                    "sa_filter",
                )
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ipv4_address: str = None
                """Peer IP Address."""
                default_peer: DefaultPeer | None = None
                local_interface: str | None = None
                description: str | None = None
                disabled: bool | None = None
                """Disable the MSDP peer."""
                sa_limit: Annotated[int, Max[40000]] | None = None
                """Maximum number of SA messages allowed in cache."""
                mesh_groups: list[MeshGroupsItem] | None = None
                keepalive: Keepalive | None = None
                sa_filter: SaFilter | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    ipv4_address: str = None,
                    default_peer: DefaultPeer | None = None,
                    local_interface: str | None = None,
                    description: str | None = None,
                    disabled: bool | None = None,
                    sa_limit: Annotated[int, Max[40000]] | None = None,
                    mesh_groups: list[MeshGroupsItem] | None = None,
                    keepalive: Keepalive | None = None,
                    sa_filter: SaFilter | None = None,
                ) -> None:
                    """
                    PeersItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ipv4_address: Peer IP Address.
                        default_peer: default_peer
                        local_interface: local_interface
                        description: description
                        disabled: Disable the MSDP peer.
                        sa_limit: Maximum number of SA messages allowed in cache.
                        mesh_groups: mesh_groups
                        keepalive: keepalive
                        sa_filter: sa_filter

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = (
                "_custom_data",
                "name",
                "originator_id_local_interface",
                "rejected_limit",
                "forward_register_packets",
                "connection_retry_interval",
                "group_limits",
                "peers",
            )
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """VRF name."""
            originator_id_local_interface: str | None = None
            """Interface to use for originator ID."""
            rejected_limit: Annotated[int, Max[40000]] | None = None
            """Maximum number of rejected SA messages allowed in cache."""
            forward_register_packets: bool | None = None
            connection_retry_interval: Annotated[int, Min[1], Max[65535]] | None = None
            group_limits: list[GroupLimitsItem] | None = None
            peers: list[PeersItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                originator_id_local_interface: str | None = None,
                rejected_limit: Annotated[int, Max[40000]] | None = None,
                forward_register_packets: bool | None = None,
                connection_retry_interval: Annotated[int, Min[1], Max[65535]] | None = None,
                group_limits: list[GroupLimitsItem] | None = None,
                peers: list[PeersItem] | None = None,
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF name.
                    originator_id_local_interface: Interface to use for originator ID.
                    rejected_limit: Maximum number of rejected SA messages allowed in cache.
                    forward_register_packets: forward_register_packets
                    connection_retry_interval: connection_retry_interval
                    group_limits: group_limits
                    peers: peers

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "originator_id_local_interface",
            "rejected_limit",
            "forward_register_packets",
            "connection_retry_interval",
            "group_limits",
            "peers",
            "vrfs",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        originator_id_local_interface: str | None = None
        """Interface to use for originator ID."""
        rejected_limit: Annotated[int, Max[40000]] | None = None
        """Maximum number of rejected SA messages allowed in cache."""
        forward_register_packets: bool | None = None
        connection_retry_interval: Annotated[int, Min[1], Max[65535]] | None = None
        group_limits: list[GroupLimitsItem] | None = None
        peers: list[PeersItem] | None = None
        vrfs: list[VrfsItem] | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            originator_id_local_interface: str | None = None,
            rejected_limit: Annotated[int, Max[40000]] | None = None,
            forward_register_packets: bool | None = None,
            connection_retry_interval: Annotated[int, Min[1], Max[65535]] | None = None,
            group_limits: list[GroupLimitsItem] | None = None,
            peers: list[PeersItem] | None = None,
            vrfs: list[VrfsItem] | None = None,
        ) -> None:
            """
            RouterMsdp.

            Args:
            -----
                _custom_data: _custom_data
                originator_id_local_interface: Interface to use for originator ID.
                rejected_limit: Maximum number of rejected SA messages allowed in cache.
                forward_register_packets: forward_register_packets
                connection_retry_interval: connection_retry_interval
                group_limits: group_limits
                peers: peers
                vrfs: vrfs

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterMulticast(AvdBase):
        class Ipv4(AvdBase):
            class Counters(AvdBase):
                _fields = ("_custom_data", "rate_period_decay")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                rate_period_decay: Annotated[int, Max[600]] | None = None
                """Rate in seconds."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, rate_period_decay: Annotated[int, Max[600]] | None = None) -> None:
                    """
                    Counters.

                    Args:
                    -----
                        _custom_data: _custom_data
                        rate_period_decay: Rate in seconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Rpf(AvdBase):
                class RoutesItem(AvdBase):
                    class DestinationsItem(AvdBase):
                        _fields = ("_custom_data", "nexthop", "distance")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        nexthop: str = None
                        """Next-hop IP address or interface name."""
                        distance: Annotated[int, Min[1], Max[255]] | None = None
                        """Administrative distance for this route."""

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | None = None, nexthop: str = None, distance: Annotated[int, Min[1], Max[255]] | None = None
                        ) -> None:
                            """
                            DestinationsItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                nexthop: Next-hop IP address or interface name.
                                distance: Administrative distance for this route.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "source_prefix", "destinations")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    source_prefix: str = None
                    """Source address A.B.C.D or Source prefix A.B.C.D/E."""
                    destinations: list[DestinationsItem] = None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, source_prefix: str = None, destinations: list[DestinationsItem] = None
                    ) -> None:
                        """
                        RoutesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source_prefix: Source address A.B.C.D or Source prefix A.B.C.D/E.
                            destinations: destinations

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "routes")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                routes: list[RoutesItem] | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, routes: list[RoutesItem] | None = None) -> None:
                    """
                    Rpf.

                    Args:
                    -----
                        _custom_data: _custom_data
                        routes: routes

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "activity_polling_interval", "counters", "routing", "multipath", "software_forwarding", "rpf")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            activity_polling_interval: Annotated[int, Min[1], Max[60]] | None = None
            """MFIB entry activity polling interval."""
            counters: Counters | None = None
            routing: bool | None = None
            multipath: Annotated[str, ValidValues["none", "deterministic", "deterministic color", "deterministic router-id"]] | None = None
            software_forwarding: Annotated[str, ValidValues["kernel", "sfe"]] | None = None
            rpf: Rpf | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                activity_polling_interval: Annotated[int, Min[1], Max[60]] | None = None,
                counters: Counters | None = None,
                routing: bool | None = None,
                multipath: Annotated[str, ValidValues["none", "deterministic", "deterministic color", "deterministic router-id"]] | None = None,
                software_forwarding: Annotated[str, ValidValues["kernel", "sfe"]] | None = None,
                rpf: Rpf | None = None,
            ) -> None:
                """
                Ipv4.

                Args:
                -----
                    _custom_data: _custom_data
                    activity_polling_interval: MFIB entry activity polling interval.
                    counters: counters
                    routing: routing
                    multipath: multipath
                    software_forwarding: software_forwarding
                    rpf: rpf

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6(AvdBase):
            _fields = ("_custom_data", "activity_polling_interval")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            activity_polling_interval: Annotated[int, Min[1], Max[60]] | None = None
            """MFIB entry activity polling interval."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, activity_polling_interval: Annotated[int, Min[1], Max[60]] | None = None) -> None:
                """
                Ipv6.

                Args:
                -----
                    _custom_data: _custom_data
                    activity_polling_interval: MFIB entry activity polling interval.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrfsItem(AvdBase):
            class Ipv4(AvdBase):
                _fields = ("_custom_data", "routing")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                routing: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, routing: bool | None = None) -> None:
                    """
                    Ipv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        routing: routing

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "ipv4")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            ipv4: Ipv4 | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, ipv4: Ipv4 | None = None) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    ipv4: ipv4

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "ipv4", "ipv6", "vrfs")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        ipv4: Ipv4 | None = None
        ipv6: Ipv6 | None = None
        vrfs: list[VrfsItem] | None = None

        def __init__(
            self, *, _custom_data: dict[str, Any] | None = None, ipv4: Ipv4 | None = None, ipv6: Ipv6 | None = None, vrfs: list[VrfsItem] | None = None
        ) -> None:
            """
            RouterMulticast.

            Args:
            -----
                _custom_data: _custom_data
                ipv4: ipv4
                ipv6: ipv6
                vrfs: vrfs

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterOspf(AvdBase):
        class ProcessIdsItem(AvdBase):
            class Distance(AvdBase):
                _fields = ("_custom_data", "external", "inter_area", "intra_area")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                external: Annotated[int, Min[1], Max[255]] | None = None
                inter_area: Annotated[int, Min[1], Max[255]] | None = None
                intra_area: Annotated[int, Min[1], Max[255]] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    external: Annotated[int, Min[1], Max[255]] | None = None,
                    inter_area: Annotated[int, Min[1], Max[255]] | None = None,
                    intra_area: Annotated[int, Min[1], Max[255]] | None = None,
                ) -> None:
                    """
                    Distance.

                    Args:
                    -----
                        _custom_data: _custom_data
                        external: external
                        inter_area: inter_area
                        intra_area: intra_area

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NetworkPrefixesItem(AvdBase):
                _fields = ("_custom_data", "ipv4_prefix", "area")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ipv4_prefix: str = None
                area: str | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, ipv4_prefix: str = None, area: str | None = None) -> None:
                    """
                    NetworkPrefixesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ipv4_prefix: ipv4_prefix
                        area: area

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class DistributeListIn(AvdBase):
                _fields = ("_custom_data", "route_map")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                route_map: str | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, route_map: str | None = None) -> None:
                    """
                    DistributeListIn.

                    Args:
                    -----
                        _custom_data: _custom_data
                        route_map: route_map

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Timers(AvdBase):
                class Lsa(AvdBase):
                    class TxDelay(AvdBase):
                        _fields = ("_custom_data", "initial", "min", "max")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        initial: Annotated[int, Max[600000]] | None = None
                        """Delay to generate first occurrence of LSA in msecs."""
                        min: Annotated[int, Min[1], Max[600000]] | None = None
                        """Min delay between originating the same LSA in msecs."""
                        max: Annotated[int, Min[1], Max[600000]] | None = None
                        """1-600000 Maximum delay between originating the same LSA in msec."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            initial: Annotated[int, Max[600000]] | None = None,
                            min: Annotated[int, Min[1], Max[600000]] | None = None,
                            max: Annotated[int, Min[1], Max[600000]] | None = None,
                        ) -> None:
                            """
                            TxDelay.

                            Args:
                            -----
                                _custom_data: _custom_data
                                initial: Delay to generate first occurrence of LSA in msecs.
                                min: Min delay between originating the same LSA in msecs.
                                max: 1-600000 Maximum delay between originating the same LSA in msec.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "rx_min_interval", "tx_delay")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    rx_min_interval: Annotated[int, Max[600000]] | None = None
                    """Min interval in msecs between accepting the same LSA."""
                    tx_delay: TxDelay | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        rx_min_interval: Annotated[int, Max[600000]] | None = None,
                        tx_delay: TxDelay | None = None,
                    ) -> None:
                        """
                        Lsa.

                        Args:
                        -----
                            _custom_data: _custom_data
                            rx_min_interval: Min interval in msecs between accepting the same LSA.
                            tx_delay: tx_delay

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class SpfDelay(AvdBase):
                    _fields = ("_custom_data", "initial", "min", "max")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    initial: Annotated[int, Max[600000]] | None = None
                    """Initial SPF schedule delay in msecs."""
                    min: Annotated[int, Max[65535000]] | None = None
                    """Min Hold time between two SPFs in msecs."""
                    max: Annotated[int, Max[65535000]] | None = None
                    """Max wait time between two SPFs in msecs."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        initial: Annotated[int, Max[600000]] | None = None,
                        min: Annotated[int, Max[65535000]] | None = None,
                        max: Annotated[int, Max[65535000]] | None = None,
                    ) -> None:
                        """
                        SpfDelay.

                        Args:
                        -----
                            _custom_data: _custom_data
                            initial: Initial SPF schedule delay in msecs.
                            min: Min Hold time between two SPFs in msecs.
                            max: Max wait time between two SPFs in msecs.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "lsa", "spf_delay")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                lsa: Lsa | None = None
                spf_delay: SpfDelay | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, lsa: Lsa | None = None, spf_delay: SpfDelay | None = None) -> None:
                    """
                    Timers.

                    Args:
                    -----
                        _custom_data: _custom_data
                        lsa: lsa
                        spf_delay: spf_delay

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class DefaultInformationOriginate(AvdBase):
                _fields = ("_custom_data", "always", "metric", "metric_type")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                always: bool | None = None
                metric: Annotated[int, Min[1], Max[65535]] | None = None
                """Metric for default route."""
                metric_type: Annotated[int, ValidValues[1, 2]] | None = None
                """OSPF metric type for default route."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    always: bool | None = None,
                    metric: Annotated[int, Min[1], Max[65535]] | None = None,
                    metric_type: Annotated[int, ValidValues[1, 2]] | None = None,
                ) -> None:
                    """
                    DefaultInformationOriginate.

                    Args:
                    -----
                        _custom_data: _custom_data
                        always: always
                        metric: Metric for default route.
                        metric_type: OSPF metric type for default route.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class SummaryAddressesItem(AvdBase):
                _fields = ("_custom_data", "prefix", "tag", "attribute_map", "not_advertise")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                prefix: str = None
                """Summary Prefix Address."""
                tag: int | None = None
                attribute_map: str | None = None
                not_advertise: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    prefix: str = None,
                    tag: int | None = None,
                    attribute_map: str | None = None,
                    not_advertise: bool | None = None,
                ) -> None:
                    """
                    SummaryAddressesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefix: Summary Prefix Address.
                        tag: tag
                        attribute_map: attribute_map
                        not_advertise: not_advertise

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Redistribute(AvdBase):
                class Static(AvdBase):
                    _fields = ("_custom_data", "enabled", "route_map", "include_leaked")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    route_map: str | None = None
                    """Route Map Name."""
                    include_leaked: bool | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        enabled: bool = None,
                        route_map: str | None = None,
                        include_leaked: bool | None = None,
                    ) -> None:
                        """
                        Static.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: Route Map Name.
                            include_leaked: include_leaked

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Connected(AvdBase):
                    _fields = ("_custom_data", "enabled", "route_map", "include_leaked")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    route_map: str | None = None
                    """Route Map Name."""
                    include_leaked: bool | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        enabled: bool = None,
                        route_map: str | None = None,
                        include_leaked: bool | None = None,
                    ) -> None:
                        """
                        Connected.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: Route Map Name.
                            include_leaked: include_leaked

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Bgp(AvdBase):
                    _fields = ("_custom_data", "enabled", "route_map", "include_leaked")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    route_map: str | None = None
                    """Route Map Name."""
                    include_leaked: bool | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        enabled: bool = None,
                        route_map: str | None = None,
                        include_leaked: bool | None = None,
                    ) -> None:
                        """
                        Bgp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: Route Map Name.
                            include_leaked: include_leaked

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "static", "connected", "bgp")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                static: Static | None = None
                connected: Connected | None = None
                bgp: Bgp | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    static: Static | None = None,
                    connected: Connected | None = None,
                    bgp: Bgp | None = None,
                ) -> None:
                    """
                    Redistribute.

                    Args:
                    -----
                        _custom_data: _custom_data
                        static: static
                        connected: connected
                        bgp: bgp

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AreasItem(AvdBase):
                class Filter(AvdBase):
                    _fields = ("_custom_data", "networks", "prefix_list")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    networks: list[str] | None = None
                    prefix_list: str | None = None
                    """Prefix-List Name."""

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, networks: list[str] | None = None, prefix_list: str | None = None
                    ) -> None:
                        """
                        Filter.

                        Args:
                        -----
                            _custom_data: _custom_data
                            networks: networks
                            prefix_list: Prefix-List Name.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class DefaultInformationOriginate(AvdBase):
                    _fields = ("_custom_data", "metric", "metric_type")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    metric: Annotated[int, Min[1], Max[65535]] | None = None
                    """Metric for default route."""
                    metric_type: Annotated[int, ValidValues[1, 2]] | None = None
                    """OSPF metric type for default route."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        metric: Annotated[int, Min[1], Max[65535]] | None = None,
                        metric_type: Annotated[int, ValidValues[1, 2]] | None = None,
                    ) -> None:
                        """
                        DefaultInformationOriginate.

                        Args:
                        -----
                            _custom_data: _custom_data
                            metric: Metric for default route.
                            metric_type: OSPF metric type for default route.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "id", "filter", "type", "no_summary", "nssa_only", "default_information_originate")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                id: str = None
                filter: Filter | None = None
                type: Annotated[str, ValidValues["normal", "stub", "nssa"]] | None = "normal"
                no_summary: bool | None = None
                nssa_only: bool | None = None
                default_information_originate: DefaultInformationOriginate | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    id: str = None,
                    filter: Filter | None = None,
                    type: Annotated[str, ValidValues["normal", "stub", "nssa"]] | None = "normal",
                    no_summary: bool | None = None,
                    nssa_only: bool | None = None,
                    default_information_originate: DefaultInformationOriginate | None = None,
                ) -> None:
                    """
                    AreasItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        id: id
                        filter: filter
                        type: type
                        no_summary: no_summary
                        nssa_only: nssa_only
                        default_information_originate: default_information_originate

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class MaxMetric(AvdBase):
                class RouterLsa(AvdBase):
                    class ExternalLsa(AvdBase):
                        _fields = ("_custom_data", "override_metric")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        override_metric: Annotated[int, Min[1], Max[16777215]] | None = None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | None = None, override_metric: Annotated[int, Min[1], Max[16777215]] | None = None
                        ) -> None:
                            """
                            ExternalLsa.

                            Args:
                            -----
                                _custom_data: _custom_data
                                override_metric: override_metric

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class SummaryLsa(AvdBase):
                        _fields = ("_custom_data", "override_metric")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        override_metric: Annotated[int, Min[1], Max[16777215]] | None = None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | None = None, override_metric: Annotated[int, Min[1], Max[16777215]] | None = None
                        ) -> None:
                            """
                            SummaryLsa.

                            Args:
                            -----
                                _custom_data: _custom_data
                                override_metric: override_metric

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "external_lsa", "include_stub", "on_startup", "summary_lsa")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    external_lsa: ExternalLsa | None = None
                    include_stub: bool | None = None
                    on_startup: str | None = None
                    """
                    "wait-for-bgp" or Integer 5-86400.
                    Example: "wait-for-bgp" Or "222"
                    """
                    summary_lsa: SummaryLsa | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        external_lsa: ExternalLsa | None = None,
                        include_stub: bool | None = None,
                        on_startup: str | None = None,
                        summary_lsa: SummaryLsa | None = None,
                    ) -> None:
                        """
                        RouterLsa.

                        Args:
                        -----
                            _custom_data: _custom_data
                            external_lsa: external_lsa
                            include_stub: include_stub
                            on_startup:
                               "wait-for-bgp" or Integer 5-86400.
                               Example: "wait-for-bgp" Or "222"
                            summary_lsa: summary_lsa

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "router_lsa")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                router_lsa: RouterLsa | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, router_lsa: RouterLsa | None = None) -> None:
                    """
                    MaxMetric.

                    Args:
                    -----
                        _custom_data: _custom_data
                        router_lsa: router_lsa

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = (
                "_custom_data",
                "id",
                "vrf",
                "passive_interface_default",
                "router_id",
                "distance",
                "log_adjacency_changes_detail",
                "network_prefixes",
                "bfd_enable",
                "bfd_adjacency_state_any",
                "no_passive_interfaces",
                "distribute_list_in",
                "max_lsa",
                "timers",
                "default_information_originate",
                "summary_addresses",
                "redistribute",
                "auto_cost_reference_bandwidth",
                "areas",
                "maximum_paths",
                "max_metric",
                "mpls_ldp_sync_default",
                "eos_cli",
            )
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            id: int = None
            """OSPF Process ID."""
            vrf: str | None = None
            """VRF Name for OSPF Process."""
            passive_interface_default: bool | None = None
            router_id: str | None = None
            """IPv4 Address."""
            distance: Distance | None = None
            log_adjacency_changes_detail: bool | None = None
            network_prefixes: list[NetworkPrefixesItem] | None = None
            bfd_enable: bool | None = None
            bfd_adjacency_state_any: bool | None = None
            no_passive_interfaces: list[str] | None = None
            distribute_list_in: DistributeListIn | None = None
            max_lsa: int | None = None
            timers: Timers | None = None
            default_information_originate: DefaultInformationOriginate | None = None
            summary_addresses: list[SummaryAddressesItem] | None = None
            redistribute: Redistribute | None = None
            auto_cost_reference_bandwidth: int | None = None
            """Bandwidth in mbps."""
            areas: list[AreasItem] | None = None
            maximum_paths: Annotated[int, Min[1], Max[128]] | None = None
            max_metric: MaxMetric | None = None
            mpls_ldp_sync_default: bool | None = None
            eos_cli: str | None = None
            """Multiline EOS CLI rendered directly on the Router OSPF process ID in the final EOS configuration."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                id: int = None,
                vrf: str | None = None,
                passive_interface_default: bool | None = None,
                router_id: str | None = None,
                distance: Distance | None = None,
                log_adjacency_changes_detail: bool | None = None,
                network_prefixes: list[NetworkPrefixesItem] | None = None,
                bfd_enable: bool | None = None,
                bfd_adjacency_state_any: bool | None = None,
                no_passive_interfaces: list[str] | None = None,
                distribute_list_in: DistributeListIn | None = None,
                max_lsa: int | None = None,
                timers: Timers | None = None,
                default_information_originate: DefaultInformationOriginate | None = None,
                summary_addresses: list[SummaryAddressesItem] | None = None,
                redistribute: Redistribute | None = None,
                auto_cost_reference_bandwidth: int | None = None,
                areas: list[AreasItem] | None = None,
                maximum_paths: Annotated[int, Min[1], Max[128]] | None = None,
                max_metric: MaxMetric | None = None,
                mpls_ldp_sync_default: bool | None = None,
                eos_cli: str | None = None,
            ) -> None:
                """
                ProcessIdsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: OSPF Process ID.
                    vrf: VRF Name for OSPF Process.
                    passive_interface_default: passive_interface_default
                    router_id: IPv4 Address.
                    distance: distance
                    log_adjacency_changes_detail: log_adjacency_changes_detail
                    network_prefixes: network_prefixes
                    bfd_enable: bfd_enable
                    bfd_adjacency_state_any: bfd_adjacency_state_any
                    no_passive_interfaces: no_passive_interfaces
                    distribute_list_in: distribute_list_in
                    max_lsa: max_lsa
                    timers: timers
                    default_information_originate: default_information_originate
                    summary_addresses: summary_addresses
                    redistribute: redistribute
                    auto_cost_reference_bandwidth: Bandwidth in mbps.
                    areas: areas
                    maximum_paths: maximum_paths
                    max_metric: max_metric
                    mpls_ldp_sync_default: mpls_ldp_sync_default
                    eos_cli: Multiline EOS CLI rendered directly on the Router OSPF process ID in the final EOS configuration.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "process_ids")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        process_ids: list[ProcessIdsItem] | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, process_ids: list[ProcessIdsItem] | None = None) -> None:
            """
            RouterOspf.

            Args:
            -----
                _custom_data: _custom_data
                process_ids: process_ids

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterPathSelection(AvdBase):
        class PathGroupsItem(AvdBase):
            class LocalInterfacesItem(AvdBase):
                class Stun(AvdBase):
                    _fields = ("_custom_data", "server_profiles")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    server_profiles: list[str] = None
                    """STUN server-profile names."""

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, server_profiles: list[str] = None) -> None:
                        """
                        Stun.

                        Args:
                        -----
                            _custom_data: _custom_data
                            server_profiles: STUN server-profile names.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "name", "public_address", "stun")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: Annotated[str, Pattern[r"^(Port-Channel|Ethernet(\d+/)*)\d+(\.\d+)?$"]] = None
                """Local interface name."""
                public_address: str | None = None
                """Public IP assigned by NAT."""
                stun: Stun | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: Annotated[str, Pattern[r"^(Port-Channel|Ethernet(\d+/)*)\d+(\.\d+)?$"]] = None,
                    public_address: str | None = None,
                    stun: Stun | None = None,
                ) -> None:
                    """
                    LocalInterfacesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Local interface name.
                        public_address: Public IP assigned by NAT.
                        stun: stun

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class LocalIpsItem(AvdBase):
                class Stun(AvdBase):
                    _fields = ("_custom_data", "server_profiles")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    server_profiles: list[str] = None
                    """STUN server-profile names."""

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, server_profiles: list[str] = None) -> None:
                        """
                        Stun.

                        Args:
                        -----
                            _custom_data: _custom_data
                            server_profiles: STUN server-profile names.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "ip_address", "public_address", "stun")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ip_address: str = None
                public_address: str | None = None
                """Public IP assigned by NAT."""
                stun: Stun | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, ip_address: str = None, public_address: str | None = None, stun: Stun | None = None
                ) -> None:
                    """
                    LocalIpsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        public_address: Public IP assigned by NAT.
                        stun: stun

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class DynamicPeers(AvdBase):
                _fields = ("_custom_data", "enabled", "ip_local", "ipsec")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                """Enable `peer dynamic`."""
                ip_local: bool | None = None
                """Prefer local IP address."""
                ipsec: bool | None = None
                """IPsec configuration for dynamic peers."""

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, ip_local: bool | None = None, ipsec: bool | None = None
                ) -> None:
                    """
                    DynamicPeers.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: Enable `peer dynamic`.
                        ip_local: Prefer local IP address.
                        ipsec: IPsec configuration for dynamic peers.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class StaticPeersItem(AvdBase):
                _fields = ("_custom_data", "router_ip", "name", "ipv4_addresses")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                router_ip: str = None
                """Peer router IP."""
                name: str | None = None
                """Name of the site."""
                ipv4_addresses: list[str] | None = None
                """Static IPv4 addresses."""

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, router_ip: str = None, name: str | None = None, ipv4_addresses: list[str] | None = None
                ) -> None:
                    """
                    StaticPeersItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        router_ip: Peer router IP.
                        name: Name of the site.
                        ipv4_addresses: Static IPv4 addresses.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Keepalive(AvdBase):
                _fields = ("_custom_data", "auto", "interval", "failure_threshold")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                auto: bool | None = False
                """Enable adaptive keepalive and feedback interval."""
                interval: Annotated[int, Min[50], Max[60000]] | None = None
                """Interval in milliseconds."""
                failure_threshold: Annotated[int, Min[2], Max[100]] | None = None
                """Failure threshold in number of intervals. Required when `interval` is set."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    auto: bool | None = False,
                    interval: Annotated[int, Min[50], Max[60000]] | None = None,
                    failure_threshold: Annotated[int, Min[2], Max[100]] | None = None,
                ) -> None:
                    """
                    Keepalive.

                    Args:
                    -----
                        _custom_data: _custom_data
                        auto: Enable adaptive keepalive and feedback interval.
                        interval: Interval in milliseconds.
                        failure_threshold: Failure threshold in number of intervals. Required when `interval` is set.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = (
                "_custom_data",
                "name",
                "id",
                "ipsec_profile",
                "flow_assignment",
                "local_interfaces",
                "local_ips",
                "dynamic_peers",
                "static_peers",
                "keepalive",
            )
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Path group name."""
            id: Annotated[int, Min[1], Max[65535]] | None = None
            """Path group ID."""
            ipsec_profile: str | None = None
            """IPSec profile for the path group."""
            flow_assignment: Annotated[str, ValidValues["lan"]] | None = None
            """Flow assignment `lan` can not be configured in a path group with dynamic peers."""
            local_interfaces: list[LocalInterfacesItem] | None = None
            local_ips: list[LocalIpsItem] | None = None
            dynamic_peers: DynamicPeers | None = None
            """Flow assignment `lan` can not be configured in a path group with dynamic peers."""
            static_peers: list[StaticPeersItem] | None = None
            keepalive: Keepalive | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                id: Annotated[int, Min[1], Max[65535]] | None = None,
                ipsec_profile: str | None = None,
                flow_assignment: Annotated[str, ValidValues["lan"]] | None = None,
                local_interfaces: list[LocalInterfacesItem] | None = None,
                local_ips: list[LocalIpsItem] | None = None,
                dynamic_peers: DynamicPeers | None = None,
                static_peers: list[StaticPeersItem] | None = None,
                keepalive: Keepalive | None = None,
            ) -> None:
                """
                PathGroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Path group name.
                    id: Path group ID.
                    ipsec_profile: IPSec profile for the path group.
                    flow_assignment: Flow assignment `lan` can not be configured in a path group with dynamic peers.
                    local_interfaces: local_interfaces
                    local_ips: local_ips
                    dynamic_peers: Flow assignment `lan` can not be configured in a path group with dynamic peers.
                    static_peers: static_peers
                    keepalive: keepalive

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class LoadBalancePoliciesItem(AvdBase):
            class PathGroupsItem(AvdBase):
                _fields = ("_custom_data", "name", "priority")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Path-group name."""
                priority: Annotated[int, Min[1], Max[65535]] | None = None
                """
                Priority for this path-group.
                The EOS default value is 1.
                """

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, name: str = None, priority: Annotated[int, Min[1], Max[65535]] | None = None
                ) -> None:
                    """
                    PathGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Path-group name.
                        priority:
                           Priority for this path-group.
                           The EOS default value is 1.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "lowest_hop_count", "jitter", "latency", "loss_rate", "path_groups")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Load-balance policy name."""
            lowest_hop_count: bool | None = None
            """Prefer paths with lowest hop-count."""
            jitter: Annotated[int, Max[10000]] | None = None
            """Jitter requirement for this load balance policy in milliseconds."""
            latency: Annotated[int, Max[10000]] | None = None
            """One way delay requirement for this load balance policy in milliseconds."""
            loss_rate: Annotated[str, Pattern[r"^\d+(\.\d{1,2})?$"]] | None = None
            """
            Loss Rate requirement in percentage for this load balance policy.
            Value between 0.00 and 100.00.
            """
            path_groups: list[PathGroupsItem] | None = None
            """List of path-groups to use for this load balance policy."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                lowest_hop_count: bool | None = None,
                jitter: Annotated[int, Max[10000]] | None = None,
                latency: Annotated[int, Max[10000]] | None = None,
                loss_rate: Annotated[str, Pattern[r"^\d+(\.\d{1,2})?$"]] | None = None,
                path_groups: list[PathGroupsItem] | None = None,
            ) -> None:
                """
                LoadBalancePoliciesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Load-balance policy name.
                    lowest_hop_count: Prefer paths with lowest hop-count.
                    jitter: Jitter requirement for this load balance policy in milliseconds.
                    latency: One way delay requirement for this load balance policy in milliseconds.
                    loss_rate:
                       Loss Rate requirement in percentage for this load balance policy.
                       Value between 0.00 and 100.00.
                    path_groups: List of path-groups to use for this load balance policy.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PoliciesItem(AvdBase):
            class DefaultMatch(AvdBase):
                _fields = ("_custom_data", "load_balance")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                load_balance: str | None = None
                """Name of the load-balance policy."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, load_balance: str | None = None) -> None:
                    """
                    DefaultMatch.

                    Args:
                    -----
                        _custom_data: _custom_data
                        load_balance: Name of the load-balance policy.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RulesItem(AvdBase):
                _fields = ("_custom_data", "id", "application_profile", "load_balance")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                id: Annotated[int, Min[1], Max[255]] = None
                """Rule ID."""
                application_profile: str = None
                load_balance: str | None = None
                """Name of the load-balance policy."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    id: Annotated[int, Min[1], Max[255]] = None,
                    application_profile: str = None,
                    load_balance: str | None = None,
                ) -> None:
                    """
                    RulesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        id: Rule ID.
                        application_profile: application_profile
                        load_balance: Name of the load-balance policy.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "default_match", "rules")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """DPS policy name."""
            default_match: DefaultMatch | None = None
            rules: list[RulesItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                default_match: DefaultMatch | None = None,
                rules: list[RulesItem] | None = None,
            ) -> None:
                """
                PoliciesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: DPS policy name.
                    default_match: default_match
                    rules: rules

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrfsItem(AvdBase):
            _fields = ("_custom_data", "name", "path_selection_policy")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """VRF name."""
            path_selection_policy: str | None = None
            """DPS policy name to use for this VRF."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, path_selection_policy: str | None = None) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF name.
                    path_selection_policy: DPS policy name to use for this VRF.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TcpMssCeiling(AvdBase):
            _fields = ("_custom_data", "ipv4_segment_size", "direction")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv4_segment_size: str | None = None
            """
            Segment Size for IPv4.
            Can be an integer in the range 64-65515 or "auto".
            "auto" will enable auto-
            discovery which clamps the TCP MSS value to the minimum of all the direct paths
            and multi-hop path
            MTU towards a remote VTEP (minus 40bytes to account for IP + TCP header).
            """
            direction: Annotated[str, ValidValues["ingress"]] | None = "ingress"
            """
            Enforce on packets through DPS tunnel for a specific direction.
            Only 'ingress' direction is
            supported.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                ipv4_segment_size: str | None = None,
                direction: Annotated[str, ValidValues["ingress"]] | None = "ingress",
            ) -> None:
                """
                TcpMssCeiling.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4_segment_size:
                       Segment Size for IPv4.
                       Can be an integer in the range 64-65515 or "auto".
                       "auto" will enable auto-
                       discovery which clamps the TCP MSS value to the minimum of all the direct paths
                       and multi-hop path
                       MTU towards a remote VTEP (minus 40bytes to account for IP + TCP header).
                    direction:
                       Enforce on packets through DPS tunnel for a specific direction.
                       Only 'ingress' direction is
                       supported.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "peer_dynamic_source", "path_groups", "load_balance_policies", "policies", "vrfs", "tcp_mss_ceiling")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        peer_dynamic_source: Annotated[str, ValidValues["stun"]] | None = None
        """Source of dynamic peer discovery."""
        path_groups: list[PathGroupsItem] | None = None
        load_balance_policies: list[LoadBalancePoliciesItem] | None = None
        policies: list[PoliciesItem] | None = None
        vrfs: list[VrfsItem] | None = None
        tcp_mss_ceiling: TcpMssCeiling | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            peer_dynamic_source: Annotated[str, ValidValues["stun"]] | None = None,
            path_groups: list[PathGroupsItem] | None = None,
            load_balance_policies: list[LoadBalancePoliciesItem] | None = None,
            policies: list[PoliciesItem] | None = None,
            vrfs: list[VrfsItem] | None = None,
            tcp_mss_ceiling: TcpMssCeiling | None = None,
        ) -> None:
            """
            RouterPathSelection.

            Args:
            -----
                _custom_data: _custom_data
                peer_dynamic_source: Source of dynamic peer discovery.
                path_groups: path_groups
                load_balance_policies: load_balance_policies
                policies: policies
                vrfs: vrfs
                tcp_mss_ceiling: tcp_mss_ceiling

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterPimSparseMode(AvdBase):
        class Ipv4(AvdBase):
            class RpAddressesItem(AvdBase):
                _fields = ("_custom_data", "address", "groups", "access_lists", "priority", "hashmask", "override")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                address: str = None
                """RP Address."""
                groups: list[str] | None = None
                access_lists: list[str] | None = None
                priority: Annotated[int, Max[255]] | None = None
                hashmask: Annotated[int, Max[32]] | None = None
                override: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    address: str = None,
                    groups: list[str] | None = None,
                    access_lists: list[str] | None = None,
                    priority: Annotated[int, Max[255]] | None = None,
                    hashmask: Annotated[int, Max[32]] | None = None,
                    override: bool | None = None,
                ) -> None:
                    """
                    RpAddressesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        address: RP Address.
                        groups: groups
                        access_lists: access_lists
                        priority: priority
                        hashmask: hashmask
                        override: override

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AnycastRpsItem(AvdBase):
                class OtherAnycastRpAddressesItem(AvdBase):
                    _fields = ("_custom_data", "address", "register_count")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    address: str = None
                    """Other Anycast RP Address."""
                    register_count: int | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, address: str = None, register_count: int | None = None) -> None:
                        """
                        OtherAnycastRpAddressesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            address: Other Anycast RP Address.
                            register_count: register_count

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "address", "other_anycast_rp_addresses")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                address: str = None
                """Anycast RP Address."""
                other_anycast_rp_addresses: list[OtherAnycastRpAddressesItem] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    address: str = None,
                    other_anycast_rp_addresses: list[OtherAnycastRpAddressesItem] | None = None,
                ) -> None:
                    """
                    AnycastRpsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        address: Anycast RP Address.
                        other_anycast_rp_addresses: other_anycast_rp_addresses

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "bfd", "ssm_range", "rp_addresses", "anycast_rps")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            bfd: bool | None = None
            """Enable/Disable BFD."""
            ssm_range: str | None = None
            """IPv4 Prefix associated with SSM."""
            rp_addresses: list[RpAddressesItem] | None = None
            anycast_rps: list[AnycastRpsItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                bfd: bool | None = None,
                ssm_range: str | None = None,
                rp_addresses: list[RpAddressesItem] | None = None,
                anycast_rps: list[AnycastRpsItem] | None = None,
            ) -> None:
                """
                Ipv4.

                Args:
                -----
                    _custom_data: _custom_data
                    bfd: Enable/Disable BFD.
                    ssm_range: IPv4 Prefix associated with SSM.
                    rp_addresses: rp_addresses
                    anycast_rps: anycast_rps

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrfsItem(AvdBase):
            class Ipv4(AvdBase):
                class RpAddressesItem(AvdBase):
                    _fields = ("_custom_data", "address", "groups", "access_lists", "priority", "hashmask", "override")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    address: str = None
                    """RP Address."""
                    groups: list[str] | None = None
                    access_lists: list[str] | None = None
                    priority: Annotated[int, Max[255]] | None = None
                    hashmask: Annotated[int, Max[32]] | None = None
                    override: bool | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        address: str = None,
                        groups: list[str] | None = None,
                        access_lists: list[str] | None = None,
                        priority: Annotated[int, Max[255]] | None = None,
                        hashmask: Annotated[int, Max[32]] | None = None,
                        override: bool | None = None,
                    ) -> None:
                        """
                        RpAddressesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            address: RP Address.
                            groups: groups
                            access_lists: access_lists
                            priority: priority
                            hashmask: hashmask
                            override: override

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "bfd", "rp_addresses")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                bfd: bool | None = None
                """Enable/Disable BFD."""
                rp_addresses: list[RpAddressesItem] | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, bfd: bool | None = None, rp_addresses: list[RpAddressesItem] | None = None
                ) -> None:
                    """
                    Ipv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        bfd: Enable/Disable BFD.
                        rp_addresses: rp_addresses

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "ipv4")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """VRF Name."""
            ipv4: Ipv4 | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, ipv4: Ipv4 | None = None) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF Name.
                    ipv4: ipv4

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "ipv4", "vrfs")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        ipv4: Ipv4 | None = None
        vrfs: list[VrfsItem] | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, ipv4: Ipv4 | None = None, vrfs: list[VrfsItem] | None = None) -> None:
            """
            RouterPimSparseMode.

            Args:
            -----
                _custom_data: _custom_data
                ipv4: ipv4
                vrfs: vrfs

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterSegmentSecurity(AvdBase):
        class PoliciesItem(AvdBase):
            class SequenceNumbersItem(AvdBase):
                _fields = ("_custom_data", "sequence", "application", "action", "log", "stateless", "next_hop")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                sequence: Annotated[int, Min[1], Max[1023]] = None
                """Sequence ID."""
                application: str = None
                """The name of the application."""
                action: Annotated[str, ValidValues["forward", "drop", "redirect"]] = None
                """
                The action to take - note that platform support for the redirect action is limited. The "redirect"
                action also requires the 'next_hop' to be configured.
                """
                log: bool | None = None
                """Enable logging - note that platform support is limited."""
                stateless: bool | None = True
                """Take action, regardless of state. Should be set to 'true' for MSS-G."""
                next_hop: str | None = None
                """When the action is 'redirect', this indicates the IPv4 next hop to redirect to."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    sequence: Annotated[int, Min[1], Max[1023]] = None,
                    application: str = None,
                    action: Annotated[str, ValidValues["forward", "drop", "redirect"]] = None,
                    log: bool | None = None,
                    stateless: bool | None = True,
                    next_hop: str | None = None,
                ) -> None:
                    """
                    SequenceNumbersItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        sequence: Sequence ID.
                        application: The name of the application.
                        action:
                           The action to take - note that platform support for the redirect action is limited. The "redirect"
                           action also requires the 'next_hop' to be configured.
                        log: Enable logging - note that platform support is limited.
                        stateless: Take action, regardless of state. Should be set to 'true' for MSS-G.
                        next_hop: When the action is 'redirect', this indicates the IPv4 next hop to redirect to.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "sequence_numbers")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Policy name."""
            sequence_numbers: list[SequenceNumbersItem] = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, sequence_numbers: list[SequenceNumbersItem] = None) -> None:
                """
                PoliciesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Policy name.
                    sequence_numbers: sequence_numbers

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrfsItem(AvdBase):
            class SegmentsItem(AvdBase):
                class Definition(AvdBase):
                    class MatchListsItem(AvdBase):
                        _fields = ("_custom_data", "address_family", "covered_prefix_list", "prefix")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        address_family: Annotated[str, ValidValues["ipv4", "ipv6"]] = None
                        """Indicate which address-family the match list belongs to e.g. ipv4 or ipv6."""
                        covered_prefix_list: str | None = None
                        """
                        The name of the prefix-list. You can have a maximum of one per address-family. Mutually exclusive to
                        the use of match_list.  If both are configured prefix takes precedence.
                        """
                        prefix: str | None = None
                        """
                        The name of the match-list. You can have a maximum of one per address-family. Mutually exclusive to
                        the use of covered_prefix_list. If both are configured prefix takes precedence.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            address_family: Annotated[str, ValidValues["ipv4", "ipv6"]] = None,
                            covered_prefix_list: str | None = None,
                            prefix: str | None = None,
                        ) -> None:
                            """
                            MatchListsItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                address_family: Indicate which address-family the match list belongs to e.g. ipv4 or ipv6.
                                covered_prefix_list:
                                   The name of the prefix-list. You can have a maximum of one per address-family. Mutually exclusive to
                                   the use of match_list.  If both are configured prefix takes precedence.
                                prefix:
                                   The name of the match-list. You can have a maximum of one per address-family. Mutually exclusive to
                                   the use of covered_prefix_list. If both are configured prefix takes precedence.

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "interfaces", "match_lists")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    interfaces: list[str] | None = None
                    """The names of the source interface e.g. Port-Channel1 - note that platform support is limited."""
                    match_lists: list[MatchListsItem] | None = None
                    """The set of lists that define the segment. These can be a mix of IPv4 and IPv6 prefix or match lists."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        interfaces: list[str] | None = None,
                        match_lists: list[MatchListsItem] | None = None,
                    ) -> None:
                        """
                        Definition.

                        Args:
                        -----
                            _custom_data: _custom_data
                            interfaces: The names of the source interface e.g. Port-Channel1 - note that platform support is limited.
                            match_lists: The set of lists that define the segment. These can be a mix of IPv4 and IPv6 prefix or match lists.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class PoliciesItem(AvdBase):
                    _fields = ("_custom_data", "field_from", "policy")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    field_from: str = None
                    """The name of the source segment or 'forwarding-segments' for all segments."""
                    policy: str | None = None
                    """
                    The name of the policy to apply. The built-in policies are 'policy-forward-all' and 'policy-drop-
                    all'.
                    """

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, field_from: str = None, policy: str | None = None) -> None:
                        """
                        PoliciesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            field_from: The name of the source segment or 'forwarding-segments' for all segments.
                            policy:
                               The name of the policy to apply. The built-in policies are 'policy-forward-all' and 'policy-drop-
                               all'.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "name", "definition", "policies", "fallback_policy")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Segment name."""
                definition: Definition | None = None
                policies: list[PoliciesItem] | None = None
                """The policies controlling traffic into the segment."""
                fallback_policy: str | None = None
                """
                Only supported on the R3 series platforms, this allows a per-segment default policy to be specified
                by name.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    definition: Definition | None = None,
                    policies: list[PoliciesItem] | None = None,
                    fallback_policy: str | None = None,
                ) -> None:
                    """
                    SegmentsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Segment name.
                        definition: definition
                        policies: The policies controlling traffic into the segment.
                        fallback_policy:
                           Only supported on the R3 series platforms, this allows a per-segment default policy to be specified
                           by name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "segments")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            segments: list[SegmentsItem] = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, segments: list[SegmentsItem] = None) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    segments: segments

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "enabled", "policies", "vrfs")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        enabled: bool | None = None
        policies: list[PoliciesItem] | None = None
        """
        Customised application policies.
        Using the Application Traffic Recognition L4 profiles, custom
        policies can be defined. The built-in application 'app-match-all' can be used to match any packets.
        Note that this is stateless, so both the source and destination flows need to be considered.
        """
        vrfs: list[VrfsItem] | None = None
        """The name of the VRF that the segments and policies are defined in."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            enabled: bool | None = None,
            policies: list[PoliciesItem] | None = None,
            vrfs: list[VrfsItem] | None = None,
        ) -> None:
            """
            RouterSegmentSecurity.

            Args:
            -----
                _custom_data: _custom_data
                enabled: enabled
                policies:
                   Customised application policies.
                   Using the Application Traffic Recognition L4 profiles, custom
                   policies can be defined. The built-in application 'app-match-all' can be used to match any packets.
                   Note that this is stateless, so both the source and destination flows need to be considered.
                vrfs: The name of the VRF that the segments and policies are defined in.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterServiceInsertion(AvdBase):
        class ConnectionsItem(AvdBase):
            class EthernetInterface(AvdBase):
                _fields = ("_custom_data", "name", "next_hop")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """e.g. Ethernet2 or Ethernet2/2.2"""
                next_hop: str = None
                """Next-hop IPv4 address (without mask)."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, next_hop: str = None) -> None:
                    """
                    EthernetInterface.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: e.g. Ethernet2 or Ethernet2/2.2
                        next_hop: Next-hop IPv4 address (without mask).

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class TunnelInterface(AvdBase):
                _fields = ("_custom_data", "primary", "secondary")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                primary: str | None = None
                """e.g. Tunnel2"""
                secondary: str | None = None
                """e.g. Tunnel3"""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, primary: str | None = None, secondary: str | None = None) -> None:
                    """
                    TunnelInterface.

                    Args:
                    -----
                        _custom_data: _custom_data
                        primary: e.g. Tunnel2
                        secondary: e.g. Tunnel3

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "ethernet_interface", "tunnel_interface", "monitor_connectivity_host")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Connection name."""
            ethernet_interface: EthernetInterface | None = None
            """
            Outgoing physical interface or subinterface to use for the connection.
            If both `ethernet_interface`
            and `tunnel_interface` are configured, `ethernet_interface` will be used.
            """
            tunnel_interface: TunnelInterface | None = None
            """
            Outgoing tunnel interface(s) to use for this connection.
            If both `ethernet_interface` and
            `tunnel_interface` are configured, `ethernet_interface` will be used.
            """
            monitor_connectivity_host: str | None = None
            """
            Name of the host defined under `monitor_connectivity.hosts` used to derive the health of the
            connection.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                ethernet_interface: EthernetInterface | None = None,
                tunnel_interface: TunnelInterface | None = None,
                monitor_connectivity_host: str | None = None,
            ) -> None:
                """
                ConnectionsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Connection name.
                    ethernet_interface:
                       Outgoing physical interface or subinterface to use for the connection.
                       If both `ethernet_interface`
                       and `tunnel_interface` are configured, `ethernet_interface` will be used.
                    tunnel_interface:
                       Outgoing tunnel interface(s) to use for this connection.
                       If both `ethernet_interface` and
                       `tunnel_interface` are configured, `ethernet_interface` will be used.
                    monitor_connectivity_host:
                       Name of the host defined under `monitor_connectivity.hosts` used to derive the health of the
                       connection.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "enabled", "connections")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        enabled: bool | None = None
        connections: list[ConnectionsItem] | None = None

        def __init__(
            self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None, connections: list[ConnectionsItem] | None = None
        ) -> None:
            """
            RouterServiceInsertion.

            Args:
            -----
                _custom_data: _custom_data
                enabled: enabled
                connections: connections

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterTrafficEngineering(AvdBase):
        class RouterId(AvdBase):
            _fields = ("_custom_data", "ipv4", "ipv6")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv4: str | None = None
            ipv6: str | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, ipv4: str | None = None, ipv6: str | None = None) -> None:
                """
                RouterId.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: ipv4
                    ipv6: ipv6

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SegmentRouting(AvdBase):
            class PolicyEndpointsItem(AvdBase):
                class ColorsItem(AvdBase):
                    class PathGroupItem(AvdBase):
                        class SegmentListItem(AvdBase):
                            _fields = ("_custom_data", "label_stack", "weight", "index")
                            _required_fields = ()
                            _custom_data: dict[str, Any] | None = None
                            label_stack: str | None = None
                            """
                            Label Stack as string.
                            Example: "100 2000 30"
                            """
                            weight: int | None = None
                            index: int | None = None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | None = None,
                                label_stack: str | None = None,
                                weight: int | None = None,
                                index: int | None = None,
                            ) -> None:
                                """
                                SegmentListItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    label_stack:
                                       Label Stack as string.
                                       Example: "100 2000 30"
                                    weight: weight
                                    index: index

                                """
                                for arg, arg_value in locals().items():
                                    if arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields = ("_custom_data", "preference", "explicit_null", "segment_list")
                        _required_fields = ()
                        _custom_data: dict[str, Any] | None = None
                        preference: int | None = None
                        explicit_null: Annotated[str, ValidValues["ipv4", "ipv6", "ipv4 ipv6", "none"]] | None = None
                        segment_list: list[SegmentListItem] | None = None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | None = None,
                            preference: int | None = None,
                            explicit_null: Annotated[str, ValidValues["ipv4", "ipv6", "ipv4 ipv6", "none"]] | None = None,
                            segment_list: list[SegmentListItem] | None = None,
                        ) -> None:
                            """
                            PathGroupItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                preference: preference
                                explicit_null: explicit_null
                                segment_list: segment_list

                            """
                            for arg, arg_value in locals().items():
                                if arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields = ("_custom_data", "value", "binding_sid", "description", "name", "sbfd_remote_discriminator", "path_group")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    value: int = None
                    binding_sid: int | None = None
                    description: str | None = None
                    name: str | None = None
                    sbfd_remote_discriminator: str | None = None
                    """IPv4 address or 32 bit integer."""
                    path_group: list[PathGroupItem] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        value: int = None,
                        binding_sid: int | None = None,
                        description: str | None = None,
                        name: str | None = None,
                        sbfd_remote_discriminator: str | None = None,
                        path_group: list[PathGroupItem] | None = None,
                    ) -> None:
                        """
                        ColorsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            value: value
                            binding_sid: binding_sid
                            description: description
                            name: name
                            sbfd_remote_discriminator: IPv4 address or 32 bit integer.
                            path_group: path_group

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "address", "colors")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                address: str | None = None
                """IPv4 or IPv6 address."""
                colors: list[ColorsItem] | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, address: str | None = None, colors: list[ColorsItem] | None = None) -> None:
                    """
                    PolicyEndpointsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        address: IPv4 or IPv6 address.
                        colors: colors

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "colored_tunnel_rib", "policy_endpoints")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            colored_tunnel_rib: bool | None = None
            policy_endpoints: list[PolicyEndpointsItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                colored_tunnel_rib: bool | None = None,
                policy_endpoints: list[PolicyEndpointsItem] | None = None,
            ) -> None:
                """
                SegmentRouting.

                Args:
                -----
                    _custom_data: _custom_data
                    colored_tunnel_rib: colored_tunnel_rib
                    policy_endpoints: policy_endpoints

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "enabled", "router_id", "segment_routing")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        enabled: bool = None
        router_id: RouterId | None = None
        segment_routing: SegmentRouting | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            enabled: bool = None,
            router_id: RouterId | None = None,
            segment_routing: SegmentRouting | None = None,
        ) -> None:
            """
            RouterTrafficEngineering.

            Args:
            -----
                _custom_data: _custom_data
                enabled: enabled
                router_id: router_id
                segment_routing: segment_routing

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ServiceRoutingConfigurationBgp(AvdBase):
        _fields = ("_custom_data", "no_equals_default")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        no_equals_default: bool | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, no_equals_default: bool | None = None) -> None:
            """
            ServiceRoutingConfigurationBgp.

            Args:
            -----
                _custom_data: _custom_data
                no_equals_default: no_equals_default

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ServiceUnsupportedTransceiver(AvdBase):
        _fields = ("_custom_data", "license_name", "license_key")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        license_name: str | None = None
        license_key: str | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, license_name: str | None = None, license_key: str | None = None) -> None:
            """
            ServiceUnsupportedTransceiver.

            Args:
            -----
                _custom_data: _custom_data
                license_name: license_name
                license_key: license_key

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Sflow(AvdBase):
        class VrfsItem(AvdBase):
            class DestinationsItem(AvdBase):
                _fields = ("_custom_data", "destination", "port")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                destination: str = None
                """Sflow Destination IP Address."""
                port: int | None = None
                """Port Number"""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, destination: str = None, port: int | None = None) -> None:
                    """
                    DestinationsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        destination: Sflow Destination IP Address.
                        port: Port Number

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "destinations", "source", "source_interface")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            destinations: list[DestinationsItem] | None = None
            source: str | None = None
            """
            Source IP Address.
            "source" and "source_interface" are mutually exclusive. If both are defined,
            "source_interface" takes precedence.
            """
            source_interface: str | None = None
            """Source Interface."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                destinations: list[DestinationsItem] | None = None,
                source: str | None = None,
                source_interface: str | None = None,
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    destinations: destinations
                    source:
                       Source IP Address.
                       "source" and "source_interface" are mutually exclusive. If both are defined,
                       "source_interface" takes precedence.
                    source_interface: Source Interface.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class DestinationsItem(AvdBase):
            _fields = ("_custom_data", "destination", "port")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            destination: str = None
            """Sflow Destination IP Address."""
            port: int | None = None
            """Port Number."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, destination: str = None, port: int | None = None) -> None:
                """
                DestinationsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    destination: Sflow Destination IP Address.
                    port: Port Number.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ExtensionsItem(AvdBase):
            _fields = ("_custom_data", "name", "enabled")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Extension Name."""
            enabled: bool = None
            """Enable or Disable Extension."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, enabled: bool = None) -> None:
                """
                ExtensionsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Extension Name.
                    enabled: Enable or Disable Extension.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Interface(AvdBase):
            class Disable(AvdBase):
                _fields = ("_custom_data", "default")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                default: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, default: bool | None = None) -> None:
                    """
                    Disable.

                    Args:
                    -----
                        _custom_data: _custom_data
                        default: default

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Egress(AvdBase):
                _fields = ("_custom_data", "enable_default", "unmodified")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enable_default: bool | None = None
                """Enable egress sFlow by default."""
                unmodified: bool | None = None
                """
                Enable egress sFlow unmodified.
                Platform dependent feature.
                """

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, enable_default: bool | None = None, unmodified: bool | None = None) -> None:
                    """
                    Egress.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enable_default: Enable egress sFlow by default.
                        unmodified:
                           Enable egress sFlow unmodified.
                           Platform dependent feature.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "disable", "egress")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            disable: Disable | None = None
            egress: Egress | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, disable: Disable | None = None, egress: Egress | None = None) -> None:
                """
                Interface.

                Args:
                -----
                    _custom_data: _custom_data
                    disable: disable
                    egress: egress

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class HardwareAcceleration(AvdBase):
            class ModulesItem(AvdBase):
                _fields = ("_custom_data", "name", "enabled")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                enabled: bool | None = True

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, enabled: bool | None = True) -> None:
                    """
                    ModulesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        enabled: enabled

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "enabled", "sample", "modules")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool | None = None
            sample: int | None = None
            modules: list[ModulesItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enabled: bool | None = None,
                sample: int | None = None,
                modules: list[ModulesItem] | None = None,
            ) -> None:
                """
                HardwareAcceleration.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    sample: sample
                    modules: modules

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "sample",
            "sample_input_subinterface",
            "sample_output_subinterface",
            "dangerous",
            "polling_interval",
            "vrfs",
            "destinations",
            "source",
            "source_interface",
            "extensions",
            "interface",
            "run",
            "hardware_acceleration",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        sample: int | None = None
        sample_input_subinterface: bool | None = None
        sample_output_subinterface: bool | None = None
        dangerous: bool | None = None
        polling_interval: int | None = None
        """Polling interval in seconds."""
        vrfs: list[VrfsItem] | None = None
        destinations: list[DestinationsItem] | None = None
        source: str | None = None
        """
        Source IP Address.
        "source" and "source_interface" are mutually exclusive. If both are defined,
        "source_interface" takes precedence.
        """
        source_interface: str | None = None
        """Source Interface."""
        extensions: list[ExtensionsItem] | None = None
        interface: Interface | None = None
        run: bool | None = None
        hardware_acceleration: HardwareAcceleration | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            sample: int | None = None,
            sample_input_subinterface: bool | None = None,
            sample_output_subinterface: bool | None = None,
            dangerous: bool | None = None,
            polling_interval: int | None = None,
            vrfs: list[VrfsItem] | None = None,
            destinations: list[DestinationsItem] | None = None,
            source: str | None = None,
            source_interface: str | None = None,
            extensions: list[ExtensionsItem] | None = None,
            interface: Interface | None = None,
            run: bool | None = None,
            hardware_acceleration: HardwareAcceleration | None = None,
        ) -> None:
            """
            Sflow.

            Args:
            -----
                _custom_data: _custom_data
                sample: sample
                sample_input_subinterface: sample_input_subinterface
                sample_output_subinterface: sample_output_subinterface
                dangerous: dangerous
                polling_interval: Polling interval in seconds.
                vrfs: vrfs
                destinations: destinations
                source:
                   Source IP Address.
                   "source" and "source_interface" are mutually exclusive. If both are defined,
                   "source_interface" takes precedence.
                source_interface: Source Interface.
                extensions: extensions
                interface: interface
                run: run
                hardware_acceleration: hardware_acceleration

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class SnmpServer(AvdBase):
        class EngineIds(AvdBase):
            class RemotesItem(AvdBase):
                _fields = ("_custom_data", "id", "address", "udp_port")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                id: str | None = None
                """Remote engine ID in hexadecimal."""
                address: str | None = None
                """Hostname or IP of remote engine."""
                udp_port: int | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, id: str | None = None, address: str | None = None, udp_port: int | None = None
                ) -> None:
                    """
                    RemotesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        id: Remote engine ID in hexadecimal.
                        address: Hostname or IP of remote engine.
                        udp_port: udp_port

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "local", "remotes")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            local: str | None = None
            """Engine ID in hexadecimal."""
            remotes: list[RemotesItem] | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, local: str | None = None, remotes: list[RemotesItem] | None = None) -> None:
                """
                EngineIds.

                Args:
                -----
                    _custom_data: _custom_data
                    local: Engine ID in hexadecimal.
                    remotes: remotes

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class CommunitiesItem(AvdBase):
            class AccessListIpv4(AvdBase):
                _fields = ("_custom_data", "name")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str | None = None
                """IPv4 access list name."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None) -> None:
                    """
                    AccessListIpv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: IPv4 access list name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AccessListIpv6(AvdBase):
                _fields = ("_custom_data", "name")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str | None = None
                """IPv6 access list name."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None) -> None:
                    """
                    AccessListIpv6.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: IPv6 access list name.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "access", "access_list_ipv4", "access_list_ipv6", "view")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Community name."""
            access: Annotated[str, ValidValues["ro", "rw"]] | None = None
            access_list_ipv4: AccessListIpv4 | None = None
            access_list_ipv6: AccessListIpv6 | None = None
            view: str | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                access: Annotated[str, ValidValues["ro", "rw"]] | None = None,
                access_list_ipv4: AccessListIpv4 | None = None,
                access_list_ipv6: AccessListIpv6 | None = None,
                view: str | None = None,
            ) -> None:
                """
                CommunitiesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Community name.
                    access: access
                    access_list_ipv4: access_list_ipv4
                    access_list_ipv6: access_list_ipv6
                    view: view

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv4AclsItem(AvdBase):
            _fields = ("_custom_data", "name", "vrf")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str | None = None
            """IPv4 access list name."""
            vrf: str | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, vrf: str | None = None) -> None:
                """
                Ipv4AclsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: IPv4 access list name.
                    vrf: vrf

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6AclsItem(AvdBase):
            _fields = ("_custom_data", "name", "vrf")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str | None = None
            """IPv6 access list name."""
            vrf: str | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, vrf: str | None = None) -> None:
                """
                Ipv6AclsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: IPv6 access list name.
                    vrf: vrf

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class LocalInterfacesItem(AvdBase):
            _fields = ("_custom_data", "name", "vrf")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Interface name."""
            vrf: str | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, vrf: str | None = None) -> None:
                """
                LocalInterfacesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Interface name.
                    vrf: vrf

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ViewsItem(AvdBase):
            _fields = ("_custom_data", "name", "mib_family_name", "included")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str | None = None
            """SNMP view name."""
            mib_family_name: str | None = None
            included: bool | None = None

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, mib_family_name: str | None = None, included: bool | None = None
            ) -> None:
                """
                ViewsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: SNMP view name.
                    mib_family_name: mib_family_name
                    included: included

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class GroupsItem(AvdBase):
            _fields = ("_custom_data", "name", "version", "authentication", "read", "write", "notify")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str | None = None
            """Group name."""
            version: Annotated[str, ValidValues["v1", "v2c", "v3"]] | None = None
            authentication: Annotated[str, ValidValues["auth", "noauth", "priv"]] | None = None
            read: str | None = None
            """Read view."""
            write: str | None = None
            """Write view."""
            notify: str | None = None
            """Notify view."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str | None = None,
                version: Annotated[str, ValidValues["v1", "v2c", "v3"]] | None = None,
                authentication: Annotated[str, ValidValues["auth", "noauth", "priv"]] | None = None,
                read: str | None = None,
                write: str | None = None,
                notify: str | None = None,
            ) -> None:
                """
                GroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Group name.
                    version: version
                    authentication: authentication
                    read: Read view.
                    write: Write view.
                    notify: Notify view.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class UsersItem(AvdBase):
            _fields = (
                "_custom_data",
                "name",
                "group",
                "remote_address",
                "udp_port",
                "version",
                "localized",
                "auth",
                "auth_passphrase",
                "priv",
                "priv_passphrase",
            )
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str | None = None
            """Username."""
            group: str | None = None
            """Group name."""
            remote_address: str | None = None
            """
            Hostname or ip of remote engine.
            The remote_address and udp_port are used for remote users.
            """
            udp_port: int | None = None
            """udp_port will not be used if no remote_address is configured."""
            version: Annotated[str, ValidValues["v1", "v2c", "v3"]] | None = None
            localized: str | None = None
            """Engine ID in hexadecimal for localizing auth and/or priv."""
            auth: str | None = None
            """Hash algorithm."""
            auth_passphrase: str | None = None
            """Hashed authentication passphrase if localized is used else cleartext authentication passphrase."""
            priv: str | None = None
            """Encryption algorithm."""
            priv_passphrase: str | None = None
            """Hashed privacy passphrase if localized is used else cleartext privacy passphrase."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str | None = None,
                group: str | None = None,
                remote_address: str | None = None,
                udp_port: int | None = None,
                version: Annotated[str, ValidValues["v1", "v2c", "v3"]] | None = None,
                localized: str | None = None,
                auth: str | None = None,
                auth_passphrase: str | None = None,
                priv: str | None = None,
                priv_passphrase: str | None = None,
            ) -> None:
                """
                UsersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Username.
                    group: Group name.
                    remote_address:
                       Hostname or ip of remote engine.
                       The remote_address and udp_port are used for remote users.
                    udp_port: udp_port will not be used if no remote_address is configured.
                    version: version
                    localized: Engine ID in hexadecimal for localizing auth and/or priv.
                    auth: Hash algorithm.
                    auth_passphrase: Hashed authentication passphrase if localized is used else cleartext authentication passphrase.
                    priv: Encryption algorithm.
                    priv_passphrase: Hashed privacy passphrase if localized is used else cleartext privacy passphrase.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class HostsItem(AvdBase):
            class UsersItem(AvdBase):
                _fields = ("_custom_data", "username", "authentication_level")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                username: str | None = None
                authentication_level: Annotated[str, ValidValues["auth", "noauth", "priv"]] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    username: str | None = None,
                    authentication_level: Annotated[str, ValidValues["auth", "noauth", "priv"]] | None = None,
                ) -> None:
                    """
                    UsersItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        username: username
                        authentication_level: authentication_level

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "host", "vrf", "version", "community", "users")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            host: str | None = None
            """Host IP address or name."""
            vrf: str | None = None
            version: Annotated[str, ValidValues["1", "2c", "3"]] | None = None
            community: str | None = None
            """Community name."""
            users: list[UsersItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                host: str | None = None,
                vrf: str | None = None,
                version: Annotated[str, ValidValues["1", "2c", "3"]] | None = None,
                community: str | None = None,
                users: list[UsersItem] | None = None,
            ) -> None:
                """
                HostsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    host: Host IP address or name.
                    vrf: vrf
                    version: version
                    community: Community name.
                    users: users

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Traps(AvdBase):
            class SnmpTrapsItem(AvdBase):
                _fields = ("_custom_data", "name", "enabled")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str | None = None
                """
                Enable or disable specific snmp-traps and their sub_traps.
                Examples:
                - "bgp"
                - "bgp established"
                """
                enabled: bool | None = True

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str | None = None, enabled: bool | None = True) -> None:
                    """
                    SnmpTrapsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name:
                           Enable or disable specific snmp-traps and their sub_traps.

                    Examples:
                           - "bgp"
                           - "bgp established"
                        enabled: enabled

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "enable", "snmp_traps")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enable: bool | None = False
            """Enable or disable all snmp-traps."""
            snmp_traps: list[SnmpTrapsItem] | None = None

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, enable: bool | None = False, snmp_traps: list[SnmpTrapsItem] | None = None
            ) -> None:
                """
                Traps.

                Args:
                -----
                    _custom_data: _custom_data
                    enable: Enable or disable all snmp-traps.
                    snmp_traps: snmp_traps

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrfsItem(AvdBase):
            _fields = ("_custom_data", "name", "enable")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """VRF name."""
            enable: bool | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, enable: bool | None = None) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF name.
                    enable: enable

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "engine_ids",
            "contact",
            "location",
            "communities",
            "ipv4_acls",
            "ipv6_acls",
            "local_interfaces",
            "views",
            "groups",
            "users",
            "hosts",
            "traps",
            "vrfs",
            "ifmib_ifspeed_shape_rate",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        engine_ids: EngineIds | None = None
        contact: str | None = None
        """SNMP contact."""
        location: str | None = None
        """SNMP location."""
        communities: list[CommunitiesItem] | None = None
        ipv4_acls: list[Ipv4AclsItem] | None = None
        ipv6_acls: list[Ipv6AclsItem] | None = None
        local_interfaces: list[LocalInterfacesItem] | None = None
        views: list[ViewsItem] | None = None
        groups: list[GroupsItem] | None = None
        users: list[UsersItem] | None = None
        hosts: list[HostsItem] | None = None
        traps: Traps | None = None
        vrfs: list[VrfsItem] | None = None
        ifmib_ifspeed_shape_rate: bool | None = None
        """SNMP ifspeed reflecting shaping rate."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            engine_ids: EngineIds | None = None,
            contact: str | None = None,
            location: str | None = None,
            communities: list[CommunitiesItem] | None = None,
            ipv4_acls: list[Ipv4AclsItem] | None = None,
            ipv6_acls: list[Ipv6AclsItem] | None = None,
            local_interfaces: list[LocalInterfacesItem] | None = None,
            views: list[ViewsItem] | None = None,
            groups: list[GroupsItem] | None = None,
            users: list[UsersItem] | None = None,
            hosts: list[HostsItem] | None = None,
            traps: Traps | None = None,
            vrfs: list[VrfsItem] | None = None,
            ifmib_ifspeed_shape_rate: bool | None = None,
        ) -> None:
            """
            SnmpServer.

            Args:
            -----
                _custom_data: _custom_data
                engine_ids: engine_ids
                contact: SNMP contact.
                location: SNMP location.
                communities: communities
                ipv4_acls: ipv4_acls
                ipv6_acls: ipv6_acls
                local_interfaces: local_interfaces
                views: views
                groups: groups
                users: users
                hosts: hosts
                traps: traps
                vrfs: vrfs
                ifmib_ifspeed_shape_rate: SNMP ifspeed reflecting shaping rate.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class SpanningTree(AvdBase):
        class EdgePort(AvdBase):
            _fields = ("_custom_data", "bpdufilter_default", "bpduguard_default")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            bpdufilter_default: bool | None = None
            bpduguard_default: bool | None = None

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, bpdufilter_default: bool | None = None, bpduguard_default: bool | None = None
            ) -> None:
                """
                EdgePort.

                Args:
                -----
                    _custom_data: _custom_data
                    bpdufilter_default: bpdufilter_default
                    bpduguard_default: bpduguard_default

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class BpduguardRateLimit(AvdBase):
            _fields = ("_custom_data", "default", "count")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            default: bool | None = None
            count: int | None = None
            """Maximum number of BPDUs per timer interval."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, default: bool | None = None, count: int | None = None) -> None:
                """
                BpduguardRateLimit.

                Args:
                -----
                    _custom_data: _custom_data
                    default: default
                    count: Maximum number of BPDUs per timer interval.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Mst(AvdBase):
            class Configuration(AvdBase):
                class InstancesItem(AvdBase):
                    _fields = ("_custom_data", "id", "vlans")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    id: int = None
                    """Instance ID."""
                    vlans: str | None = None
                    """
                    "< vlan_id >, < vlan_id >-< vlan_id >"
                    Example: 15,16,17,18
                    """

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, id: int = None, vlans: str | None = None) -> None:
                        """
                        InstancesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: Instance ID.
                            vlans:
                               "< vlan_id >, < vlan_id >-< vlan_id >"
                               Example: 15,16,17,18

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "name", "revision", "instances")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str | None = None
                revision: int | None = None
                """0-65535."""
                instances: list[InstancesItem] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str | None = None,
                    revision: int | None = None,
                    instances: list[InstancesItem] | None = None,
                ) -> None:
                    """
                    Configuration.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        revision: 0-65535.
                        instances: instances

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "pvst_border", "configuration")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            pvst_border: bool | None = None
            configuration: Configuration | None = None

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, pvst_border: bool | None = None, configuration: Configuration | None = None
            ) -> None:
                """
                Mst.

                Args:
                -----
                    _custom_data: _custom_data
                    pvst_border: pvst_border
                    configuration: configuration

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class MstInstancesItem(AvdBase):
            _fields = ("_custom_data", "id", "priority")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            id: str = None
            """Instance ID."""
            priority: int | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, id: str = None, priority: int | None = None) -> None:
                """
                MstInstancesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: Instance ID.
                    priority: priority

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class RapidPvstInstancesItem(AvdBase):
            _fields = ("_custom_data", "id", "priority")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            id: str = None
            """
            "< vlan_id >, < vlan_id >-< vlan_id >"
            Example: 105,202,505-506
            """
            priority: int | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, id: str = None, priority: int | None = None) -> None:
                """
                RapidPvstInstancesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id:
                       "< vlan_id >, < vlan_id >-< vlan_id >"
                       Example: 105,202,505-506
                    priority: priority

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "root_super",
            "edge_port",
            "mode",
            "bpduguard_rate_limit",
            "rstp_priority",
            "mst",
            "mst_instances",
            "no_spanning_tree_vlan",
            "rapid_pvst_instances",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        root_super: bool | None = None
        edge_port: EdgePort | None = None
        mode: Annotated[str, ValidValues["mstp", "rstp", "rapid-pvst", "none"]] | None = None
        bpduguard_rate_limit: BpduguardRateLimit | None = None
        rstp_priority: int | None = None
        mst: Mst | None = None
        mst_instances: list[MstInstancesItem] | None = None
        no_spanning_tree_vlan: str | None = None
        """
        "< vlan_id >, < vlan_id >-< vlan_id >"
        Example: 105,202,505-506
        """
        rapid_pvst_instances: list[RapidPvstInstancesItem] | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            root_super: bool | None = None,
            edge_port: EdgePort | None = None,
            mode: Annotated[str, ValidValues["mstp", "rstp", "rapid-pvst", "none"]] | None = None,
            bpduguard_rate_limit: BpduguardRateLimit | None = None,
            rstp_priority: int | None = None,
            mst: Mst | None = None,
            mst_instances: list[MstInstancesItem] | None = None,
            no_spanning_tree_vlan: str | None = None,
            rapid_pvst_instances: list[RapidPvstInstancesItem] | None = None,
        ) -> None:
            """
            SpanningTree.

            Args:
            -----
                _custom_data: _custom_data
                root_super: root_super
                edge_port: edge_port
                mode: mode
                bpduguard_rate_limit: bpduguard_rate_limit
                rstp_priority: rstp_priority
                mst: mst
                mst_instances: mst_instances
                no_spanning_tree_vlan:
                   "< vlan_id >, < vlan_id >-< vlan_id >"
                   Example: 105,202,505-506
                rapid_pvst_instances: rapid_pvst_instances

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class StandardAccessListsItem(AvdBase):
        class SequenceNumbersItem(AvdBase):
            _fields = ("_custom_data", "sequence", "action")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            sequence: int = None
            """Sequence ID."""
            action: str = None
            """
            Action as string.
            Example: "deny ip any any"
            """

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, sequence: int = None, action: str = None) -> None:
                """
                SequenceNumbersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: Sequence ID.
                    action:
                       Action as string.
                       Example: "deny ip any any"

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "name", "counters_per_entry", "sequence_numbers")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Access-list Name."""
        counters_per_entry: bool | None = None
        sequence_numbers: list[SequenceNumbersItem] = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str = None,
            counters_per_entry: bool | None = None,
            sequence_numbers: list[SequenceNumbersItem] = None,
        ) -> None:
            """
            StandardAccessListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Access-list Name.
                counters_per_entry: counters_per_entry
                sequence_numbers: sequence_numbers

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class StaticRoutesItem(AvdBase):
        _fields = ("_custom_data", "vrf", "destination_address_prefix", "interface", "gateway", "track_bfd", "distance", "tag", "name", "metric")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        vrf: str | None = None
        """VRF Name."""
        destination_address_prefix: str | None = None
        """IPv4_network/Mask."""
        interface: str | None = None
        gateway: str | None = None
        """IPv4 Address."""
        track_bfd: bool | None = None
        """Track next-hop using BFD."""
        distance: Annotated[int, Min[1], Max[255]] | None = None
        tag: Annotated[int, Max[4294967295]] | None = None
        name: str | None = None
        """Description."""
        metric: Annotated[int, Max[4294967295]] | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            vrf: str | None = None,
            destination_address_prefix: str | None = None,
            interface: str | None = None,
            gateway: str | None = None,
            track_bfd: bool | None = None,
            distance: Annotated[int, Min[1], Max[255]] | None = None,
            tag: Annotated[int, Max[4294967295]] | None = None,
            name: str | None = None,
            metric: Annotated[int, Max[4294967295]] | None = None,
        ) -> None:
            """
            StaticRoutesItem.

            Args:
            -----
                _custom_data: _custom_data
                vrf: VRF Name.
                destination_address_prefix: IPv4_network/Mask.
                interface: interface
                gateway: IPv4 Address.
                track_bfd: Track next-hop using BFD.
                distance: distance
                tag: tag
                name: Description.
                metric: metric

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Stun(AvdBase):
        class Client(AvdBase):
            class ServerProfilesItem(AvdBase):
                _fields = ("_custom_data", "name", "ip_address", "ssl_profile", "port")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                ip_address: str | None = None
                ssl_profile: str | None = None
                """SSL profile name."""
                port: Annotated[int, Min[1], Max[65535]] | None = None
                """Destination port for the request STUN server (default - 3478)."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    ip_address: str | None = None,
                    ssl_profile: str | None = None,
                    port: Annotated[int, Min[1], Max[65535]] | None = None,
                ) -> None:
                    """
                    ServerProfilesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        ip_address: ip_address
                        ssl_profile: SSL profile name.
                        port: Destination port for the request STUN server (default - 3478).

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "server_profiles")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            server_profiles: list[ServerProfilesItem] | None = None
            """List of server profiles for the client."""

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, server_profiles: list[ServerProfilesItem] | None = None) -> None:
                """
                Client.

                Args:
                -----
                    _custom_data: _custom_data
                    server_profiles: List of server profiles for the client.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Server(AvdBase):
            class SslConnectionLifetime(AvdBase):
                _fields = ("_custom_data", "minutes", "hours")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                minutes: Annotated[int, Min[1], Max[1440]] | None = None
                """SSL connection lifetime in minutes (default - 120)."""
                hours: Annotated[int, Min[1], Max[24]] | None = None
                """SSL connection lifetime in hours (default - 2)."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    minutes: Annotated[int, Min[1], Max[1440]] | None = None,
                    hours: Annotated[int, Min[1], Max[24]] | None = None,
                ) -> None:
                    """
                    SslConnectionLifetime.

                    Args:
                    -----
                        _custom_data: _custom_data
                        minutes: SSL connection lifetime in minutes (default - 120).
                        hours: SSL connection lifetime in hours (default - 2).

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "local_interfaces", "bindings_timeout", "ssl_profile", "ssl_connection_lifetime", "port")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            local_interfaces: list[str] | None = None
            bindings_timeout: Annotated[int, Min[10], Max[7200]] | None = None
            """Timeout for bindings stored on STUN server in seconds."""
            ssl_profile: str | None = None
            """SSL profile name."""
            ssl_connection_lifetime: SslConnectionLifetime | None = None
            """
            SSL connection lifetime in minutes or hours.
            If both are specified, minutes is given higher
            precedence.
            """
            port: Annotated[int, Min[1], Max[65535]] | None = None
            """Listening port for STUN server (default - 3478)."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                local_interfaces: list[str] | None = None,
                bindings_timeout: Annotated[int, Min[10], Max[7200]] | None = None,
                ssl_profile: str | None = None,
                ssl_connection_lifetime: SslConnectionLifetime | None = None,
                port: Annotated[int, Min[1], Max[65535]] | None = None,
            ) -> None:
                """
                Server.

                Args:
                -----
                    _custom_data: _custom_data
                    local_interfaces: local_interfaces
                    bindings_timeout: Timeout for bindings stored on STUN server in seconds.
                    ssl_profile: SSL profile name.
                    ssl_connection_lifetime:
                       SSL connection lifetime in minutes or hours.
                       If both are specified, minutes is given higher
                       precedence.
                    port: Listening port for STUN server (default - 3478).

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "client", "server")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        client: Client | None = None
        """STUN client settings."""
        server: Server | None = None
        """STUN server settings."""

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, client: Client | None = None, server: Server | None = None) -> None:
            """
            Stun.

            Args:
            -----
                _custom_data: _custom_data
                client: STUN client settings.
                server: STUN server settings.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class SwitchportDefault(AvdBase):
        class Phone(AvdBase):
            _fields = ("_custom_data", "cos", "trunk", "vlan")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            cos: Annotated[int, Max[7]] | None = None
            trunk: Annotated[str, ValidValues["tagged", "untagged"]] | None = None
            vlan: Annotated[int, Min[1], Max[4094]] | None = None
            """VLAN ID."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                cos: Annotated[int, Max[7]] | None = None,
                trunk: Annotated[str, ValidValues["tagged", "untagged"]] | None = None,
                vlan: Annotated[int, Min[1], Max[4094]] | None = None,
            ) -> None:
                """
                Phone.

                Args:
                -----
                    _custom_data: _custom_data
                    cos: cos
                    trunk: trunk
                    vlan: VLAN ID.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "mode", "phone")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        mode: Annotated[str, ValidValues["routed", "access"]] | None = None
        phone: Phone | None = None

        def __init__(
            self, *, _custom_data: dict[str, Any] | None = None, mode: Annotated[str, ValidValues["routed", "access"]] | None = None, phone: Phone | None = None
        ) -> None:
            """
            SwitchportDefault.

            Args:
            -----
                _custom_data: _custom_data
                mode: mode
                phone: phone

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class SwitchportPortSecurity(AvdBase):
        class MacAddress(AvdBase):
            _fields = ("_custom_data", "aging", "moveable")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            aging: bool | None = None
            moveable: bool | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, aging: bool | None = None, moveable: bool | None = None) -> None:
                """
                MacAddress.

                Args:
                -----
                    _custom_data: _custom_data
                    aging: aging
                    moveable: moveable

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "mac_address", "persistence_disabled", "violation_protect_chip_based")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        mac_address: MacAddress | None = None
        persistence_disabled: bool | None = None
        violation_protect_chip_based: bool | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            mac_address: MacAddress | None = None,
            persistence_disabled: bool | None = None,
            violation_protect_chip_based: bool | None = None,
        ) -> None:
            """
            SwitchportPortSecurity.

            Args:
            -----
                _custom_data: _custom_data
                mac_address: mac_address
                persistence_disabled: persistence_disabled
                violation_protect_chip_based: violation_protect_chip_based

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class SyncE(AvdBase):
        _fields = ("_custom_data", "network_option")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        network_option: Annotated[int, Min[1], Max[2]] = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, network_option: Annotated[int, Min[1], Max[2]] = None) -> None:
            """
            SyncE.

            Args:
            -----
                _custom_data: _custom_data
                network_option: network_option

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class System(AvdBase):
        class ControlPlane(AvdBase):
            class TcpMss(AvdBase):
                _fields = ("_custom_data", "ipv4", "ipv6")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ipv4: int | None = None
                """Segment size."""
                ipv6: int | None = None
                """Segment size."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, ipv4: int | None = None, ipv6: int | None = None) -> None:
                    """
                    TcpMss.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ipv4: Segment size.
                        ipv6: Segment size.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv4AccessGroupsItem(AvdBase):
                _fields = ("_custom_data", "acl_name", "vrf")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                acl_name: str = None
                vrf: str | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, acl_name: str = None, vrf: str | None = None) -> None:
                    """
                    Ipv4AccessGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        acl_name: acl_name
                        vrf: vrf

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv6AccessGroupsItem(AvdBase):
                _fields = ("_custom_data", "acl_name", "vrf")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                acl_name: str = None
                vrf: str | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, acl_name: str = None, vrf: str | None = None) -> None:
                    """
                    Ipv6AccessGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        acl_name: acl_name
                        vrf: vrf

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "tcp_mss", "ipv4_access_groups", "ipv6_access_groups")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            tcp_mss: TcpMss | None = None
            ipv4_access_groups: list[Ipv4AccessGroupsItem] | None = None
            ipv6_access_groups: list[Ipv6AccessGroupsItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                tcp_mss: TcpMss | None = None,
                ipv4_access_groups: list[Ipv4AccessGroupsItem] | None = None,
                ipv6_access_groups: list[Ipv6AccessGroupsItem] | None = None,
            ) -> None:
                """
                ControlPlane.

                Args:
                -----
                    _custom_data: _custom_data
                    tcp_mss: tcp_mss
                    ipv4_access_groups: ipv4_access_groups
                    ipv6_access_groups: ipv6_access_groups

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class L1(AvdBase):
            _fields = ("_custom_data", "unsupported_speed_action", "unsupported_error_correction_action")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            unsupported_speed_action: Annotated[str, ValidValues["error", "warn"]] | None = None
            unsupported_error_correction_action: Annotated[str, ValidValues["error", "warn"]] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                unsupported_speed_action: Annotated[str, ValidValues["error", "warn"]] | None = None,
                unsupported_error_correction_action: Annotated[str, ValidValues["error", "warn"]] | None = None,
            ) -> None:
                """
                L1.

                Args:
                -----
                    _custom_data: _custom_data
                    unsupported_speed_action: unsupported_speed_action
                    unsupported_error_correction_action: unsupported_error_correction_action

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "control_plane", "l1")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        control_plane: ControlPlane | None = None
        l1: L1 | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, control_plane: ControlPlane | None = None, l1: L1 | None = None) -> None:
            """
            System.

            Args:
            -----
                _custom_data: _custom_data
                control_plane: control_plane
                l1: l1

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class TacacsServers(AvdBase):
        class HostsItem(AvdBase):
            _fields = ("_custom_data", "host", "vrf", "key", "key_type", "single_connection", "timeout")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            host: str | None = None
            """Host IP address or name."""
            vrf: str | None = None
            key: str | None = None
            """Encrypted key."""
            key_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = "7"
            single_connection: bool | None = None
            timeout: Annotated[int, Min[1], Max[1000]] | None = None
            """Timeout in seconds."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                host: str | None = None,
                vrf: str | None = None,
                key: str | None = None,
                key_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = "7",
                single_connection: bool | None = None,
                timeout: Annotated[int, Min[1], Max[1000]] | None = None,
            ) -> None:
                """
                HostsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    host: Host IP address or name.
                    vrf: vrf
                    key: Encrypted key.
                    key_type: key_type
                    single_connection: single_connection
                    timeout: Timeout in seconds.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "timeout", "hosts", "policy_unknown_mandatory_attribute_ignore")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        timeout: Annotated[int, Min[1], Max[1000]] | None = None
        """Timeout in seconds."""
        hosts: list[HostsItem] | None = None
        policy_unknown_mandatory_attribute_ignore: bool | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            timeout: Annotated[int, Min[1], Max[1000]] | None = None,
            hosts: list[HostsItem] | None = None,
            policy_unknown_mandatory_attribute_ignore: bool | None = None,
        ) -> None:
            """
            TacacsServers.

            Args:
            -----
                _custom_data: _custom_data
                timeout: Timeout in seconds.
                hosts: hosts
                policy_unknown_mandatory_attribute_ignore: policy_unknown_mandatory_attribute_ignore

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class TapAggregation(AvdBase):
        class Mode(AvdBase):
            class Exclusive(AvdBase):
                _fields = ("_custom_data", "enabled", "profile", "no_errdisable")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool | None = None
                profile: str | None = None
                """Profile Name."""
                no_errdisable: list[str] | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    enabled: bool | None = None,
                    profile: str | None = None,
                    no_errdisable: list[str] | None = None,
                ) -> None:
                    """
                    Exclusive.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        profile: Profile Name.
                        no_errdisable: no_errdisable

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "exclusive")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            exclusive: Exclusive | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, exclusive: Exclusive | None = None) -> None:
                """
                Mode.

                Args:
                -----
                    _custom_data: _custom_data
                    exclusive: exclusive

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Mac(AvdBase):
            class Timestamp(AvdBase):
                class Header(AvdBase):
                    _fields = ("_custom_data", "format", "eth_type")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    format: Annotated[str, ValidValues["48-bit", "64-bit"]] | None = None
                    eth_type: int | None = None
                    """EtherType."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        format: Annotated[str, ValidValues["48-bit", "64-bit"]] | None = None,
                        eth_type: int | None = None,
                    ) -> None:
                        """
                        Header.

                        Args:
                        -----
                            _custom_data: _custom_data
                            format: format
                            eth_type: EtherType.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "replace_source_mac", "header")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                replace_source_mac: bool | None = None
                header: Header | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, replace_source_mac: bool | None = None, header: Header | None = None) -> None:
                    """
                    Timestamp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        replace_source_mac: replace_source_mac
                        header: header

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "timestamp", "fcs_append", "fcs_error")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            timestamp: Timestamp | None = None
            """
            mac.timestamp.replace_source_mac and mac.timestamp.header.format are mutually exclsuive. If both are
            defined, replace_source_mac takes precedence.
            """
            fcs_append: bool | None = None
            """
            mac.fcs_append and mac.fcs_error are mutually exclusive. If both are defined, mac.fcs_append takes
            precedence.
            """
            fcs_error: Annotated[str, ValidValues["correct", "discard", "pass-through"]] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                timestamp: Timestamp | None = None,
                fcs_append: bool | None = None,
                fcs_error: Annotated[str, ValidValues["correct", "discard", "pass-through"]] | None = None,
            ) -> None:
                """
                Mac.

                Args:
                -----
                    _custom_data: _custom_data
                    timestamp:
                       mac.timestamp.replace_source_mac and mac.timestamp.header.format are mutually exclsuive. If both are
                       defined, replace_source_mac takes precedence.
                    fcs_append:
                       mac.fcs_append and mac.fcs_error are mutually exclusive. If both are defined, mac.fcs_append takes
                       precedence.
                    fcs_error: fcs_error

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "mode", "encapsulation_dot1br_strip", "encapsulation_vn_tag_strip", "protocol_lldp_trap", "truncation_size", "mac")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        mode: Mode | None = None
        encapsulation_dot1br_strip: bool | None = None
        encapsulation_vn_tag_strip: bool | None = None
        protocol_lldp_trap: bool | None = None
        truncation_size: int | None = None
        """Allowed truncation_size values vary depending on the platform."""
        mac: Mac | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            mode: Mode | None = None,
            encapsulation_dot1br_strip: bool | None = None,
            encapsulation_vn_tag_strip: bool | None = None,
            protocol_lldp_trap: bool | None = None,
            truncation_size: int | None = None,
            mac: Mac | None = None,
        ) -> None:
            """
            TapAggregation.

            Args:
            -----
                _custom_data: _custom_data
                mode: mode
                encapsulation_dot1br_strip: encapsulation_dot1br_strip
                encapsulation_vn_tag_strip: encapsulation_vn_tag_strip
                protocol_lldp_trap: protocol_lldp_trap
                truncation_size: Allowed truncation_size values vary depending on the platform.
                mac: mac

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class TcamProfile(AvdBase):
        class ProfilesItem(AvdBase):
            _fields = ("_custom_data", "name", "config", "source")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Tcam-Profile Name."""
            config: str | None = None
            """
            TCAM Profile Config. Since these can be very long, it is often a good idea to import the config from
            a file.
            Example: "{{ lookup('file', 'TCAM_TRAFFIC_POLICY.conf') }}"
            """
            source: str | None = None
            """
            TCAM profile local source path. Used to read the TCAM profile from a local path existing on the
            device.
            """

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, config: str | None = None, source: str | None = None) -> None:
                """
                ProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Tcam-Profile Name.
                    config:
                       TCAM Profile Config. Since these can be very long, it is often a good idea to import the config from
                       a file.
                       Example: "{{ lookup('file', 'TCAM_TRAFFIC_POLICY.conf') }}"
                    source:
                       TCAM profile local source path. Used to read the TCAM profile from a local path existing on the
                       device.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "system", "profiles")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        system: str | None = None
        """TCAM profile name to activate."""
        profiles: list[ProfilesItem] | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, system: str | None = None, profiles: list[ProfilesItem] | None = None) -> None:
            """
            TcamProfile.

            Args:
            -----
                _custom_data: _custom_data
                system: TCAM profile name to activate.
                profiles: profiles

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Terminal(AvdBase):
        _fields = ("_custom_data", "length", "width")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        length: Annotated[int, Max[32767]] | None = None
        width: Annotated[int, Min[10], Max[32767]] | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            length: Annotated[int, Max[32767]] | None = None,
            width: Annotated[int, Min[10], Max[32767]] | None = None,
        ) -> None:
            """
            Terminal.

            Args:
            -----
                _custom_data: _custom_data
                length: length
                width: width

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class TrackersItem(AvdBase):
        _fields = ("_custom_data", "name", "interface", "tracked_property")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Name of tracker object."""
        interface: str = None
        """Name of tracked interface."""
        tracked_property: str | None = "line-protocol"
        """Property to track."""

        def __init__(
            self, *, _custom_data: dict[str, Any] | None = None, name: str = None, interface: str = None, tracked_property: str | None = "line-protocol"
        ) -> None:
            """
            TrackersItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Name of tracker object.
                interface: Name of tracked interface.
                tracked_property: Property to track.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class TrafficPolicies(AvdBase):
        class Options(AvdBase):
            _fields = ("_custom_data", "counter_per_interface")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            counter_per_interface: bool | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, counter_per_interface: bool | None = None) -> None:
                """
                Options.

                Args:
                -----
                    _custom_data: _custom_data
                    counter_per_interface: counter_per_interface

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class FieldSets(AvdBase):
            class Ipv4Item(AvdBase):
                _fields = ("_custom_data", "name", "prefixes")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """IPv4 Prefix Field Set Name."""
                prefixes: list[str] | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, prefixes: list[str] | None = None) -> None:
                    """
                    Ipv4Item.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: IPv4 Prefix Field Set Name.
                        prefixes: prefixes

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv6Item(AvdBase):
                _fields = ("_custom_data", "name", "prefixes")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """IPv6 Prefix Field Set Name."""
                prefixes: list[str] | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, prefixes: list[str] | None = None) -> None:
                    """
                    Ipv6Item.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: IPv6 Prefix Field Set Name.
                        prefixes: prefixes

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PortsItem(AvdBase):
                _fields = ("_custom_data", "name", "port_range")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """L4 Port Field Set Name."""
                port_range: str | None = None
                """Example: '10,20,80,440-450'"""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, port_range: str | None = None) -> None:
                    """
                    PortsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: L4 Port Field Set Name.
                        port_range: Example: '10,20,80,440-450'

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "ipv4", "ipv6", "ports")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv4: list[Ipv4Item] | None = None
            ipv6: list[Ipv6Item] | None = None
            ports: list[PortsItem] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                ipv4: list[Ipv4Item] | None = None,
                ipv6: list[Ipv6Item] | None = None,
                ports: list[PortsItem] | None = None,
            ) -> None:
                """
                FieldSets.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: ipv4
                    ipv6: ipv6
                    ports: ports

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PoliciesItem(AvdBase):
            class MatchesItem(AvdBase):
                class Source(AvdBase):
                    _fields = ("_custom_data", "prefixes", "prefix_lists")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    prefixes: list[str] | None = None
                    prefix_lists: list[str] | None = None
                    """Field-set prefix lists."""

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, prefixes: list[str] | None = None, prefix_lists: list[str] | None = None
                    ) -> None:
                        """
                        Source.

                        Args:
                        -----
                            _custom_data: _custom_data
                            prefixes: prefixes
                            prefix_lists: Field-set prefix lists.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Destination(AvdBase):
                    _fields = ("_custom_data", "prefixes", "prefix_lists")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    prefixes: list[str] | None = None
                    prefix_lists: list[str] | None = None
                    """Field-set prefix lists."""

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, prefixes: list[str] | None = None, prefix_lists: list[str] | None = None
                    ) -> None:
                        """
                        Destination.

                        Args:
                        -----
                            _custom_data: _custom_data
                            prefixes: prefixes
                            prefix_lists: Field-set prefix lists.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Fragment(AvdBase):
                    _fields = ("_custom_data", "offset")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    offset: str | None = None
                    """Fragment offset range."""

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, offset: str | None = None) -> None:
                        """
                        Fragment.

                        Args:
                        -----
                            _custom_data: _custom_data
                            offset: Fragment offset range.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class ProtocolsItem(AvdBase):
                    _fields = ("_custom_data", "protocol", "src_port", "dst_port", "src_field", "dst_field", "flags", "icmp_type", "enforce_gtsm")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    protocol: str = None
                    src_port: str | None = None
                    """Port range."""
                    dst_port: str | None = None
                    """Port range."""
                    src_field: str | None = None
                    """L4 port range field set."""
                    dst_field: str | None = None
                    """L4 port range field set."""
                    flags: list[Annotated[str, ValidValues["established", "initial"]]] | None = None
                    icmp_type: list[str] | None = None
                    enforce_gtsm: bool | None = None
                    """Enforce the GTSM for BGP speakers. Only supported when protocol is set to 'neighbors'."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        protocol: str = None,
                        src_port: str | None = None,
                        dst_port: str | None = None,
                        src_field: str | None = None,
                        dst_field: str | None = None,
                        flags: list[Annotated[str, ValidValues["established", "initial"]]] | None = None,
                        icmp_type: list[str] | None = None,
                        enforce_gtsm: bool | None = None,
                    ) -> None:
                        """
                        ProtocolsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            protocol: protocol
                            src_port: Port range.
                            dst_port: Port range.
                            src_field: L4 port range field set.
                            dst_field: L4 port range field set.
                            flags: flags
                            icmp_type: icmp_type
                            enforce_gtsm: Enforce the GTSM for BGP speakers. Only supported when protocol is set to 'neighbors'.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Actions(AvdBase):
                    _fields = ("_custom_data", "dscp", "traffic_class", "count", "drop", "log")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    dscp: int | None = None
                    traffic_class: int | None = None
                    """Traffic class ID."""
                    count: str | None = None
                    """Counter name."""
                    drop: bool | None = None
                    log: bool | None = None
                    """Only supported when action is set to drop."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        dscp: int | None = None,
                        traffic_class: int | None = None,
                        count: str | None = None,
                        drop: bool | None = None,
                        log: bool | None = None,
                    ) -> None:
                        """
                        Actions.

                        Args:
                        -----
                            _custom_data: _custom_data
                            dscp: dscp
                            traffic_class: Traffic class ID.
                            count: Counter name.
                            drop: drop
                            log: Only supported when action is set to drop.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "name", "type", "source", "destination", "ttl", "fragment", "protocols", "actions")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Traffic Policy Item."""
                type: Annotated[str, ValidValues["ipv4", "ipv6"]] = None
                source: Source | None = None
                destination: Destination | None = None
                ttl: str | None = None
                """TTL range."""
                fragment: Fragment | None = None
                """
                The 'fragment' command is not supported when 'source port'
                or 'destination port' command is
                configured.
                """
                protocols: list[ProtocolsItem] | None = None
                actions: Actions | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    type: Annotated[str, ValidValues["ipv4", "ipv6"]] = None,
                    source: Source | None = None,
                    destination: Destination | None = None,
                    ttl: str | None = None,
                    fragment: Fragment | None = None,
                    protocols: list[ProtocolsItem] | None = None,
                    actions: Actions | None = None,
                ) -> None:
                    """
                    MatchesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Traffic Policy Item.
                        type: type
                        source: source
                        destination: destination
                        ttl: TTL range.
                        fragment:
                           The 'fragment' command is not supported when 'source port'
                           or 'destination port' command is
                           configured.
                        protocols: protocols
                        actions: actions

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class DefaultActions(AvdBase):
                class Ipv4(AvdBase):
                    _fields = ("_custom_data", "dscp", "traffic_class", "count", "drop", "log")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    dscp: int | None = None
                    traffic_class: int | None = None
                    """Traffic class ID."""
                    count: str | None = None
                    """Counter name."""
                    drop: bool | None = None
                    log: bool | None = None
                    """Only supported when action is set to drop."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        dscp: int | None = None,
                        traffic_class: int | None = None,
                        count: str | None = None,
                        drop: bool | None = None,
                        log: bool | None = None,
                    ) -> None:
                        """
                        Ipv4.

                        Args:
                        -----
                            _custom_data: _custom_data
                            dscp: dscp
                            traffic_class: Traffic class ID.
                            count: Counter name.
                            drop: drop
                            log: Only supported when action is set to drop.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Ipv6(AvdBase):
                    _fields = ("_custom_data", "dscp", "traffic_class", "count", "drop", "log")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    dscp: int | None = None
                    traffic_class: int | None = None
                    """Traffic class ID."""
                    count: str | None = None
                    """Counter name."""
                    drop: bool | None = None
                    log: bool | None = None
                    """Only supported when action is set to drop."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        dscp: int | None = None,
                        traffic_class: int | None = None,
                        count: str | None = None,
                        drop: bool | None = None,
                        log: bool | None = None,
                    ) -> None:
                        """
                        Ipv6.

                        Args:
                        -----
                            _custom_data: _custom_data
                            dscp: dscp
                            traffic_class: Traffic class ID.
                            count: Counter name.
                            drop: drop
                            log: Only supported when action is set to drop.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "ipv4", "ipv6")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                ipv4: Ipv4 | None = None
                ipv6: Ipv6 | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, ipv4: Ipv4 | None = None, ipv6: Ipv6 | None = None) -> None:
                    """
                    DefaultActions.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ipv4: ipv4
                        ipv6: ipv6

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "name", "matches", "default_actions")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            name: str = None
            """Traffic Policy Name."""
            matches: list[MatchesItem] | None = None
            default_actions: DefaultActions | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                name: str = None,
                matches: list[MatchesItem] | None = None,
                default_actions: DefaultActions | None = None,
            ) -> None:
                """
                PoliciesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Traffic Policy Name.
                    matches: matches
                    default_actions: default_actions

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "options", "field_sets", "policies")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        options: Options | None = None
        field_sets: FieldSets | None = None
        policies: list[PoliciesItem] | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            options: Options | None = None,
            field_sets: FieldSets | None = None,
            policies: list[PoliciesItem] | None = None,
        ) -> None:
            """
            TrafficPolicies.

            Args:
            -----
                _custom_data: _custom_data
                options: options
                field_sets: field_sets
                policies: policies

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class TunnelInterfacesItem(AvdBase):
        class TcpMssCeiling(AvdBase):
            _fields = ("_custom_data", "ipv4", "ipv6", "direction")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv4: Annotated[int, Min[64], Max[65495]] | None = None
            """Segment Size for IPv4."""
            ipv6: Annotated[int, Min[64], Max[65475]] | None = None
            """Segment Size for IPv6."""
            direction: Annotated[str, ValidValues["ingress", "egress"]] | None = None
            """Optional direction ('ingress', 'egress')  for tcp mss ceiling."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                ipv4: Annotated[int, Min[64], Max[65495]] | None = None,
                ipv6: Annotated[int, Min[64], Max[65475]] | None = None,
                direction: Annotated[str, ValidValues["ingress", "egress"]] | None = None,
            ) -> None:
                """
                TcpMssCeiling.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: Segment Size for IPv4.
                    ipv6: Segment Size for IPv6.
                    direction: Optional direction ('ingress', 'egress')  for tcp mss ceiling.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "name",
            "description",
            "shutdown",
            "mtu",
            "vrf",
            "underlay_vrf",
            "ip_address",
            "ipv6_enable",
            "ipv6_address",
            "access_group_in",
            "access_group_out",
            "ipv6_access_group_in",
            "ipv6_access_group_out",
            "tcp_mss_ceiling",
            "tunnel_mode",
            "source_interface",
            "destination",
            "path_mtu_discovery",
            "ipsec_profile",
            "nat_profile",
            "eos_cli",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Tunnel Interface Name."""
        description: str | None = None
        shutdown: bool | None = None
        mtu: Annotated[int, Min[68], Max[65535]] | None = None
        vrf: str | None = None
        """VRF Name."""
        underlay_vrf: str | None = None
        """Underlay VRF Name."""
        ip_address: Annotated[str, Format["ipv4_cidr"]] | None = None
        """IPv4_address/Mask."""
        ipv6_enable: bool | None = None
        ipv6_address: Annotated[str, Format["ipv6_cidr"]] | None = None
        """IPv6_address/Mask."""
        access_group_in: str | None = None
        """IPv4 ACL Name for ingress."""
        access_group_out: str | None = None
        """IPv4 ACL Name for egress."""
        ipv6_access_group_in: str | None = None
        """IPv6 ACL Name for ingress."""
        ipv6_access_group_out: str | None = None
        """IPv6 ACL Name for egress."""
        tcp_mss_ceiling: TcpMssCeiling | None = None
        tunnel_mode: Annotated[str, ValidValues["gre", "ipsec"]] | None = None
        """
        Tunnel encapsulation method.
        `gre`: Generic route encapsulation protocol,
        `ipsec`: IPsec-over-IP
        encapsulation.
        """
        source_interface: str | None = None
        """Tunnel Source Interface Name."""
        destination: str | None = None
        """IPv4 or IPv6 Address Tunnel Destination."""
        path_mtu_discovery: bool | None = None
        """Enable Path MTU Discovery On Tunnel."""
        ipsec_profile: str | None = None
        """
        Used only when `tunnel_mode` is set to `ipsec`.
        It must target a defined IPsec profile.
        """
        nat_profile: str | None = None
        """NAT interface profile."""
        eos_cli: str | None = None
        """
        Multiline String with EOS CLI rendered directly on the Tunnel interface in the final EOS
        configuration.
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str = None,
            description: str | None = None,
            shutdown: bool | None = None,
            mtu: Annotated[int, Min[68], Max[65535]] | None = None,
            vrf: str | None = None,
            underlay_vrf: str | None = None,
            ip_address: Annotated[str, Format["ipv4_cidr"]] | None = None,
            ipv6_enable: bool | None = None,
            ipv6_address: Annotated[str, Format["ipv6_cidr"]] | None = None,
            access_group_in: str | None = None,
            access_group_out: str | None = None,
            ipv6_access_group_in: str | None = None,
            ipv6_access_group_out: str | None = None,
            tcp_mss_ceiling: TcpMssCeiling | None = None,
            tunnel_mode: Annotated[str, ValidValues["gre", "ipsec"]] | None = None,
            source_interface: str | None = None,
            destination: str | None = None,
            path_mtu_discovery: bool | None = None,
            ipsec_profile: str | None = None,
            nat_profile: str | None = None,
            eos_cli: str | None = None,
        ) -> None:
            """
            TunnelInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Tunnel Interface Name.
                description: description
                shutdown: shutdown
                mtu: mtu
                vrf: VRF Name.
                underlay_vrf: Underlay VRF Name.
                ip_address: IPv4_address/Mask.
                ipv6_enable: ipv6_enable
                ipv6_address: IPv6_address/Mask.
                access_group_in: IPv4 ACL Name for ingress.
                access_group_out: IPv4 ACL Name for egress.
                ipv6_access_group_in: IPv6 ACL Name for ingress.
                ipv6_access_group_out: IPv6 ACL Name for egress.
                tcp_mss_ceiling: tcp_mss_ceiling
                tunnel_mode:
                   Tunnel encapsulation method.
                   `gre`: Generic route encapsulation protocol,
                   `ipsec`: IPsec-over-IP
                   encapsulation.
                source_interface: Tunnel Source Interface Name.
                destination: IPv4 or IPv6 Address Tunnel Destination.
                path_mtu_discovery: Enable Path MTU Discovery On Tunnel.
                ipsec_profile:
                   Used only when `tunnel_mode` is set to `ipsec`.
                   It must target a defined IPsec profile.
                nat_profile: NAT interface profile.
                eos_cli:
                   Multiline String with EOS CLI rendered directly on the Tunnel interface in the final EOS
                   configuration.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class VirtualSourceNatVrfsItem(AvdBase):
        _fields = ("_custom_data", "name", "ip_address")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """VRF Name."""
        ip_address: str | None = None
        """IPv4 Address."""

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None, ip_address: str | None = None) -> None:
            """
            VirtualSourceNatVrfsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: VRF Name.
                ip_address: IPv4 Address.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class VlanInterfacesItem(AvdBase):
        class Logging(AvdBase):
            class Event(AvdBase):
                _fields = ("_custom_data", "link_status")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                link_status: bool | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, link_status: bool | None = None) -> None:
                    """
                    Event.

                    Args:
                    -----
                        _custom_data: _custom_data
                        link_status: link_status

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "event")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            event: Event | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, event: Event | None = None) -> None:
                """
                Logging.

                Args:
                -----
                    _custom_data: _custom_data
                    event: event

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IpIgmpHostProxy(AvdBase):
            class GroupsItem(AvdBase):
                class ExcludeItem(AvdBase):
                    _fields = ("_custom_data", "source")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    source: str = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, source: str = None) -> None:
                        """
                        ExcludeItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source: source

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class IncludeItem(AvdBase):
                    _fields = ("_custom_data", "source")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    source: str = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, source: str = None) -> None:
                        """
                        IncludeItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source: source

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "group", "exclude", "include")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                group: str = None
                """Multicast Address."""
                exclude: list[ExcludeItem] | None = None
                """The same source must not be present both in `exclude` and `include` list."""
                include: list[IncludeItem] | None = None
                """The same source must not be present both in `exclude` and `include` list."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    group: str = None,
                    exclude: list[ExcludeItem] | None = None,
                    include: list[IncludeItem] | None = None,
                ) -> None:
                    """
                    GroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        group: Multicast Address.
                        exclude: The same source must not be present both in `exclude` and `include` list.
                        include: The same source must not be present both in `exclude` and `include` list.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AccessListsItem(AvdBase):
                _fields = ("_custom_data", "name")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, name: str = None) -> None:
                    """
                    AccessListsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "enabled", "groups", "report_interval", "access_lists", "version")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool | None = None
            groups: list[GroupsItem] | None = None
            report_interval: Annotated[int, Min[1], Max[31744]] | None = None
            """Time interval between unsolicited reports."""
            access_lists: list[AccessListsItem] | None = None
            """Non-standard Access List name."""
            version: Annotated[int, Min[1], Max[3]] | None = None
            """IGMP version on IGMP host-proxy interface."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enabled: bool | None = None,
                groups: list[GroupsItem] | None = None,
                report_interval: Annotated[int, Min[1], Max[31744]] | None = None,
                access_lists: list[AccessListsItem] | None = None,
                version: Annotated[int, Min[1], Max[3]] | None = None,
            ) -> None:
                """
                IpIgmpHostProxy.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    groups: groups
                    report_interval: Time interval between unsolicited reports.
                    access_lists: Non-standard Access List name.
                    version: IGMP version on IGMP host-proxy interface.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IpHelpersItem(AvdBase):
            _fields = ("_custom_data", "ip_helper", "source_interface", "vrf")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ip_helper: str = None
            """IP address or hostname of DHCP server."""
            source_interface: str | None = None
            """Interface used as source for forwarded DHCP packets."""
            vrf: str | None = None
            """VRF where DHCP server can be reached."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, ip_helper: str = None, source_interface: str | None = None, vrf: str | None = None
            ) -> None:
                """
                IpHelpersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    ip_helper: IP address or hostname of DHCP server.
                    source_interface: Interface used as source for forwarded DHCP packets.
                    vrf: VRF where DHCP server can be reached.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IpNat(AvdBase):
            class Destination(AvdBase):
                class DynamicItem(AvdBase):
                    _fields = ("_custom_data", "access_list", "comment", "pool_name", "priority")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    access_list: str = None
                    comment: str | None = None
                    pool_name: str = None
                    priority: Annotated[int, Max[4294967295]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        access_list: str = None,
                        comment: str | None = None,
                        pool_name: str = None,
                        priority: Annotated[int, Max[4294967295]] | None = None,
                    ) -> None:
                        """
                        DynamicItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: access_list
                            comment: comment
                            pool_name: pool_name
                            priority: priority

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class StaticItem(AvdBase):
                    _fields = (
                        "_custom_data",
                        "access_list",
                        "comment",
                        "direction",
                        "group",
                        "original_ip",
                        "original_port",
                        "priority",
                        "protocol",
                        "translated_ip",
                        "translated_port",
                    )
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    access_list: str | None = None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None = None
                    direction: Annotated[str, ValidValues["egress", "ingress"]] | None = None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: Annotated[int, Min[1], Max[65535]] | None = None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None = None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: Annotated[int, Min[1], Max[65535]] | None = None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: Annotated[int, Max[4294967295]] | None = None
                    protocol: Annotated[str, ValidValues["udp", "tcp"]] | None = None
                    translated_ip: str = None
                    """IPv4 address."""
                    translated_port: Annotated[int, Min[1], Max[65535]] | None = None
                    """requires 'original_port'."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        access_list: str | None = None,
                        comment: str | None = None,
                        direction: Annotated[str, ValidValues["egress", "ingress"]] | None = None,
                        group: Annotated[int, Min[1], Max[65535]] | None = None,
                        original_ip: str | None = None,
                        original_port: Annotated[int, Min[1], Max[65535]] | None = None,
                        priority: Annotated[int, Max[4294967295]] | None = None,
                        protocol: Annotated[str, ValidValues["udp", "tcp"]] | None = None,
                        translated_ip: str = None,
                        translated_port: Annotated[int, Min[1], Max[65535]] | None = None,
                    ) -> None:
                        """
                        StaticItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: 'access_list' and 'group' are mutual exclusive.
                            comment: comment
                            direction:
                               Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                               platform.
                               EOS might remove this keyword in the configuration. So, check the configuration on
                               targeted HW/SW.
                            group: 'access_list' and 'group' are mutual exclusive.
                            original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                            original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                            priority: priority
                            protocol: protocol
                            translated_ip: IPv4 address.
                            translated_port: requires 'original_port'.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "dynamic", "static")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                dynamic: list[DynamicItem] | None = None
                static: list[StaticItem] | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, dynamic: list[DynamicItem] | None = None, static: list[StaticItem] | None = None
                ) -> None:
                    """
                    Destination.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dynamic: dynamic
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Source(AvdBase):
                class DynamicItem(AvdBase):
                    _fields = ("_custom_data", "access_list", "comment", "nat_type", "pool_name", "priority")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    access_list: str = None
                    comment: str | None = None
                    nat_type: Annotated[str, ValidValues["overload", "pool", "pool-address-only", "pool-full-cone"]] = None
                    pool_name: str | None = None
                    """
                    required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                    ignored if 'nat_type' is
                    overload.
                    """
                    priority: Annotated[int, Max[4294967295]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        access_list: str = None,
                        comment: str | None = None,
                        nat_type: Annotated[str, ValidValues["overload", "pool", "pool-address-only", "pool-full-cone"]] = None,
                        pool_name: str | None = None,
                        priority: Annotated[int, Max[4294967295]] | None = None,
                    ) -> None:
                        """
                        DynamicItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: access_list
                            comment: comment
                            nat_type: nat_type
                            pool_name:
                               required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                               ignored if 'nat_type' is
                               overload.
                            priority: priority

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class StaticItem(AvdBase):
                    _fields = (
                        "_custom_data",
                        "access_list",
                        "comment",
                        "direction",
                        "group",
                        "original_ip",
                        "original_port",
                        "priority",
                        "protocol",
                        "translated_ip",
                        "translated_port",
                    )
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    access_list: str | None = None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None = None
                    direction: Annotated[str, ValidValues["egress", "ingress"]] | None = None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: Annotated[int, Min[1], Max[65535]] | None = None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None = None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: Annotated[int, Min[1], Max[65535]] | None = None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: Annotated[int, Max[4294967295]] | None = None
                    protocol: Annotated[str, ValidValues["udp", "tcp"]] | None = None
                    translated_ip: str = None
                    """IPv4 address."""
                    translated_port: Annotated[int, Min[1], Max[65535]] | None = None
                    """requires 'original_port'."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        access_list: str | None = None,
                        comment: str | None = None,
                        direction: Annotated[str, ValidValues["egress", "ingress"]] | None = None,
                        group: Annotated[int, Min[1], Max[65535]] | None = None,
                        original_ip: str | None = None,
                        original_port: Annotated[int, Min[1], Max[65535]] | None = None,
                        priority: Annotated[int, Max[4294967295]] | None = None,
                        protocol: Annotated[str, ValidValues["udp", "tcp"]] | None = None,
                        translated_ip: str = None,
                        translated_port: Annotated[int, Min[1], Max[65535]] | None = None,
                    ) -> None:
                        """
                        StaticItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: 'access_list' and 'group' are mutual exclusive.
                            comment: comment
                            direction:
                               Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                               platform.
                               EOS might remove this keyword in the configuration. So, check the configuration on
                               targeted HW/SW.
                            group: 'access_list' and 'group' are mutual exclusive.
                            original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                            original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                            priority: priority
                            protocol: protocol
                            translated_ip: IPv4 address.
                            translated_port: requires 'original_port'.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "dynamic", "static")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                dynamic: list[DynamicItem] | None = None
                static: list[StaticItem] | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, dynamic: list[DynamicItem] | None = None, static: list[StaticItem] | None = None
                ) -> None:
                    """
                    Source.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dynamic: dynamic
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "destination", "source")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            destination: Destination | None = None
            source: Source | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, destination: Destination | None = None, source: Source | None = None) -> None:
                """
                IpNat.

                Args:
                -----
                    _custom_data: _custom_data
                    destination: destination
                    source: source

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6NdCache(AvdBase):
            _fields = ("_custom_data", "dynamic_capacity", "expire", "refresh_always")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            dynamic_capacity: Annotated[int, Max[4294967295]] | None = None
            """Capacity of dynamic cache entries."""
            expire: Annotated[int, Min[1], Max[65535]] | None = None
            """Cache entries expirery in seconds."""
            refresh_always: bool | None = None
            """Force refresh on cache expiry."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                dynamic_capacity: Annotated[int, Max[4294967295]] | None = None,
                expire: Annotated[int, Min[1], Max[65535]] | None = None,
                refresh_always: bool | None = None,
            ) -> None:
                """
                Ipv6NdCache.

                Args:
                -----
                    _custom_data: _custom_data
                    dynamic_capacity: Capacity of dynamic cache entries.
                    expire: Cache entries expirery in seconds.
                    refresh_always: Force refresh on cache expiry.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6NdPrefixesItem(AvdBase):
            _fields = ("_custom_data", "ipv6_prefix", "valid_lifetime", "preferred_lifetime", "no_autoconfig_flag")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv6_prefix: str = None
            """IPv6_address/Mask."""
            valid_lifetime: str | None = None
            """In seconds <0-4294967295> or infinite."""
            preferred_lifetime: str | None = None
            """In seconds <0-4294967295> or infinite."""
            no_autoconfig_flag: bool | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                ipv6_prefix: str = None,
                valid_lifetime: str | None = None,
                preferred_lifetime: str | None = None,
                no_autoconfig_flag: bool | None = None,
            ) -> None:
                """
                Ipv6NdPrefixesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv6_prefix: IPv6_address/Mask.
                    valid_lifetime: In seconds <0-4294967295> or infinite.
                    preferred_lifetime: In seconds <0-4294967295> or infinite.
                    no_autoconfig_flag: no_autoconfig_flag

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6DhcpRelayDestinationsItem(AvdBase):
            _fields = ("_custom_data", "address", "vrf", "local_interface", "source_address", "link_address")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            address: str = None
            """DHCP server's IPv6 address."""
            vrf: str | None = None
            local_interface: str | None = None
            """Local interface to communicate with DHCP server - mutually exclusive to source_address."""
            source_address: str | None = None
            """Source IPv6 address to communicate with DHCP server - mutually exclusive to local_interface."""
            link_address: str | None = None
            """Override the default link address specified in the relayed DHCP packet."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                address: str = None,
                vrf: str | None = None,
                local_interface: str | None = None,
                source_address: str | None = None,
                link_address: str | None = None,
            ) -> None:
                """
                Ipv6DhcpRelayDestinationsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    address: DHCP server's IPv6 address.
                    vrf: vrf
                    local_interface: Local interface to communicate with DHCP server - mutually exclusive to source_address.
                    source_address: Source IPv6 address to communicate with DHCP server - mutually exclusive to local_interface.
                    link_address: Override the default link address specified in the relayed DHCP packet.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Multicast(AvdBase):
            class Ipv4(AvdBase):
                class BoundariesItem(AvdBase):
                    _fields = ("_custom_data", "boundary", "out")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    boundary: str = None
                    """IPv4 access-list name or IPv4 multicast group prefix with mask."""
                    out: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, boundary: str = None, out: bool | None = None) -> None:
                        """
                        BoundariesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            boundary: IPv4 access-list name or IPv4 multicast group prefix with mask.
                            out: out

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class SourceRouteExport(AvdBase):
                    _fields = ("_custom_data", "enabled", "administrative_distance")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    administrative_distance: Annotated[int, Min[1], Max[255]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        enabled: bool = None,
                        administrative_distance: Annotated[int, Min[1], Max[255]] | None = None,
                    ) -> None:
                        """
                        SourceRouteExport.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            administrative_distance: administrative_distance

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "boundaries", "source_route_export", "static")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                boundaries: list[BoundariesItem] | None = None
                """
                Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
                of both.
                """
                source_route_export: SourceRouteExport | None = None
                static: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    boundaries: list[BoundariesItem] | None = None,
                    source_route_export: SourceRouteExport | None = None,
                    static: bool | None = None,
                ) -> None:
                    """
                    Ipv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        boundaries:
                           Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
                           of both.
                        source_route_export: source_route_export
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv6(AvdBase):
                class BoundariesItem(AvdBase):
                    _fields = ("_custom_data", "boundary")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    boundary: str = None
                    """IPv6 access-list name or IPv6 multicast group prefix with mask."""

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, boundary: str = None) -> None:
                        """
                        BoundariesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            boundary: IPv6 access-list name or IPv6 multicast group prefix with mask.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class SourceRouteExport(AvdBase):
                    _fields = ("_custom_data", "enabled", "administrative_distance")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool = None
                    administrative_distance: Annotated[int, Min[1], Max[255]] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        enabled: bool = None,
                        administrative_distance: Annotated[int, Min[1], Max[255]] | None = None,
                    ) -> None:
                        """
                        SourceRouteExport.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            administrative_distance: administrative_distance

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "boundaries", "source_route_export", "static")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                boundaries: list[BoundariesItem] | None = None
                """
                Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
                of both.
                """
                source_route_export: SourceRouteExport | None = None
                static: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    boundaries: list[BoundariesItem] | None = None,
                    source_route_export: SourceRouteExport | None = None,
                    static: bool | None = None,
                ) -> None:
                    """
                    Ipv6.

                    Args:
                    -----
                        _custom_data: _custom_data
                        boundaries:
                           Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
                           of both.
                        source_route_export: source_route_export
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "ipv4", "ipv6")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv4: Ipv4 | None = None
            ipv6: Ipv6 | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, ipv4: Ipv4 | None = None, ipv6: Ipv6 | None = None) -> None:
                """
                Multicast.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: ipv4
                    ipv6: ipv6

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class OspfMessageDigestKeysItem(AvdBase):
            _fields = ("_custom_data", "id", "hash_algorithm", "key")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            id: int = None
            hash_algorithm: Annotated[str, ValidValues["md5", "sha1", "sha256", "sha384", "sha512"]] | None = None
            key: str | None = None
            """Encrypted password."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                id: int = None,
                hash_algorithm: Annotated[str, ValidValues["md5", "sha1", "sha256", "sha384", "sha512"]] | None = None,
                key: str | None = None,
            ) -> None:
                """
                OspfMessageDigestKeysItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: id
                    hash_algorithm: hash_algorithm
                    key: Encrypted password.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Pim(AvdBase):
            class Ipv4(AvdBase):
                class Hello(AvdBase):
                    _fields = ("_custom_data", "count", "interval")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    count: str | None = None
                    """Number of missed hellos after which the neighbor expires. Range <1.5-65535>."""
                    interval: Annotated[int, Min[1], Max[65535]] | None = None
                    """PIM hello interval in seconds."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        count: str | None = None,
                        interval: Annotated[int, Min[1], Max[65535]] | None = None,
                    ) -> None:
                        """
                        Hello.

                        Args:
                        -----
                            _custom_data: _custom_data
                            count: Number of missed hellos after which the neighbor expires. Range <1.5-65535>.
                            interval: PIM hello interval in seconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "border_router", "dr_priority", "sparse_mode", "local_interface", "bfd", "bidirectional", "hello")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                border_router: bool | None = None
                """Configure PIM border router. EOS default is false."""
                dr_priority: Annotated[int, Max[429467295]] | None = None
                sparse_mode: bool | None = None
                local_interface: str | None = None
                bfd: bool | None = None
                """Set the default for whether Bidirectional Forwarding Detection is enabled for PIM."""
                bidirectional: bool | None = None
                hello: Hello | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    border_router: bool | None = None,
                    dr_priority: Annotated[int, Max[429467295]] | None = None,
                    sparse_mode: bool | None = None,
                    local_interface: str | None = None,
                    bfd: bool | None = None,
                    bidirectional: bool | None = None,
                    hello: Hello | None = None,
                ) -> None:
                    """
                    Ipv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        border_router: Configure PIM border router. EOS default is false.
                        dr_priority: dr_priority
                        sparse_mode: sparse_mode
                        local_interface: local_interface
                        bfd: Set the default for whether Bidirectional Forwarding Detection is enabled for PIM.
                        bidirectional: bidirectional
                        hello: hello

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "ipv4")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            ipv4: Ipv4 | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, ipv4: Ipv4 | None = None) -> None:
                """
                Pim.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: ipv4

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IsisAuthentication(AvdBase):
            class Both(AvdBase):
                class KeyIdsItem(AvdBase):
                    _fields = ("_custom_data", "id", "algorithm", "key_type", "key", "rfc_5310")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    id: Annotated[int, Min[1], Max[65535]] = None
                    """Configure authentication key-id."""
                    algorithm: Annotated[str, ValidValues["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None
                    key_type: Annotated[str, ValidValues["0", "7", "8a"]] = None
                    """Configure authentication key type."""
                    key: str = None
                    """Password string."""
                    rfc_5310: bool | None = None
                    """SHA digest computation according to rfc5310."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        id: Annotated[int, Min[1], Max[65535]] = None,
                        algorithm: Annotated[str, ValidValues["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None,
                        key_type: Annotated[str, ValidValues["0", "7", "8a"]] = None,
                        key: str = None,
                        rfc_5310: bool | None = None,
                    ) -> None:
                        """
                        KeyIdsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: Configure authentication key-id.
                            algorithm: algorithm
                            key_type: Configure authentication key type.
                            key: Password string.
                            rfc_5310: SHA digest computation according to rfc5310.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Sha(AvdBase):
                    _fields = ("_custom_data", "key_id")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    key_id: Annotated[int, Min[1], Max[65535]] = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, key_id: Annotated[int, Min[1], Max[65535]] = None) -> None:
                        """
                        Sha.

                        Args:
                        -----
                            _custom_data: _custom_data
                            key_id: key_id

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class SharedSecret(AvdBase):
                    _fields = ("_custom_data", "profile", "algorithm")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    profile: str = None
                    algorithm: Annotated[str, ValidValues["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        profile: str = None,
                        algorithm: Annotated[str, ValidValues["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None,
                    ) -> None:
                        """
                        SharedSecret.

                        Args:
                        -----
                            _custom_data: _custom_data
                            profile: profile
                            algorithm: algorithm

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "key_type", "key", "key_ids", "mode", "sha", "shared_secret", "rx_disabled")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                key_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = None
                """Configure authentication key type."""
                key: str | None = None
                """Password string. `key_type` is required for this setting."""
                key_ids: list[KeyIdsItem] | None = None
                mode: Annotated[str, ValidValues["md5", "sha", "text", "shared-secret"]] | None = None
                """Authentication mode."""
                sha: Sha | None = None
                """Required settings for authentication mode 'sha'."""
                shared_secret: SharedSecret | None = None
                """Required settings for authentication mode 'shared_secret'."""
                rx_disabled: bool | None = None
                """Disable authentication check on the receive side."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    key_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = None,
                    key: str | None = None,
                    key_ids: list[KeyIdsItem] | None = None,
                    mode: Annotated[str, ValidValues["md5", "sha", "text", "shared-secret"]] | None = None,
                    sha: Sha | None = None,
                    shared_secret: SharedSecret | None = None,
                    rx_disabled: bool | None = None,
                ) -> None:
                    """
                    Both.

                    Args:
                    -----
                        _custom_data: _custom_data
                        key_type: Configure authentication key type.
                        key: Password string. `key_type` is required for this setting.
                        key_ids: key_ids
                        mode: Authentication mode.
                        sha: Required settings for authentication mode 'sha'.
                        shared_secret: Required settings for authentication mode 'shared_secret'.
                        rx_disabled: Disable authentication check on the receive side.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Level1(AvdBase):
                class KeyIdsItem(AvdBase):
                    _fields = ("_custom_data", "id", "algorithm", "key_type", "key", "rfc_5310")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    id: Annotated[int, Min[1], Max[65535]] = None
                    """Configure authentication key-id."""
                    algorithm: Annotated[str, ValidValues["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None
                    key_type: Annotated[str, ValidValues["0", "7", "8a"]] = None
                    """Configure authentication key type."""
                    key: str = None
                    """Password string."""
                    rfc_5310: bool | None = None
                    """SHA digest computation according to rfc5310."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        id: Annotated[int, Min[1], Max[65535]] = None,
                        algorithm: Annotated[str, ValidValues["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None,
                        key_type: Annotated[str, ValidValues["0", "7", "8a"]] = None,
                        key: str = None,
                        rfc_5310: bool | None = None,
                    ) -> None:
                        """
                        KeyIdsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: Configure authentication key-id.
                            algorithm: algorithm
                            key_type: Configure authentication key type.
                            key: Password string.
                            rfc_5310: SHA digest computation according to rfc5310.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Sha(AvdBase):
                    _fields = ("_custom_data", "key_id")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    key_id: Annotated[int, Min[1], Max[65535]] = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, key_id: Annotated[int, Min[1], Max[65535]] = None) -> None:
                        """
                        Sha.

                        Args:
                        -----
                            _custom_data: _custom_data
                            key_id: key_id

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class SharedSecret(AvdBase):
                    _fields = ("_custom_data", "profile", "algorithm")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    profile: str = None
                    algorithm: Annotated[str, ValidValues["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        profile: str = None,
                        algorithm: Annotated[str, ValidValues["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None,
                    ) -> None:
                        """
                        SharedSecret.

                        Args:
                        -----
                            _custom_data: _custom_data
                            profile: profile
                            algorithm: algorithm

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "key_type", "key", "key_ids", "mode", "sha", "shared_secret", "rx_disabled")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                key_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = None
                """Configure authentication key type."""
                key: str | None = None
                """Password string. `key_type` is required for this setting."""
                key_ids: list[KeyIdsItem] | None = None
                mode: Annotated[str, ValidValues["md5", "sha", "text", "shared-secret"]] | None = None
                """Authentication mode."""
                sha: Sha | None = None
                """Required settings for authentication mode 'sha'."""
                shared_secret: SharedSecret | None = None
                """Required settings for authentication mode 'shared_secret'."""
                rx_disabled: bool | None = None
                """Disable authentication check on the receive side."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    key_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = None,
                    key: str | None = None,
                    key_ids: list[KeyIdsItem] | None = None,
                    mode: Annotated[str, ValidValues["md5", "sha", "text", "shared-secret"]] | None = None,
                    sha: Sha | None = None,
                    shared_secret: SharedSecret | None = None,
                    rx_disabled: bool | None = None,
                ) -> None:
                    """
                    Level1.

                    Args:
                    -----
                        _custom_data: _custom_data
                        key_type: Configure authentication key type.
                        key: Password string. `key_type` is required for this setting.
                        key_ids: key_ids
                        mode: Authentication mode.
                        sha: Required settings for authentication mode 'sha'.
                        shared_secret: Required settings for authentication mode 'shared_secret'.
                        rx_disabled: Disable authentication check on the receive side.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Level2(AvdBase):
                class KeyIdsItem(AvdBase):
                    _fields = ("_custom_data", "id", "algorithm", "key_type", "key", "rfc_5310")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    id: Annotated[int, Min[1], Max[65535]] = None
                    """Configure authentication key-id."""
                    algorithm: Annotated[str, ValidValues["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None
                    key_type: Annotated[str, ValidValues["0", "7", "8a"]] = None
                    """Configure authentication key type."""
                    key: str = None
                    """Password string."""
                    rfc_5310: bool | None = None
                    """SHA digest computation according to rfc5310."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        id: Annotated[int, Min[1], Max[65535]] = None,
                        algorithm: Annotated[str, ValidValues["sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None,
                        key_type: Annotated[str, ValidValues["0", "7", "8a"]] = None,
                        key: str = None,
                        rfc_5310: bool | None = None,
                    ) -> None:
                        """
                        KeyIdsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: Configure authentication key-id.
                            algorithm: algorithm
                            key_type: Configure authentication key type.
                            key: Password string.
                            rfc_5310: SHA digest computation according to rfc5310.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Sha(AvdBase):
                    _fields = ("_custom_data", "key_id")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    key_id: Annotated[int, Min[1], Max[65535]] = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, key_id: Annotated[int, Min[1], Max[65535]] = None) -> None:
                        """
                        Sha.

                        Args:
                        -----
                            _custom_data: _custom_data
                            key_id: key_id

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class SharedSecret(AvdBase):
                    _fields = ("_custom_data", "profile", "algorithm")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    profile: str = None
                    algorithm: Annotated[str, ValidValues["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        profile: str = None,
                        algorithm: Annotated[str, ValidValues["md5", "sha-1", "sha-224", "sha-256", "sha-384", "sha-512"]] = None,
                    ) -> None:
                        """
                        SharedSecret.

                        Args:
                        -----
                            _custom_data: _custom_data
                            profile: profile
                            algorithm: algorithm

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "key_type", "key", "key_ids", "mode", "sha", "shared_secret", "rx_disabled")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                key_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = None
                """Configure authentication key type."""
                key: str | None = None
                """Password string. `key_type` is required for this setting."""
                key_ids: list[KeyIdsItem] | None = None
                mode: Annotated[str, ValidValues["md5", "sha", "text", "shared-secret"]] | None = None
                """Authentication mode."""
                sha: Sha | None = None
                """Required settings for authentication mode 'sha'."""
                shared_secret: SharedSecret | None = None
                """Required settings for authentication mode 'shared_secret'."""
                rx_disabled: bool | None = None
                """Disable authentication check on the receive side."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    key_type: Annotated[str, ValidValues["0", "7", "8a"]] | None = None,
                    key: str | None = None,
                    key_ids: list[KeyIdsItem] | None = None,
                    mode: Annotated[str, ValidValues["md5", "sha", "text", "shared-secret"]] | None = None,
                    sha: Sha | None = None,
                    shared_secret: SharedSecret | None = None,
                    rx_disabled: bool | None = None,
                ) -> None:
                    """
                    Level2.

                    Args:
                    -----
                        _custom_data: _custom_data
                        key_type: Configure authentication key type.
                        key: Password string. `key_type` is required for this setting.
                        key_ids: key_ids
                        mode: Authentication mode.
                        sha: Required settings for authentication mode 'sha'.
                        shared_secret: Required settings for authentication mode 'shared_secret'.
                        rx_disabled: Disable authentication check on the receive side.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "both", "level_1", "level_2")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            both: Both | None = None
            """
            Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
            'level_2' settings.
            """
            level_1: Level1 | None = None
            """Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings."""
            level_2: Level2 | None = None
            """Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, both: Both | None = None, level_1: Level1 | None = None, level_2: Level2 | None = None
            ) -> None:
                """
                IsisAuthentication.

                Args:
                -----
                    _custom_data: _custom_data
                    both:
                       Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
                       'level_2' settings.
                    level_1: Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings.
                    level_2: Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrrpIdsItem(AvdBase):
            class Advertisement(AvdBase):
                _fields = ("_custom_data", "interval")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                interval: Annotated[int, Min[1], Max[255]] | None = None
                """Interval in seconds."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, interval: Annotated[int, Min[1], Max[255]] | None = None) -> None:
                    """
                    Advertisement.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interval: Interval in seconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Preempt(AvdBase):
                class Delay(AvdBase):
                    _fields = ("_custom_data", "minimum", "reload")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    minimum: Annotated[int, Max[3600]] | None = None
                    """Minimum preempt delay in seconds."""
                    reload: Annotated[int, Max[3600]] | None = None
                    """Reload preempt delay in seconds."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        minimum: Annotated[int, Max[3600]] | None = None,
                        reload: Annotated[int, Max[3600]] | None = None,
                    ) -> None:
                        """
                        Delay.

                        Args:
                        -----
                            _custom_data: _custom_data
                            minimum: Minimum preempt delay in seconds.
                            reload: Reload preempt delay in seconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "enabled", "delay")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                enabled: bool = None
                delay: Delay | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, delay: Delay | None = None) -> None:
                    """
                    Preempt.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        delay: delay

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Timers(AvdBase):
                class Delay(AvdBase):
                    _fields = ("_custom_data", "reload")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    reload: Annotated[int, Max[3600]] | None = None
                    """Delay after reload in seconds."""

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, reload: Annotated[int, Max[3600]] | None = None) -> None:
                        """
                        Delay.

                        Args:
                        -----
                            _custom_data: _custom_data
                            reload: Delay after reload in seconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = ("_custom_data", "delay")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                delay: Delay | None = None

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, delay: Delay | None = None) -> None:
                    """
                    Timers.

                    Args:
                    -----
                        _custom_data: _custom_data
                        delay: delay

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class TrackedObjectItem(AvdBase):
                _fields = ("_custom_data", "name", "decrement", "shutdown")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                name: str = None
                """Tracked object name."""
                decrement: Annotated[int, Min[1], Max[254]] | None = None
                """Decrement VRRP priority by 1-254."""
                shutdown: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    name: str = None,
                    decrement: Annotated[int, Min[1], Max[254]] | None = None,
                    shutdown: bool | None = None,
                ) -> None:
                    """
                    TrackedObjectItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Tracked object name.
                        decrement: Decrement VRRP priority by 1-254.
                        shutdown: shutdown

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv4(AvdBase):
                _fields = ("_custom_data", "address", "version")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                address: str = None
                """Virtual IPv4 address."""
                version: Annotated[int, ValidValues[2, 3]] | None = None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | None = None, address: str = None, version: Annotated[int, ValidValues[2, 3]] | None = None
                ) -> None:
                    """
                    Ipv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        address: Virtual IPv4 address.
                        version: version

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv6(AvdBase):
                _fields = ("_custom_data", "address")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                address: str = None
                """Virtual IPv6 address."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, address: str = None) -> None:
                    """
                    Ipv6.

                    Args:
                    -----
                        _custom_data: _custom_data
                        address: Virtual IPv6 address.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "id", "priority_level", "advertisement", "preempt", "timers", "tracked_object", "ipv4", "ipv6")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            id: int = None
            """VRID."""
            priority_level: Annotated[int, Min[1], Max[254]] | None = None
            """Instance priority."""
            advertisement: Advertisement | None = None
            preempt: Preempt | None = None
            timers: Timers | None = None
            tracked_object: list[TrackedObjectItem] | None = None
            ipv4: Ipv4 | None = None
            ipv6: Ipv6 | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                id: int = None,
                priority_level: Annotated[int, Min[1], Max[254]] | None = None,
                advertisement: Advertisement | None = None,
                preempt: Preempt | None = None,
                timers: Timers | None = None,
                tracked_object: list[TrackedObjectItem] | None = None,
                ipv4: Ipv4 | None = None,
                ipv6: Ipv6 | None = None,
            ) -> None:
                """
                VrrpIdsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: VRID.
                    priority_level: Instance priority.
                    advertisement: advertisement
                    preempt: preempt
                    timers: timers
                    tracked_object: tracked_object
                    ipv4: ipv4
                    ipv6: ipv6

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IpAttachedHostRouteExport(AvdBase):
            _fields = ("_custom_data", "enabled", "distance")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool = None
            distance: Annotated[int, Min[1], Max[255]] | None = None

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, enabled: bool = None, distance: Annotated[int, Min[1], Max[255]] | None = None
            ) -> None:
                """
                IpAttachedHostRouteExport.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    distance: distance

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6AttachedHostRouteExport(AvdBase):
            _fields = ("_custom_data", "enabled", "distance", "prefix_length")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            enabled: bool = None
            distance: Annotated[int, Min[1], Max[255]] | None = None
            """Administrative distance for generated routes."""
            prefix_length: Annotated[int, Max[128]] | None = None
            """Prefix length for generated routes."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                enabled: bool = None,
                distance: Annotated[int, Min[1], Max[255]] | None = None,
                prefix_length: Annotated[int, Max[128]] | None = None,
            ) -> None:
                """
                Ipv6AttachedHostRouteExport.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    distance: Administrative distance for generated routes.
                    prefix_length: Prefix length for generated routes.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Bfd(AvdBase):
            _fields = ("_custom_data", "echo", "interval", "min_rx", "multiplier")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            echo: bool | None = None
            interval: int | None = None
            """Rate in milliseconds."""
            min_rx: int | None = None
            """Minimum RX hold time in milliseconds."""
            multiplier: Annotated[int, Min[3], Max[50]] | None = None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                echo: bool | None = None,
                interval: int | None = None,
                min_rx: int | None = None,
                multiplier: Annotated[int, Min[3], Max[50]] | None = None,
            ) -> None:
                """
                Bfd.

                Args:
                -----
                    _custom_data: _custom_data
                    echo: echo
                    interval: Rate in milliseconds.
                    min_rx: Minimum RX hold time in milliseconds.
                    multiplier: multiplier

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ServicePolicy(AvdBase):
            class Pbr(AvdBase):
                _fields = ("_custom_data", "input")
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                input: str | None = None
                """Name of policy-map used for policy based routing."""

                def __init__(self, *, _custom_data: dict[str, Any] | None = None, input: str | None = None) -> None:
                    """
                    Pbr.

                    Args:
                    -----
                        _custom_data: _custom_data
                        input: Name of policy-map used for policy based routing.

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "pbr")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            pbr: Pbr | None = None

            def __init__(self, *, _custom_data: dict[str, Any] | None = None, pbr: Pbr | None = None) -> None:
                """
                ServicePolicy.

                Args:
                -----
                    _custom_data: _custom_data
                    pbr: pbr

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = (
            "_custom_data",
            "name",
            "description",
            "logging",
            "shutdown",
            "vrf",
            "arp_aging_timeout",
            "arp_cache_dynamic_capacity",
            "arp_gratuitous_accept",
            "arp_monitor_mac_address",
            "ip_proxy_arp",
            "ip_directed_broadcast",
            "ip_address",
            "ip_address_secondaries",
            "ip_virtual_router_addresses",
            "ip_address_virtual",
            "ip_address_virtual_secondaries",
            "ip_verify_unicast_source_reachable_via",
            "ip_igmp",
            "ip_igmp_version",
            "ip_igmp_host_proxy",
            "ip_helpers",
            "ip_dhcp_relay_all_subnets",
            "ip_nat",
            "ipv6_enable",
            "ipv6_address",
            "ipv6_address_virtuals",
            "ipv6_address_link_local",
            "ipv6_virtual_router_addresses",
            "ipv6_nd_ra_disabled",
            "ipv6_nd_managed_config_flag",
            "ipv6_nd_other_config_flag",
            "ipv6_nd_cache",
            "ipv6_nd_prefixes",
            "ipv6_dhcp_relay_destinations",
            "ipv6_dhcp_relay_all_subnets",
            "access_group_in",
            "access_group_out",
            "ipv6_access_group_in",
            "ipv6_access_group_out",
            "multicast",
            "ospf_network_point_to_point",
            "ospf_area",
            "ospf_cost",
            "ospf_authentication",
            "ospf_authentication_key",
            "ospf_message_digest_keys",
            "pim",
            "isis_enable",
            "isis_bfd",
            "isis_passive",
            "isis_metric",
            "isis_network_point_to_point",
            "isis_authentication",
            "mtu",
            "no_autostate",
            "vrrp_ids",
            "ip_attached_host_route_export",
            "ipv6_attached_host_route_export",
            "bfd",
            "service_policy",
            "pvlan_mapping",
            "tenant",
            "tags",
            "type",
            "eos_cli",
        )
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """VLAN interface name like "Vlan123"."""
        description: str | None = None
        logging: Logging | None = None
        shutdown: bool | None = None
        vrf: str | None = None
        """VRF name."""
        arp_aging_timeout: Annotated[int, Min[1], Max[65535]] | None = None
        """In seconds."""
        arp_cache_dynamic_capacity: Annotated[int, Max[4294967295]] | None = None
        arp_gratuitous_accept: bool | None = None
        arp_monitor_mac_address: bool | None = None
        ip_proxy_arp: bool | None = None
        ip_directed_broadcast: bool | None = None
        ip_address: str | None = None
        """IPv4_address/Mask."""
        ip_address_secondaries: list[str] | None = None
        ip_virtual_router_addresses: list[str] | None = None
        ip_address_virtual: str | None = None
        """IPv4_address/Mask."""
        ip_address_virtual_secondaries: list[str] | None = None
        ip_verify_unicast_source_reachable_via: Annotated[str, ValidValues["any", "rx"]] | None = None
        ip_igmp: bool | None = None
        ip_igmp_version: Annotated[int, Min[1], Max[3]] | None = None
        ip_igmp_host_proxy: IpIgmpHostProxy | None = None
        ip_helpers: list[IpHelpersItem] | None = None
        """List of DHCP servers."""
        ip_dhcp_relay_all_subnets: bool | None = None
        """Allow forwarding requests with secondary IP addresses in the gateway address "giaddr" field."""
        ip_nat: IpNat | None = None
        ipv6_enable: bool | None = None
        ipv6_address: str | None = None
        """IPv6_address/Mask."""
        ipv6_address_virtuals: list[str] | None = None
        """The new "ipv6_address_virtuals" key support multiple virtual ipv6 addresses."""
        ipv6_address_link_local: str | None = None
        """IPv6_address/Mask."""
        ipv6_virtual_router_addresses: list[str] | None = None
        """Improved "VARPv6" data model to support multiple VARPv6 addresses."""
        ipv6_nd_ra_disabled: bool | None = None
        ipv6_nd_managed_config_flag: bool | None = None
        ipv6_nd_other_config_flag: bool | None = None
        """Set the "other stateful configuration" flag in IPv6 router advertisements."""
        ipv6_nd_cache: Ipv6NdCache | None = None
        """IPv6 neighbor cache options."""
        ipv6_nd_prefixes: list[Ipv6NdPrefixesItem] | None = None
        ipv6_dhcp_relay_destinations: list[Ipv6DhcpRelayDestinationsItem] | None = None
        ipv6_dhcp_relay_all_subnets: bool | None = None
        """Allow forwarding requests with additional IPv6 addresses in the gateway address "giaddr" field."""
        access_group_in: str | None = None
        """IPv4 access-list name."""
        access_group_out: str | None = None
        """IPv4 access-list name."""
        ipv6_access_group_in: str | None = None
        """IPv6 access-list name."""
        ipv6_access_group_out: str | None = None
        """IPv6 access-list name."""
        multicast: Multicast | None = None
        ospf_network_point_to_point: bool | None = None
        ospf_area: str | None = None
        ospf_cost: int | None = None
        ospf_authentication: Annotated[str, ValidValues["none", "simple", "message-digest"]] | None = None
        ospf_authentication_key: str | None = None
        """Encrypted password used for simple authentication."""
        ospf_message_digest_keys: list[OspfMessageDigestKeysItem] | None = None
        """Keys used for message-digest authentication."""
        pim: Pim | None = None
        isis_enable: str | None = None
        """ISIS instance name."""
        isis_bfd: bool | None = None
        """Enable BFD for ISIS."""
        isis_passive: bool | None = None
        isis_metric: int | None = None
        isis_network_point_to_point: bool | None = None
        isis_authentication: IsisAuthentication | None = None
        mtu: int | None = None
        no_autostate: bool | None = None
        vrrp_ids: list[VrrpIdsItem] | None = None
        """Improved "vrrp" data model to support multiple VRRP IDs."""
        ip_attached_host_route_export: IpAttachedHostRouteExport | None = None
        ipv6_attached_host_route_export: Ipv6AttachedHostRouteExport | None = None
        bfd: Bfd | None = None
        service_policy: ServicePolicy | None = None
        pvlan_mapping: str | None = None
        """List of VLANs as string."""
        tenant: str | None = None
        """Key only used for documentation or validation purposes."""
        tags: list[str] | None = None
        """Key only used for documentation or validation purposes."""
        type: str | None = None
        """Key only used for documentation or validation purposes."""
        eos_cli: str | None = None
        """Multiline EOS CLI rendered directly on the VLAN interface in the final EOS configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str = None,
            description: str | None = None,
            logging: Logging | None = None,
            shutdown: bool | None = None,
            vrf: str | None = None,
            arp_aging_timeout: Annotated[int, Min[1], Max[65535]] | None = None,
            arp_cache_dynamic_capacity: Annotated[int, Max[4294967295]] | None = None,
            arp_gratuitous_accept: bool | None = None,
            arp_monitor_mac_address: bool | None = None,
            ip_proxy_arp: bool | None = None,
            ip_directed_broadcast: bool | None = None,
            ip_address: str | None = None,
            ip_address_secondaries: list[str] | None = None,
            ip_virtual_router_addresses: list[str] | None = None,
            ip_address_virtual: str | None = None,
            ip_address_virtual_secondaries: list[str] | None = None,
            ip_verify_unicast_source_reachable_via: Annotated[str, ValidValues["any", "rx"]] | None = None,
            ip_igmp: bool | None = None,
            ip_igmp_version: Annotated[int, Min[1], Max[3]] | None = None,
            ip_igmp_host_proxy: IpIgmpHostProxy | None = None,
            ip_helpers: list[IpHelpersItem] | None = None,
            ip_dhcp_relay_all_subnets: bool | None = None,
            ip_nat: IpNat | None = None,
            ipv6_enable: bool | None = None,
            ipv6_address: str | None = None,
            ipv6_address_virtuals: list[str] | None = None,
            ipv6_address_link_local: str | None = None,
            ipv6_virtual_router_addresses: list[str] | None = None,
            ipv6_nd_ra_disabled: bool | None = None,
            ipv6_nd_managed_config_flag: bool | None = None,
            ipv6_nd_other_config_flag: bool | None = None,
            ipv6_nd_cache: Ipv6NdCache | None = None,
            ipv6_nd_prefixes: list[Ipv6NdPrefixesItem] | None = None,
            ipv6_dhcp_relay_destinations: list[Ipv6DhcpRelayDestinationsItem] | None = None,
            ipv6_dhcp_relay_all_subnets: bool | None = None,
            access_group_in: str | None = None,
            access_group_out: str | None = None,
            ipv6_access_group_in: str | None = None,
            ipv6_access_group_out: str | None = None,
            multicast: Multicast | None = None,
            ospf_network_point_to_point: bool | None = None,
            ospf_area: str | None = None,
            ospf_cost: int | None = None,
            ospf_authentication: Annotated[str, ValidValues["none", "simple", "message-digest"]] | None = None,
            ospf_authentication_key: str | None = None,
            ospf_message_digest_keys: list[OspfMessageDigestKeysItem] | None = None,
            pim: Pim | None = None,
            isis_enable: str | None = None,
            isis_bfd: bool | None = None,
            isis_passive: bool | None = None,
            isis_metric: int | None = None,
            isis_network_point_to_point: bool | None = None,
            isis_authentication: IsisAuthentication | None = None,
            mtu: int | None = None,
            no_autostate: bool | None = None,
            vrrp_ids: list[VrrpIdsItem] | None = None,
            ip_attached_host_route_export: IpAttachedHostRouteExport | None = None,
            ipv6_attached_host_route_export: Ipv6AttachedHostRouteExport | None = None,
            bfd: Bfd | None = None,
            service_policy: ServicePolicy | None = None,
            pvlan_mapping: str | None = None,
            tenant: str | None = None,
            tags: list[str] | None = None,
            type: str | None = None,
            eos_cli: str | None = None,
        ) -> None:
            """
            VlanInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: VLAN interface name like "Vlan123".
                description: description
                logging: logging
                shutdown: shutdown
                vrf: VRF name.
                arp_aging_timeout: In seconds.
                arp_cache_dynamic_capacity: arp_cache_dynamic_capacity
                arp_gratuitous_accept: arp_gratuitous_accept
                arp_monitor_mac_address: arp_monitor_mac_address
                ip_proxy_arp: ip_proxy_arp
                ip_directed_broadcast: ip_directed_broadcast
                ip_address: IPv4_address/Mask.
                ip_address_secondaries: ip_address_secondaries
                ip_virtual_router_addresses: ip_virtual_router_addresses
                ip_address_virtual: IPv4_address/Mask.
                ip_address_virtual_secondaries: ip_address_virtual_secondaries
                ip_verify_unicast_source_reachable_via: ip_verify_unicast_source_reachable_via
                ip_igmp: ip_igmp
                ip_igmp_version: ip_igmp_version
                ip_igmp_host_proxy: ip_igmp_host_proxy
                ip_helpers: List of DHCP servers.
                ip_dhcp_relay_all_subnets: Allow forwarding requests with secondary IP addresses in the gateway address "giaddr" field.
                ip_nat: ip_nat
                ipv6_enable: ipv6_enable
                ipv6_address: IPv6_address/Mask.
                ipv6_address_virtuals: The new "ipv6_address_virtuals" key support multiple virtual ipv6 addresses.
                ipv6_address_link_local: IPv6_address/Mask.
                ipv6_virtual_router_addresses: Improved "VARPv6" data model to support multiple VARPv6 addresses.
                ipv6_nd_ra_disabled: ipv6_nd_ra_disabled
                ipv6_nd_managed_config_flag: ipv6_nd_managed_config_flag
                ipv6_nd_other_config_flag: Set the "other stateful configuration" flag in IPv6 router advertisements.
                ipv6_nd_cache: IPv6 neighbor cache options.
                ipv6_nd_prefixes: ipv6_nd_prefixes
                ipv6_dhcp_relay_destinations: ipv6_dhcp_relay_destinations
                ipv6_dhcp_relay_all_subnets: Allow forwarding requests with additional IPv6 addresses in the gateway address "giaddr" field.
                access_group_in: IPv4 access-list name.
                access_group_out: IPv4 access-list name.
                ipv6_access_group_in: IPv6 access-list name.
                ipv6_access_group_out: IPv6 access-list name.
                multicast: multicast
                ospf_network_point_to_point: ospf_network_point_to_point
                ospf_area: ospf_area
                ospf_cost: ospf_cost
                ospf_authentication: ospf_authentication
                ospf_authentication_key: Encrypted password used for simple authentication.
                ospf_message_digest_keys: Keys used for message-digest authentication.
                pim: pim
                isis_enable: ISIS instance name.
                isis_bfd: Enable BFD for ISIS.
                isis_passive: isis_passive
                isis_metric: isis_metric
                isis_network_point_to_point: isis_network_point_to_point
                isis_authentication: isis_authentication
                mtu: mtu
                no_autostate: no_autostate
                vrrp_ids: Improved "vrrp" data model to support multiple VRRP IDs.
                ip_attached_host_route_export: ip_attached_host_route_export
                ipv6_attached_host_route_export: ipv6_attached_host_route_export
                bfd: bfd
                service_policy: service_policy
                pvlan_mapping: List of VLANs as string.
                tenant: Key only used for documentation or validation purposes.
                tags: Key only used for documentation or validation purposes.
                type: Key only used for documentation or validation purposes.
                eos_cli: Multiline EOS CLI rendered directly on the VLAN interface in the final EOS configuration.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class VlanInternalOrder(AvdBase):
        class Range(AvdBase):
            _fields = ("_custom_data", "beginning", "ending")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            beginning: Annotated[int, Min[2], Max[4094]] = None
            """First VLAN ID."""
            ending: Annotated[int, Min[2], Max[4094]] = None
            """Last VLAN ID."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                beginning: Annotated[int, Min[2], Max[4094]] = None,
                ending: Annotated[int, Min[2], Max[4094]] = None,
            ) -> None:
                """
                Range.

                Args:
                -----
                    _custom_data: _custom_data
                    beginning: First VLAN ID.
                    ending: Last VLAN ID.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "allocation", "range")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        allocation: Annotated[str, ValidValues["ascending", "descending"]] = None
        range: Range = None

        def __init__(
            self, *, _custom_data: dict[str, Any] | None = None, allocation: Annotated[str, ValidValues["ascending", "descending"]] = None, range: Range = None
        ) -> None:
            """
            VlanInternalOrder.

            Args:
            -----
                _custom_data: _custom_data
                allocation: allocation
                range: range

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class VlansItem(AvdBase):
        class PrivateVlan(AvdBase):
            _fields = ("_custom_data", "type", "primary_vlan")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            type: Annotated[str, ValidValues["community", "isolated"]] | None = None
            primary_vlan: int | None = None
            """Primary VLAN ID."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | None = None,
                type: Annotated[str, ValidValues["community", "isolated"]] | None = None,
                primary_vlan: int | None = None,
            ) -> None:
                """
                PrivateVlan.

                Args:
                -----
                    _custom_data: _custom_data
                    type: type
                    primary_vlan: Primary VLAN ID.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "id", "name", "state", "trunk_groups", "private_vlan", "tenant")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        id: int = None
        """VLAN ID."""
        name: str | None = None
        """VLAN Name."""
        state: Annotated[str, ValidValues["active", "suspend"]] | None = None
        trunk_groups: list[str] | None = None
        private_vlan: PrivateVlan | None = None
        tenant: str | None = None
        """Key only used for documentation or validation purposes."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            id: int = None,
            name: str | None = None,
            state: Annotated[str, ValidValues["active", "suspend"]] | None = None,
            trunk_groups: list[str] | None = None,
            private_vlan: PrivateVlan | None = None,
            tenant: str | None = None,
        ) -> None:
            """
            VlansItem.

            Args:
            -----
                _custom_data: _custom_data
                id: VLAN ID.
                name: VLAN Name.
                state: state
                trunk_groups: trunk_groups
                private_vlan: private_vlan
                tenant: Key only used for documentation or validation purposes.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class VmtracerSessionsItem(AvdBase):
        _fields = ("_custom_data", "name", "url", "username", "password", "autovlan_disable", "source_interface")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """Vmtracer Session Name."""
        url: str | None = None
        username: str | None = None
        password: str | None = None
        """Type 7 Password Hash."""
        autovlan_disable: bool | None = None
        source_interface: str | None = None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str = None,
            url: str | None = None,
            username: str | None = None,
            password: str | None = None,
            autovlan_disable: bool | None = None,
            source_interface: str | None = None,
        ) -> None:
            """
            VmtracerSessionsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Vmtracer Session Name.
                url: url
                username: username
                password: Type 7 Password Hash.
                autovlan_disable: autovlan_disable
                source_interface: source_interface

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class VrfsItem(AvdBase):
        _fields = ("_custom_data", "name", "description", "ip_routing", "ipv6_routing", "ip_routing_ipv6_interfaces", "tenant")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        name: str = None
        """VRF Name."""
        description: str | None = None
        ip_routing: bool | None = None
        ipv6_routing: bool | None = None
        ip_routing_ipv6_interfaces: bool | None = None
        tenant: str | None = None
        """Key only used for documentation or validation purposes."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | None = None,
            name: str = None,
            description: str | None = None,
            ip_routing: bool | None = None,
            ipv6_routing: bool | None = None,
            ip_routing_ipv6_interfaces: bool | None = None,
            tenant: str | None = None,
        ) -> None:
            """
            VrfsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: VRF Name.
                description: description
                ip_routing: ip_routing
                ipv6_routing: ipv6_routing
                ip_routing_ipv6_interfaces: ip_routing_ipv6_interfaces
                tenant: Key only used for documentation or validation purposes.

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class VxlanInterface(AvdBase):
        class Vxlan1(AvdBase):
            class Vxlan(AvdBase):
                class Multicast(AvdBase):
                    _fields = ("_custom_data", "headend_replication")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    headend_replication: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, headend_replication: bool | None = None) -> None:
                        """
                        Multicast.

                        Args:
                        -----
                            _custom_data: _custom_data
                            headend_replication: headend_replication

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class ControllerClient(AvdBase):
                    _fields = ("_custom_data", "enabled")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None) -> None:
                        """
                        ControllerClient.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class BfdVtepEvpn(AvdBase):
                    _fields = ("_custom_data", "interval", "min_rx", "multiplier", "prefix_list")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    interval: int | None = None
                    min_rx: int | None = None
                    multiplier: Annotated[int, Min[3], Max[50]] | None = None
                    prefix_list: str | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        interval: int | None = None,
                        min_rx: int | None = None,
                        multiplier: Annotated[int, Min[3], Max[50]] | None = None,
                        prefix_list: str | None = None,
                    ) -> None:
                        """
                        BfdVtepEvpn.

                        Args:
                        -----
                            _custom_data: _custom_data
                            interval: interval
                            min_rx: min_rx
                            multiplier: multiplier
                            prefix_list: prefix_list

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Qos(AvdBase):
                    _fields = ("_custom_data", "dscp_propagation_encapsulation", "ecn_propagation", "map_dscp_to_traffic_class_decapsulation")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    dscp_propagation_encapsulation: bool | None = None
                    ecn_propagation: bool | None = None
                    """Enable copying the ECN marking to/from encapsulated packets."""
                    map_dscp_to_traffic_class_decapsulation: bool | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        dscp_propagation_encapsulation: bool | None = None,
                        ecn_propagation: bool | None = None,
                        map_dscp_to_traffic_class_decapsulation: bool | None = None,
                    ) -> None:
                        """
                        Qos.

                        Args:
                        -----
                            _custom_data: _custom_data
                            dscp_propagation_encapsulation: dscp_propagation_encapsulation
                            ecn_propagation: Enable copying the ECN marking to/from encapsulated packets.
                            map_dscp_to_traffic_class_decapsulation: map_dscp_to_traffic_class_decapsulation

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class VlansItem(AvdBase):
                    _fields = ("_custom_data", "id", "vni", "multicast_group", "flood_vteps")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    id: int = None
                    """VLAN ID."""
                    vni: int | None = None
                    multicast_group: str | None = None
                    """IP Multicast Group Address."""
                    flood_vteps: list[str] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        id: int = None,
                        vni: int | None = None,
                        multicast_group: str | None = None,
                        flood_vteps: list[str] | None = None,
                    ) -> None:
                        """
                        VlansItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: VLAN ID.
                            vni: vni
                            multicast_group: IP Multicast Group Address.
                            flood_vteps: flood_vteps

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class VrfsItem(AvdBase):
                    _fields = ("_custom_data", "name", "vni", "multicast_group")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    name: str = None
                    """VRF Name."""
                    vni: int | None = None
                    multicast_group: str | None = None
                    """IP Multicast Group Address."""

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, name: str = None, vni: int | None = None, multicast_group: str | None = None
                    ) -> None:
                        """
                        VrfsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: VRF Name.
                            vni: vni
                            multicast_group: IP Multicast Group Address.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = (
                    "_custom_data",
                    "source_interface",
                    "multicast",
                    "controller_client",
                    "mlag_source_interface",
                    "udp_port",
                    "vtep_to_vtep_bridging",
                    "virtual_router_encapsulation_mac_address",
                    "bfd_vtep_evpn",
                    "qos",
                    "vlans",
                    "vrfs",
                    "flood_vteps",
                    "flood_vtep_learned_data_plane",
                )
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                source_interface: str | None = None
                """Source Interface Name."""
                multicast: Multicast | None = None
                controller_client: ControllerClient | None = None
                """Client to CVX Controllers."""
                mlag_source_interface: str | None = None
                udp_port: int | None = None
                vtep_to_vtep_bridging: bool | None = None
                """Enable bridging between different VTEPs in vxlan overlay."""
                virtual_router_encapsulation_mac_address: str | None = None
                """"mlag-system-id" or ethernet_address (H.H.H)."""
                bfd_vtep_evpn: BfdVtepEvpn | None = None
                qos: Qos | None = None
                """
                For the Traffic Class to be derived based on the outer DSCP field of the incoming VxLan packet, the
                core ports must be in "DSCP Trust" mode.
                !!!Warning, only few hardware types with software version
                >= 4.26.0 support the below knobs to configure Vxlan DSCP mapping.
                """
                vlans: list[VlansItem] | None = None
                vrfs: list[VrfsItem] | None = None
                flood_vteps: list[str] | None = None
                flood_vtep_learned_data_plane: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    source_interface: str | None = None,
                    multicast: Multicast | None = None,
                    controller_client: ControllerClient | None = None,
                    mlag_source_interface: str | None = None,
                    udp_port: int | None = None,
                    vtep_to_vtep_bridging: bool | None = None,
                    virtual_router_encapsulation_mac_address: str | None = None,
                    bfd_vtep_evpn: BfdVtepEvpn | None = None,
                    qos: Qos | None = None,
                    vlans: list[VlansItem] | None = None,
                    vrfs: list[VrfsItem] | None = None,
                    flood_vteps: list[str] | None = None,
                    flood_vtep_learned_data_plane: bool | None = None,
                ) -> None:
                    """
                    Vxlan.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_interface: Source Interface Name.
                        multicast: multicast
                        controller_client: Client to CVX Controllers.
                        mlag_source_interface: mlag_source_interface
                        udp_port: udp_port
                        vtep_to_vtep_bridging: Enable bridging between different VTEPs in vxlan overlay.
                        virtual_router_encapsulation_mac_address: "mlag-system-id" or ethernet_address (H.H.H).
                        bfd_vtep_evpn: bfd_vtep_evpn
                        qos:
                           For the Traffic Class to be derived based on the outer DSCP field of the incoming VxLan packet, the
                           core ports must be in "DSCP Trust" mode.
                           !!!Warning, only few hardware types with software version
                           >= 4.26.0 support the below knobs to configure Vxlan DSCP mapping.
                        vlans: vlans
                        vrfs: vrfs
                        flood_vteps: flood_vteps
                        flood_vtep_learned_data_plane: flood_vtep_learned_data_plane

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "description", "vxlan", "eos_cli")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            description: str | None = None
            vxlan: Vxlan | None = None
            eos_cli: str | None = None
            """
            Multiline String with EOS CLI rendered directly on the Vxlan interface in the final EOS
            configuration.
            """

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, description: str | None = None, vxlan: Vxlan | None = None, eos_cli: str | None = None
            ) -> None:
                """
                Vxlan1.

                Args:
                -----
                    _custom_data: _custom_data
                    description: description
                    vxlan: vxlan
                    eos_cli:
                       Multiline String with EOS CLI rendered directly on the Vxlan interface in the final EOS
                       configuration.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vxlan1(AvdBase):
            class Vxlan(AvdBase):
                class Multicast(AvdBase):
                    _fields = ("_custom_data", "headend_replication")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    headend_replication: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, headend_replication: bool | None = None) -> None:
                        """
                        Multicast.

                        Args:
                        -----
                            _custom_data: _custom_data
                            headend_replication: headend_replication

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class ControllerClient(AvdBase):
                    _fields = ("_custom_data", "enabled")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    enabled: bool | None = None

                    def __init__(self, *, _custom_data: dict[str, Any] | None = None, enabled: bool | None = None) -> None:
                        """
                        ControllerClient.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class BfdVtepEvpn(AvdBase):
                    _fields = ("_custom_data", "interval", "min_rx", "multiplier", "prefix_list")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    interval: int | None = None
                    min_rx: int | None = None
                    multiplier: Annotated[int, Min[3], Max[50]] | None = None
                    prefix_list: str | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        interval: int | None = None,
                        min_rx: int | None = None,
                        multiplier: Annotated[int, Min[3], Max[50]] | None = None,
                        prefix_list: str | None = None,
                    ) -> None:
                        """
                        BfdVtepEvpn.

                        Args:
                        -----
                            _custom_data: _custom_data
                            interval: interval
                            min_rx: min_rx
                            multiplier: multiplier
                            prefix_list: prefix_list

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Qos(AvdBase):
                    _fields = ("_custom_data", "dscp_propagation_encapsulation", "ecn_propagation", "map_dscp_to_traffic_class_decapsulation")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    dscp_propagation_encapsulation: bool | None = None
                    ecn_propagation: bool | None = None
                    """Enable copying the ECN marking to/from encapsulated packets."""
                    map_dscp_to_traffic_class_decapsulation: bool | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        dscp_propagation_encapsulation: bool | None = None,
                        ecn_propagation: bool | None = None,
                        map_dscp_to_traffic_class_decapsulation: bool | None = None,
                    ) -> None:
                        """
                        Qos.

                        Args:
                        -----
                            _custom_data: _custom_data
                            dscp_propagation_encapsulation: dscp_propagation_encapsulation
                            ecn_propagation: Enable copying the ECN marking to/from encapsulated packets.
                            map_dscp_to_traffic_class_decapsulation: map_dscp_to_traffic_class_decapsulation

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class VlansItem(AvdBase):
                    _fields = ("_custom_data", "id", "vni", "multicast_group", "flood_vteps")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    id: int = None
                    """VLAN ID."""
                    vni: int | None = None
                    multicast_group: str | None = None
                    """IP Multicast Group Address."""
                    flood_vteps: list[str] | None = None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | None = None,
                        id: int = None,
                        vni: int | None = None,
                        multicast_group: str | None = None,
                        flood_vteps: list[str] | None = None,
                    ) -> None:
                        """
                        VlansItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: VLAN ID.
                            vni: vni
                            multicast_group: IP Multicast Group Address.
                            flood_vteps: flood_vteps

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class VrfsItem(AvdBase):
                    _fields = ("_custom_data", "name", "vni", "multicast_group")
                    _required_fields = ()
                    _custom_data: dict[str, Any] | None = None
                    name: str = None
                    """VRF Name."""
                    vni: int | None = None
                    multicast_group: str | None = None
                    """IP Multicast Group Address."""

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | None = None, name: str = None, vni: int | None = None, multicast_group: str | None = None
                    ) -> None:
                        """
                        VrfsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: VRF Name.
                            vni: vni
                            multicast_group: IP Multicast Group Address.

                        """
                        for arg, arg_value in locals().items():
                            if arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields = (
                    "_custom_data",
                    "source_interface",
                    "multicast",
                    "controller_client",
                    "mlag_source_interface",
                    "udp_port",
                    "vtep_to_vtep_bridging",
                    "virtual_router_encapsulation_mac_address",
                    "bfd_vtep_evpn",
                    "qos",
                    "vlans",
                    "vrfs",
                    "flood_vteps",
                    "flood_vtep_learned_data_plane",
                )
                _required_fields = ()
                _custom_data: dict[str, Any] | None = None
                source_interface: str | None = None
                """Source Interface Name."""
                multicast: Multicast | None = None
                controller_client: ControllerClient | None = None
                """Client to CVX Controllers."""
                mlag_source_interface: str | None = None
                udp_port: int | None = None
                vtep_to_vtep_bridging: bool | None = None
                """Enable bridging between different VTEPs in vxlan overlay."""
                virtual_router_encapsulation_mac_address: str | None = None
                """"mlag-system-id" or ethernet_address (H.H.H)."""
                bfd_vtep_evpn: BfdVtepEvpn | None = None
                qos: Qos | None = None
                """
                For the Traffic Class to be derived based on the outer DSCP field of the incoming VxLan packet, the
                core ports must be in "DSCP Trust" mode.
                !!!Warning, only few hardware types with software version
                >= 4.26.0 support the below knobs to configure Vxlan DSCP mapping.
                """
                vlans: list[VlansItem] | None = None
                vrfs: list[VrfsItem] | None = None
                flood_vteps: list[str] | None = None
                flood_vtep_learned_data_plane: bool | None = None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | None = None,
                    source_interface: str | None = None,
                    multicast: Multicast | None = None,
                    controller_client: ControllerClient | None = None,
                    mlag_source_interface: str | None = None,
                    udp_port: int | None = None,
                    vtep_to_vtep_bridging: bool | None = None,
                    virtual_router_encapsulation_mac_address: str | None = None,
                    bfd_vtep_evpn: BfdVtepEvpn | None = None,
                    qos: Qos | None = None,
                    vlans: list[VlansItem] | None = None,
                    vrfs: list[VrfsItem] | None = None,
                    flood_vteps: list[str] | None = None,
                    flood_vtep_learned_data_plane: bool | None = None,
                ) -> None:
                    """
                    Vxlan.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_interface: Source Interface Name.
                        multicast: multicast
                        controller_client: Client to CVX Controllers.
                        mlag_source_interface: mlag_source_interface
                        udp_port: udp_port
                        vtep_to_vtep_bridging: Enable bridging between different VTEPs in vxlan overlay.
                        virtual_router_encapsulation_mac_address: "mlag-system-id" or ethernet_address (H.H.H).
                        bfd_vtep_evpn: bfd_vtep_evpn
                        qos:
                           For the Traffic Class to be derived based on the outer DSCP field of the incoming VxLan packet, the
                           core ports must be in "DSCP Trust" mode.
                           !!!Warning, only few hardware types with software version
                           >= 4.26.0 support the below knobs to configure Vxlan DSCP mapping.
                        vlans: vlans
                        vrfs: vrfs
                        flood_vteps: flood_vteps
                        flood_vtep_learned_data_plane: flood_vtep_learned_data_plane

                    """
                    for arg, arg_value in locals().items():
                        if arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields = ("_custom_data", "description", "vxlan", "eos_cli")
            _required_fields = ()
            _custom_data: dict[str, Any] | None = None
            description: str | None = None
            vxlan: Vxlan | None = None
            eos_cli: str | None = None
            """
            Multiline String with EOS CLI rendered directly on the Vxlan interface in the final EOS
            configuration.
            """

            def __init__(
                self, *, _custom_data: dict[str, Any] | None = None, description: str | None = None, vxlan: Vxlan | None = None, eos_cli: str | None = None
            ) -> None:
                """
                Vxlan1.

                Args:
                -----
                    _custom_data: _custom_data
                    description: description
                    vxlan: vxlan
                    eos_cli:
                       Multiline String with EOS CLI rendered directly on the Vxlan interface in the final EOS
                       configuration.

                """
                for arg, arg_value in locals().items():
                    if arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields = ("_custom_data", "vxlan1", "field_Vxlan1")
        _required_fields = ()
        _custom_data: dict[str, Any] | None = None
        vxlan1: Vxlan1 | None = None
        field_Vxlan1: Vxlan1 | None = None

        def __init__(self, *, _custom_data: dict[str, Any] | None = None, vxlan1: Vxlan1 | None = None, field_Vxlan1: Vxlan1 | None = None) -> None:
            """
            VxlanInterface.

            Args:
            -----
                _custom_data: _custom_data
                vxlan1: vxlan1
                field_Vxlan1: field_Vxlan1

            """
            for arg, arg_value in locals().items():
                if arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    _fields = (
        "aaa_accounting",
        "aaa_authentication",
        "aaa_authorization",
        "aaa_root",
        "aaa_server_groups",
        "access_lists",
        "address_locking",
        "agents",
        "aliases",
        "application_traffic_recognition",
        "arp",
        "as_path",
        "avd_data_validation_mode",
        "banners",
        "bgp_groups",
        "boot",
        "class_maps",
        "clock",
        "community_lists",
        "config_comment",
        "config_end",
        "custom_templates",
        "cvx",
        "daemon_terminattr",
        "daemons",
        "dhcp_relay",
        "dhcp_servers",
        "dns_domain",
        "domain_list",
        "dot1x",
        "dps_interfaces",
        "dynamic_prefix_lists",
        "enable_password",
        "eos_cli",
        "eos_cli_config_gen_configuration",
        "eos_cli_config_gen_documentation",
        "errdisable",
        "ethernet_interfaces",
        "event_handlers",
        "event_monitor",
        "flow_tracking",
        "generate_default_config",
        "generate_device_documentation",
        "hardware",
        "hardware_counters",
        "hostname",
        "interface_defaults",
        "interface_groups",
        "interface_profiles",
        "ip_access_lists",
        "ip_access_lists_max_entries",
        "ip_community_lists",
        "ip_dhcp_relay",
        "ip_dhcp_snooping",
        "ip_domain_lookup",
        "ip_extcommunity_lists",
        "ip_extcommunity_lists_regexp",
        "ip_ftp_client_source_interfaces",
        "ip_hardware",
        "ip_http_client_source_interfaces",
        "ip_icmp_redirect",
        "ip_igmp_snooping",
        "ip_name_servers",
        "ip_nat",
        "ip_radius_source_interfaces",
        "ip_routing",
        "ip_routing_ipv6_interfaces",
        "ip_security",
        "ip_ssh_client_source_interfaces",
        "ip_tacacs_source_interfaces",
        "ip_telnet_client_source_interfaces",
        "ip_tftp_client_source_interfaces",
        "ip_virtual_router_mac_address",
        "ipv6_access_lists",
        "ipv6_dhcp_relay",
        "ipv6_hardware",
        "ipv6_icmp_redirect",
        "ipv6_neighbor",
        "ipv6_prefix_lists",
        "ipv6_standard_access_lists",
        "ipv6_static_routes",
        "ipv6_unicast_routing",
        "is_deployed",
        "l2_protocol",
        "lacp",
        "link_tracking_groups",
        "lldp",
        "load_interval",
        "local_users",
        "logging",
        "loopback_interfaces",
        "mac_access_lists",
        "mac_address_table",
        "mac_security",
        "maintenance",
        "management_accounts",
        "management_api_gnmi",
        "management_api_http",
        "management_api_models",
        "management_console",
        "management_cvx",
        "management_defaults",
        "management_interfaces",
        "management_security",
        "management_ssh",
        "management_tech_support",
        "match_list_input",
        "mcs_client",
        "metadata",
        "mlag_configuration",
        "monitor_connectivity",
        "monitor_layer1",
        "monitor_session_default_encapsulation_gre",
        "monitor_sessions",
        "monitor_telemetry_influx",
        "monitor_telemetry_postcard_policy",
        "mpls",
        "ntp",
        "patch_panel",
        "peer_filters",
        "platform",
        "poe",
        "policy_maps",
        "port_channel_interfaces",
        "prefix_lists",
        "priority_flow_control",
        "prompt",
        "ptp",
        "qos",
        "qos_profiles",
        "queue_monitor_length",
        "queue_monitor_streaming",
        "radius_server",
        "redundancy",
        "roles",
        "route_maps",
        "router_adaptive_virtual_topology",
        "router_bfd",
        "router_bgp",
        "router_general",
        "router_igmp",
        "router_internet_exit",
        "router_isis",
        "router_l2_vpn",
        "router_msdp",
        "router_multicast",
        "router_ospf",
        "router_path_selection",
        "router_pim_sparse_mode",
        "router_segment_security",
        "router_service_insertion",
        "router_traffic_engineering",
        "service_routing_configuration_bgp",
        "service_routing_protocols_model",
        "service_unsupported_transceiver",
        "sflow",
        "snmp_server",
        "spanning_tree",
        "standard_access_lists",
        "static_routes",
        "stun",
        "switchport_default",
        "switchport_port_security",
        "sync_e",
        "system",
        "tacacs_servers",
        "tap_aggregation",
        "tcam_profile",
        "terminal",
        "trackers",
        "traffic_policies",
        "transceiver_qsfp_default_mode_4x10",
        "tunnel_interfaces",
        "virtual_source_nat_vrfs",
        "vlan_interfaces",
        "vlan_internal_order",
        "vlans",
        "vmtracer_sessions",
        "vrfs",
        "vxlan_interface",
    )
    _required_fields = ()
    _allow_other_keys = True
    aaa_accounting: AaaAccounting | None = None
    aaa_authentication: AaaAuthentication | None = None
    aaa_authorization: AaaAuthorization | None = None
    aaa_root: AaaRoot | None = None
    aaa_server_groups: list[AaaServerGroupsItem] | None = None
    access_lists: list[AccessListsItem] | None = None
    address_locking: AddressLocking | None = None
    agents: list[AgentsItem] | None = None
    aliases: str | None = None
    """
    Multi-line string with one or more alias commands.

    Example:

    ```yaml
    aliases: |
      alias wr copy
    running-config startup-config
      alias siib show ip interface brief
    ```
    """
    application_traffic_recognition: ApplicationTrafficRecognition | None = None
    """Application traffic recognition configuration."""
    arp: Arp | None = None
    as_path: AsPath | None = None
    avd_data_validation_mode: Annotated[str, ValidValues["error", "warning"]] | None = "error"
    """
    Validation Mode for AVD input data validation.
    Input data validation will validate the input
    variables according to the schema.
    During validation, messages will generated with information about
    the host(s) and key(s) which failed validation.
    "error" will produce error messages and fail the
    task.
    "warning" will produce warning messages.
    """
    banners: Banners | None = None
    bgp_groups: list[BgpGroupsItem] | None = None
    boot: Boot | None = None
    """Set the Aboot password."""
    class_maps: ClassMaps | None = None
    clock: Clock | None = None
    community_lists: list[CommunityListsItem] | None = None
    config_comment: str | None = None
    """
    Add a comment to provide information about the configuration.
    This comment will be rendered at the
    top of the generated configuration.
    """
    config_end: bool | None = False
    """Render `end` at the end of the configuration."""
    custom_templates: list[str] | None = None
    """
    - Custom templates can be added below the playbook directory.
    - If a location above the directory is
    desired, a symbolic link can be used.
    - Example under the `playbooks` directory create symbolic link
    with the following command:

      ```bash
      ln -s ../../shared_repo/custom_avd_templates/
    ./custom_avd_templates
      ```

    - The output will be rendered at the end of the configuration.
    - The
    order of custom templates in the list can be important if they overlap.
    - It is recommended to use a
    `!` delimiter at the top of each custom template.

    Add `custom_templates` to group/host variables:
    """
    cvx: Cvx | None = None
    """
    CVX server features are not supported on physical switches. See `management_cvx` for client
    configurations.
    """
    daemon_terminattr: DaemonTerminattr | None = None
    """
    You can either provide a list of IPs/FQDNs to target on-premise Cloudvision cluster or use DNS name
    for your Cloudvision as a Service instance.
    Streaming to multiple clusters both on-prem and cloud
    service is supported.

    !!! note
        For TerminAttr version recommendation and EOS compatibility
    matrix, please refer to the latest TerminAttr Release Notes
        which always contain the latest
    recommended versions and minimum required versions per EOS release.
    """
    daemons: list[DaemonsItem] | None = None
    """
    This will add a daemon to the eos configuration that is most useful when trying to run OpenConfig
    clients like ocprometheus.
    """
    dhcp_relay: DhcpRelay | None = None
    dhcp_servers: list[DhcpServersItem] | None = None
    dns_domain: str | None = None
    """Domain Name."""
    domain_list: list[str] | None = None
    """Search list of DNS domains."""
    dot1x: Dot1x | None = None
    dps_interfaces: list[DpsInterfacesItem] | None = None
    dynamic_prefix_lists: list[DynamicPrefixListsItem] | None = None
    enable_password: EnablePassword | None = None
    eos_cli: str | None = None
    """Multiline string with EOS CLI rendered directly on the root level of the final EOS configuration."""
    eos_cli_config_gen_configuration: EosCliConfigGenConfiguration | None = None
    eos_cli_config_gen_documentation: EosCliConfigGenDocumentation | None = None
    errdisable: Errdisable | None = None
    ethernet_interfaces: list[EthernetInterfacesItem] | None = None
    event_handlers: list[EventHandlersItem] | None = None
    """
    Gives the ability to monitor and react to Syslog messages.
    Event Handlers provide a powerful and
    flexible tool that can be used to apply self-healing actions,
    customize the system behavior, and
    implement workarounds to problems discovered in the field.
    """
    event_monitor: EventMonitor | None = None
    flow_tracking: FlowTracking | None = None
    generate_default_config: bool | None = False
    """
    The `generate_default_config` knob allows to omit default EOS configuration.
    This can be useful when
    leveraging `eos_cli_config_gen` to generate configlets with CloudVision.

    The following commands
    will be omitted when `generate_default_config` is set to `false`:

    - RANCID Content Type
    - Hostname
    (even if `hostname` variable is not set. Then the hostname is picked up from `inventory_hostname`)
    -
    Default configuration for `aaa`
    - Default configuration for `enable password`
    - Transceiver qsfp
    default mode
    - End of configuration delimiter
    """
    generate_device_documentation: bool | None = True
    hardware: Hardware | None = None
    hardware_counters: HardwareCounters | None = None
    hostname: str | None = None
    interface_defaults: InterfaceDefaults | None = None
    interface_groups: list[InterfaceGroupsItem] | None = None
    interface_profiles: list[InterfaceProfilesItem] | None = None
    ip_access_lists: list[IpAccessListsItem] | None = None
    ip_access_lists_max_entries: int | None = None
    """Limit ACL entries defined under the `ip_access_lists`."""
    ip_community_lists: list[IpCommunityListsItem] | None = None
    """Communities and regexp entries MUST not be configured in the same community-list."""
    ip_dhcp_relay: IpDhcpRelay | None = None
    ip_dhcp_snooping: IpDhcpSnooping | None = None
    ip_domain_lookup: IpDomainLookup | None = None
    ip_extcommunity_lists: list[IpExtcommunityListsItem] | None = None
    ip_extcommunity_lists_regexp: list[IpExtcommunityListsRegexpItem] | None = None
    ip_ftp_client_source_interfaces: list[IpFtpClientSourceInterfacesItem] | None = None
    ip_hardware: IpHardware | None = None
    ip_http_client_source_interfaces: list[IpHttpClientSourceInterfacesItem] | None = None
    ip_icmp_redirect: bool | None = None
    ip_igmp_snooping: IpIgmpSnooping | None = None
    ip_name_servers: list[IpNameServersItem] | None = None
    ip_nat: IpNat | None = None
    ip_radius_source_interfaces: list[IpRadiusSourceInterfacesItem] | None = None
    ip_routing: bool | None = None
    ip_routing_ipv6_interfaces: bool | None = None
    ip_security: IpSecurity | None = None
    ip_ssh_client_source_interfaces: list[IpSshClientSourceInterfacesItem] | None = None
    ip_tacacs_source_interfaces: list[IpTacacsSourceInterfacesItem] | None = None
    ip_telnet_client_source_interfaces: list[IpTelnetClientSourceInterfacesItem] | None = None
    ip_tftp_client_source_interfaces: list[IpTftpClientSourceInterfacesItem] | None = None
    ip_virtual_router_mac_address: str | None = None
    """MAC address (hh:hh:hh:hh:hh:hh)."""
    ipv6_access_lists: list[Ipv6AccessListsItem] | None = None
    ipv6_dhcp_relay: Ipv6DhcpRelay | None = None
    ipv6_hardware: Ipv6Hardware | None = None
    ipv6_icmp_redirect: bool | None = None
    ipv6_neighbor: Ipv6Neighbor | None = None
    ipv6_prefix_lists: list[Ipv6PrefixListsItem] | None = None
    ipv6_standard_access_lists: list[Ipv6StandardAccessListsItem] | None = None
    ipv6_static_routes: list[Ipv6StaticRoutesItem] | None = None
    ipv6_unicast_routing: bool | None = None
    is_deployed: bool | None = True
    """Key only used for documentation or validation purposes."""
    l2_protocol: L2Protocol | None = None
    lacp: Lacp | None = None
    """Set Link Aggregation Control Protocol (LACP) parameters."""
    link_tracking_groups: list[LinkTrackingGroupsItem] | None = None
    lldp: Lldp | None = None
    load_interval: LoadInterval | None = None
    local_users: list[LocalUsersItem] | None = None
    logging: Logging | None = None
    loopback_interfaces: list[LoopbackInterfacesItem] | None = None
    mac_access_lists: list[MacAccessListsItem] | None = None
    mac_address_table: MacAddressTable | None = None
    mac_security: MacSecurity | None = None
    maintenance: Maintenance | None = None
    management_accounts: ManagementAccounts | None = None
    management_api_gnmi: ManagementApiGnmi | None = None
    management_api_http: ManagementApiHttp | None = None
    management_api_models: ManagementApiModels | None = None
    management_console: ManagementConsole | None = None
    management_cvx: ManagementCvx | None = None
    management_defaults: ManagementDefaults | None = None
    management_interfaces: list[ManagementInterfacesItem] | None = None
    management_security: ManagementSecurity | None = None
    management_ssh: ManagementSsh | None = None
    management_tech_support: ManagementTechSupport | None = None
    match_list_input: MatchListInput | None = None
    mcs_client: McsClient | None = None
    metadata: Metadata | None = None
    """
    The data under `metadata` is used for documentation, validation or integration purposes.
    It will not
    affect the generated EOS configuration.
    """
    mlag_configuration: MlagConfiguration | None = None
    monitor_connectivity: MonitorConnectivity | None = None
    monitor_layer1: MonitorLayer1 | None = None
    """Enable SYSLOG messages on transceiver SMBus communication failures."""
    monitor_session_default_encapsulation_gre: MonitorSessionDefaultEncapsulationGre | None = None
    monitor_sessions: list[MonitorSessionsItem] | None = None
    monitor_telemetry_influx: MonitorTelemetryInflux | None = None
    monitor_telemetry_postcard_policy: MonitorTelemetryPostcardPolicy | None = None
    mpls: Mpls | None = None
    ntp: Ntp | None = None
    patch_panel: PatchPanel | None = None
    peer_filters: list[PeerFiltersItem] | None = None
    platform: Platform | None = None
    """Every key below this point is platform dependent."""
    poe: Poe | None = None
    policy_maps: PolicyMaps | None = None
    port_channel_interfaces: list[PortChannelInterfacesItem] | None = None
    prefix_lists: list[PrefixListsItem] | None = None
    priority_flow_control: PriorityFlowControl | None = None
    """Global Priority Flow Control settings."""
    prompt: str | None = None
    ptp: Ptp | None = None
    qos: Qos | None = None
    qos_profiles: list[QosProfilesItem] | None = None
    queue_monitor_length: QueueMonitorLength | None = None
    queue_monitor_streaming: QueueMonitorStreaming | None = None
    radius_server: RadiusServer | None = None
    redundancy: Redundancy | None = None
    roles: list[RolesItem] | None = None
    route_maps: list[RouteMapsItem] | None = None
    router_adaptive_virtual_topology: RouterAdaptiveVirtualTopology | None = None
    router_bfd: RouterBfd | None = None
    router_bgp: RouterBgp | None = None
    router_general: RouterGeneral | None = None
    router_igmp: RouterIgmp | None = None
    router_internet_exit: RouterInternetExit | None = None
    """Internet-exit feature to configure internet bound service for virtual topologies."""
    router_isis: RouterIsis | None = None
    router_l2_vpn: RouterL2Vpn | None = None
    router_msdp: RouterMsdp | None = None
    router_multicast: RouterMulticast | None = None
    router_ospf: RouterOspf | None = None
    router_path_selection: RouterPathSelection | None = None
    """Dynamic path selection configuration."""
    router_pim_sparse_mode: RouterPimSparseMode | None = None
    router_segment_security: RouterSegmentSecurity | None = None
    router_service_insertion: RouterServiceInsertion | None = None
    """Configure network services inserted to data forwarding."""
    router_traffic_engineering: RouterTrafficEngineering | None = None
    service_routing_configuration_bgp: ServiceRoutingConfigurationBgp | None = None
    service_routing_protocols_model: Annotated[str, ValidValues["multi-agent", "ribd"]] | None = None
    service_unsupported_transceiver: ServiceUnsupportedTransceiver | None = None
    sflow: Sflow | None = None
    snmp_server: SnmpServer | None = None
    """SNMP settings."""
    spanning_tree: SpanningTree | None = None
    standard_access_lists: list[StandardAccessListsItem] | None = None
    static_routes: list[StaticRoutesItem] | None = None
    stun: Stun | None = None
    """STUN configuration."""
    switchport_default: SwitchportDefault | None = None
    switchport_port_security: SwitchportPortSecurity | None = None
    sync_e: SyncE | None = None
    system: System | None = None
    tacacs_servers: TacacsServers | None = None
    tap_aggregation: TapAggregation | None = None
    tcam_profile: TcamProfile | None = None
    terminal: Terminal | None = None
    trackers: list[TrackersItem] | None = None
    traffic_policies: TrafficPolicies | None = None
    transceiver_qsfp_default_mode_4x10: bool | None = True
    """
    On all front panel ports which support this feature, the following global configuration command
    changes the QSFP mode from 40G to 4x10G (default). When set to false the command reverts the default
    QSFP mode back to 40G.
    """
    tunnel_interfaces: list[TunnelInterfacesItem] | None = None
    virtual_source_nat_vrfs: list[VirtualSourceNatVrfsItem] | None = None
    vlan_interfaces: list[VlanInterfacesItem] | None = None
    vlan_internal_order: VlanInternalOrder | None = None
    vlans: list[VlansItem] | None = None
    vmtracer_sessions: list[VmtracerSessionsItem] | None = None
    vrfs: list[VrfsItem] | None = None
    """These keys are ignored if the name of the vrf is 'default'."""
    vxlan_interface: VxlanInterface | None = None

    def __init__(
        self,
        *,
        aaa_accounting: AaaAccounting | None = None,
        aaa_authentication: AaaAuthentication | None = None,
        aaa_authorization: AaaAuthorization | None = None,
        aaa_root: AaaRoot | None = None,
        aaa_server_groups: list[AaaServerGroupsItem] | None = None,
        access_lists: list[AccessListsItem] | None = None,
        address_locking: AddressLocking | None = None,
        agents: list[AgentsItem] | None = None,
        aliases: str | None = None,
        application_traffic_recognition: ApplicationTrafficRecognition | None = None,
        arp: Arp | None = None,
        as_path: AsPath | None = None,
        avd_data_validation_mode: Annotated[str, ValidValues["error", "warning"]] | None = "error",
        banners: Banners | None = None,
        bgp_groups: list[BgpGroupsItem] | None = None,
        boot: Boot | None = None,
        class_maps: ClassMaps | None = None,
        clock: Clock | None = None,
        community_lists: list[CommunityListsItem] | None = None,
        config_comment: str | None = None,
        config_end: bool | None = False,
        custom_templates: list[str] | None = None,
        cvx: Cvx | None = None,
        daemon_terminattr: DaemonTerminattr | None = None,
        daemons: list[DaemonsItem] | None = None,
        dhcp_relay: DhcpRelay | None = None,
        dhcp_servers: list[DhcpServersItem] | None = None,
        dns_domain: str | None = None,
        domain_list: list[str] | None = None,
        dot1x: Dot1x | None = None,
        dps_interfaces: list[DpsInterfacesItem] | None = None,
        dynamic_prefix_lists: list[DynamicPrefixListsItem] | None = None,
        enable_password: EnablePassword | None = None,
        eos_cli: str | None = None,
        eos_cli_config_gen_configuration: EosCliConfigGenConfiguration | None = None,
        eos_cli_config_gen_documentation: EosCliConfigGenDocumentation | None = None,
        errdisable: Errdisable | None = None,
        ethernet_interfaces: list[EthernetInterfacesItem] | None = None,
        event_handlers: list[EventHandlersItem] | None = None,
        event_monitor: EventMonitor | None = None,
        flow_tracking: FlowTracking | None = None,
        generate_default_config: bool | None = False,
        generate_device_documentation: bool | None = True,
        hardware: Hardware | None = None,
        hardware_counters: HardwareCounters | None = None,
        hostname: str | None = None,
        interface_defaults: InterfaceDefaults | None = None,
        interface_groups: list[InterfaceGroupsItem] | None = None,
        interface_profiles: list[InterfaceProfilesItem] | None = None,
        ip_access_lists: list[IpAccessListsItem] | None = None,
        ip_access_lists_max_entries: int | None = None,
        ip_community_lists: list[IpCommunityListsItem] | None = None,
        ip_dhcp_relay: IpDhcpRelay | None = None,
        ip_dhcp_snooping: IpDhcpSnooping | None = None,
        ip_domain_lookup: IpDomainLookup | None = None,
        ip_extcommunity_lists: list[IpExtcommunityListsItem] | None = None,
        ip_extcommunity_lists_regexp: list[IpExtcommunityListsRegexpItem] | None = None,
        ip_ftp_client_source_interfaces: list[IpFtpClientSourceInterfacesItem] | None = None,
        ip_hardware: IpHardware | None = None,
        ip_http_client_source_interfaces: list[IpHttpClientSourceInterfacesItem] | None = None,
        ip_icmp_redirect: bool | None = None,
        ip_igmp_snooping: IpIgmpSnooping | None = None,
        ip_name_servers: list[IpNameServersItem] | None = None,
        ip_nat: IpNat | None = None,
        ip_radius_source_interfaces: list[IpRadiusSourceInterfacesItem] | None = None,
        ip_routing: bool | None = None,
        ip_routing_ipv6_interfaces: bool | None = None,
        ip_security: IpSecurity | None = None,
        ip_ssh_client_source_interfaces: list[IpSshClientSourceInterfacesItem] | None = None,
        ip_tacacs_source_interfaces: list[IpTacacsSourceInterfacesItem] | None = None,
        ip_telnet_client_source_interfaces: list[IpTelnetClientSourceInterfacesItem] | None = None,
        ip_tftp_client_source_interfaces: list[IpTftpClientSourceInterfacesItem] | None = None,
        ip_virtual_router_mac_address: str | None = None,
        ipv6_access_lists: list[Ipv6AccessListsItem] | None = None,
        ipv6_dhcp_relay: Ipv6DhcpRelay | None = None,
        ipv6_hardware: Ipv6Hardware | None = None,
        ipv6_icmp_redirect: bool | None = None,
        ipv6_neighbor: Ipv6Neighbor | None = None,
        ipv6_prefix_lists: list[Ipv6PrefixListsItem] | None = None,
        ipv6_standard_access_lists: list[Ipv6StandardAccessListsItem] | None = None,
        ipv6_static_routes: list[Ipv6StaticRoutesItem] | None = None,
        ipv6_unicast_routing: bool | None = None,
        is_deployed: bool | None = True,
        l2_protocol: L2Protocol | None = None,
        lacp: Lacp | None = None,
        link_tracking_groups: list[LinkTrackingGroupsItem] | None = None,
        lldp: Lldp | None = None,
        load_interval: LoadInterval | None = None,
        local_users: list[LocalUsersItem] | None = None,
        logging: Logging | None = None,
        loopback_interfaces: list[LoopbackInterfacesItem] | None = None,
        mac_access_lists: list[MacAccessListsItem] | None = None,
        mac_address_table: MacAddressTable | None = None,
        mac_security: MacSecurity | None = None,
        maintenance: Maintenance | None = None,
        management_accounts: ManagementAccounts | None = None,
        management_api_gnmi: ManagementApiGnmi | None = None,
        management_api_http: ManagementApiHttp | None = None,
        management_api_models: ManagementApiModels | None = None,
        management_console: ManagementConsole | None = None,
        management_cvx: ManagementCvx | None = None,
        management_defaults: ManagementDefaults | None = None,
        management_interfaces: list[ManagementInterfacesItem] | None = None,
        management_security: ManagementSecurity | None = None,
        management_ssh: ManagementSsh | None = None,
        management_tech_support: ManagementTechSupport | None = None,
        match_list_input: MatchListInput | None = None,
        mcs_client: McsClient | None = None,
        metadata: Metadata | None = None,
        mlag_configuration: MlagConfiguration | None = None,
        monitor_connectivity: MonitorConnectivity | None = None,
        monitor_layer1: MonitorLayer1 | None = None,
        monitor_session_default_encapsulation_gre: MonitorSessionDefaultEncapsulationGre | None = None,
        monitor_sessions: list[MonitorSessionsItem] | None = None,
        monitor_telemetry_influx: MonitorTelemetryInflux | None = None,
        monitor_telemetry_postcard_policy: MonitorTelemetryPostcardPolicy | None = None,
        mpls: Mpls | None = None,
        ntp: Ntp | None = None,
        patch_panel: PatchPanel | None = None,
        peer_filters: list[PeerFiltersItem] | None = None,
        platform: Platform | None = None,
        poe: Poe | None = None,
        policy_maps: PolicyMaps | None = None,
        port_channel_interfaces: list[PortChannelInterfacesItem] | None = None,
        prefix_lists: list[PrefixListsItem] | None = None,
        priority_flow_control: PriorityFlowControl | None = None,
        prompt: str | None = None,
        ptp: Ptp | None = None,
        qos: Qos | None = None,
        qos_profiles: list[QosProfilesItem] | None = None,
        queue_monitor_length: QueueMonitorLength | None = None,
        queue_monitor_streaming: QueueMonitorStreaming | None = None,
        radius_server: RadiusServer | None = None,
        redundancy: Redundancy | None = None,
        roles: list[RolesItem] | None = None,
        route_maps: list[RouteMapsItem] | None = None,
        router_adaptive_virtual_topology: RouterAdaptiveVirtualTopology | None = None,
        router_bfd: RouterBfd | None = None,
        router_bgp: RouterBgp | None = None,
        router_general: RouterGeneral | None = None,
        router_igmp: RouterIgmp | None = None,
        router_internet_exit: RouterInternetExit | None = None,
        router_isis: RouterIsis | None = None,
        router_l2_vpn: RouterL2Vpn | None = None,
        router_msdp: RouterMsdp | None = None,
        router_multicast: RouterMulticast | None = None,
        router_ospf: RouterOspf | None = None,
        router_path_selection: RouterPathSelection | None = None,
        router_pim_sparse_mode: RouterPimSparseMode | None = None,
        router_segment_security: RouterSegmentSecurity | None = None,
        router_service_insertion: RouterServiceInsertion | None = None,
        router_traffic_engineering: RouterTrafficEngineering | None = None,
        service_routing_configuration_bgp: ServiceRoutingConfigurationBgp | None = None,
        service_routing_protocols_model: Annotated[str, ValidValues["multi-agent", "ribd"]] | None = None,
        service_unsupported_transceiver: ServiceUnsupportedTransceiver | None = None,
        sflow: Sflow | None = None,
        snmp_server: SnmpServer | None = None,
        spanning_tree: SpanningTree | None = None,
        standard_access_lists: list[StandardAccessListsItem] | None = None,
        static_routes: list[StaticRoutesItem] | None = None,
        stun: Stun | None = None,
        switchport_default: SwitchportDefault | None = None,
        switchport_port_security: SwitchportPortSecurity | None = None,
        sync_e: SyncE | None = None,
        system: System | None = None,
        tacacs_servers: TacacsServers | None = None,
        tap_aggregation: TapAggregation | None = None,
        tcam_profile: TcamProfile | None = None,
        terminal: Terminal | None = None,
        trackers: list[TrackersItem] | None = None,
        traffic_policies: TrafficPolicies | None = None,
        transceiver_qsfp_default_mode_4x10: bool | None = True,
        tunnel_interfaces: list[TunnelInterfacesItem] | None = None,
        virtual_source_nat_vrfs: list[VirtualSourceNatVrfsItem] | None = None,
        vlan_interfaces: list[VlanInterfacesItem] | None = None,
        vlan_internal_order: VlanInternalOrder | None = None,
        vlans: list[VlansItem] | None = None,
        vmtracer_sessions: list[VmtracerSessionsItem] | None = None,
        vrfs: list[VrfsItem] | None = None,
        vxlan_interface: VxlanInterface | None = None,
        **kwargs: Any,
    ) -> None:
        """
        EosCliConfigGen.

        Args:
        -----
            aaa_accounting: aaa_accounting
            aaa_authentication: aaa_authentication
            aaa_authorization: aaa_authorization
            aaa_root: aaa_root
            aaa_server_groups: aaa_server_groups
            access_lists: access_lists
            address_locking: address_locking
            agents: agents
            aliases:
               Multi-line string with one or more alias commands.

        Example:
               ```yaml
               aliases: |
                 alias wr copy
               running-config startup-config
                 alias siib show ip interface brief
               ```
            application_traffic_recognition: Application traffic recognition configuration.
            arp: arp
            as_path: as_path
            avd_data_validation_mode:
               Validation Mode for AVD input data validation.
               Input data validation will validate the input
               variables according to the schema.
               During validation, messages will generated with information about
               the host(s) and key(s) which failed validation.
               "error" will produce error messages and fail the
               task.
               "warning" will produce warning messages.
            banners: banners
            bgp_groups: bgp_groups
            boot: Set the Aboot password.
            class_maps: class_maps
            clock: clock
            community_lists: community_lists
            config_comment:
               Add a comment to provide information about the configuration.
               This comment will be rendered at the
               top of the generated configuration.
            config_end: Render `end` at the end of the configuration.
            custom_templates:
               - Custom templates can be added below the playbook directory.
               - If a location above the directory is
               desired, a symbolic link can be used.
               - Example under the `playbooks` directory create symbolic link
               with the following command:

                 ```bash
                 ln -s ../../shared_repo/custom_avd_templates/
               ./custom_avd_templates
                 ```

               - The output will be rendered at the end of the configuration.
               - The
               order of custom templates in the list can be important if they overlap.
               - It is recommended to use a
               `!` delimiter at the top of each custom template.

               Add `custom_templates` to group/host variables:
            cvx:
               CVX server features are not supported on physical switches. See `management_cvx` for client
               configurations.
            daemon_terminattr:
               You can either provide a list of IPs/FQDNs to target on-premise Cloudvision cluster or use DNS name
               for your Cloudvision as a Service instance.
               Streaming to multiple clusters both on-prem and cloud
               service is supported.

               !!! note
                   For TerminAttr version recommendation and EOS compatibility
               matrix, please refer to the latest TerminAttr Release Notes
                   which always contain the latest
               recommended versions and minimum required versions per EOS release.
            daemons:
               This will add a daemon to the eos configuration that is most useful when trying to run OpenConfig
               clients like ocprometheus.
            dhcp_relay: dhcp_relay
            dhcp_servers: dhcp_servers
            dns_domain: Domain Name.
            domain_list: Search list of DNS domains.
            dot1x: dot1x
            dps_interfaces: dps_interfaces
            dynamic_prefix_lists: dynamic_prefix_lists
            enable_password: enable_password
            eos_cli: Multiline string with EOS CLI rendered directly on the root level of the final EOS configuration.
            eos_cli_config_gen_configuration: eos_cli_config_gen_configuration
            eos_cli_config_gen_documentation: eos_cli_config_gen_documentation
            errdisable: errdisable
            ethernet_interfaces: ethernet_interfaces
            event_handlers:
               Gives the ability to monitor and react to Syslog messages.
               Event Handlers provide a powerful and
               flexible tool that can be used to apply self-healing actions,
               customize the system behavior, and
               implement workarounds to problems discovered in the field.
            event_monitor: event_monitor
            flow_tracking: flow_tracking
            generate_default_config:
               The `generate_default_config` knob allows to omit default EOS configuration.
               This can be useful when
               leveraging `eos_cli_config_gen` to generate configlets with CloudVision.

               The following commands
               will be omitted when `generate_default_config` is set to `false`:

               - RANCID Content Type
               - Hostname
               (even if `hostname` variable is not set. Then the hostname is picked up from `inventory_hostname`)
               -
               Default configuration for `aaa`
               - Default configuration for `enable password`
               - Transceiver qsfp
               default mode
               - End of configuration delimiter
            generate_device_documentation: generate_device_documentation
            hardware: hardware
            hardware_counters: hardware_counters
            hostname: hostname
            interface_defaults: interface_defaults
            interface_groups: interface_groups
            interface_profiles: interface_profiles
            ip_access_lists: ip_access_lists
            ip_access_lists_max_entries: Limit ACL entries defined under the `ip_access_lists`.
            ip_community_lists: Communities and regexp entries MUST not be configured in the same community-list.
            ip_dhcp_relay: ip_dhcp_relay
            ip_dhcp_snooping: ip_dhcp_snooping
            ip_domain_lookup: ip_domain_lookup
            ip_extcommunity_lists: ip_extcommunity_lists
            ip_extcommunity_lists_regexp: ip_extcommunity_lists_regexp
            ip_ftp_client_source_interfaces: ip_ftp_client_source_interfaces
            ip_hardware: ip_hardware
            ip_http_client_source_interfaces: ip_http_client_source_interfaces
            ip_icmp_redirect: ip_icmp_redirect
            ip_igmp_snooping: ip_igmp_snooping
            ip_name_servers: ip_name_servers
            ip_nat: ip_nat
            ip_radius_source_interfaces: ip_radius_source_interfaces
            ip_routing: ip_routing
            ip_routing_ipv6_interfaces: ip_routing_ipv6_interfaces
            ip_security: ip_security
            ip_ssh_client_source_interfaces: ip_ssh_client_source_interfaces
            ip_tacacs_source_interfaces: ip_tacacs_source_interfaces
            ip_telnet_client_source_interfaces: ip_telnet_client_source_interfaces
            ip_tftp_client_source_interfaces: ip_tftp_client_source_interfaces
            ip_virtual_router_mac_address: MAC address (hh:hh:hh:hh:hh:hh).
            ipv6_access_lists: ipv6_access_lists
            ipv6_dhcp_relay: ipv6_dhcp_relay
            ipv6_hardware: ipv6_hardware
            ipv6_icmp_redirect: ipv6_icmp_redirect
            ipv6_neighbor: ipv6_neighbor
            ipv6_prefix_lists: ipv6_prefix_lists
            ipv6_standard_access_lists: ipv6_standard_access_lists
            ipv6_static_routes: ipv6_static_routes
            ipv6_unicast_routing: ipv6_unicast_routing
            is_deployed: Key only used for documentation or validation purposes.
            l2_protocol: l2_protocol
            lacp: Set Link Aggregation Control Protocol (LACP) parameters.
            link_tracking_groups: link_tracking_groups
            lldp: lldp
            load_interval: load_interval
            local_users: local_users
            logging: logging
            loopback_interfaces: loopback_interfaces
            mac_access_lists: mac_access_lists
            mac_address_table: mac_address_table
            mac_security: mac_security
            maintenance: maintenance
            management_accounts: management_accounts
            management_api_gnmi: management_api_gnmi
            management_api_http: management_api_http
            management_api_models: management_api_models
            management_console: management_console
            management_cvx: management_cvx
            management_defaults: management_defaults
            management_interfaces: management_interfaces
            management_security: management_security
            management_ssh: management_ssh
            management_tech_support: management_tech_support
            match_list_input: match_list_input
            mcs_client: mcs_client
            metadata:
               The data under `metadata` is used for documentation, validation or integration purposes.
               It will not
               affect the generated EOS configuration.
            mlag_configuration: mlag_configuration
            monitor_connectivity: monitor_connectivity
            monitor_layer1: Enable SYSLOG messages on transceiver SMBus communication failures.
            monitor_session_default_encapsulation_gre: monitor_session_default_encapsulation_gre
            monitor_sessions: monitor_sessions
            monitor_telemetry_influx: monitor_telemetry_influx
            monitor_telemetry_postcard_policy: monitor_telemetry_postcard_policy
            mpls: mpls
            ntp: ntp
            patch_panel: patch_panel
            peer_filters: peer_filters
            platform: Every key below this point is platform dependent.
            poe: poe
            policy_maps: policy_maps
            port_channel_interfaces: port_channel_interfaces
            prefix_lists: prefix_lists
            priority_flow_control: Global Priority Flow Control settings.
            prompt: prompt
            ptp: ptp
            qos: qos
            qos_profiles: qos_profiles
            queue_monitor_length: queue_monitor_length
            queue_monitor_streaming: queue_monitor_streaming
            radius_server: radius_server
            redundancy: redundancy
            roles: roles
            route_maps: route_maps
            router_adaptive_virtual_topology: router_adaptive_virtual_topology
            router_bfd: router_bfd
            router_bgp: router_bgp
            router_general: router_general
            router_igmp: router_igmp
            router_internet_exit: Internet-exit feature to configure internet bound service for virtual topologies.
            router_isis: router_isis
            router_l2_vpn: router_l2_vpn
            router_msdp: router_msdp
            router_multicast: router_multicast
            router_ospf: router_ospf
            router_path_selection: Dynamic path selection configuration.
            router_pim_sparse_mode: router_pim_sparse_mode
            router_segment_security: router_segment_security
            router_service_insertion: Configure network services inserted to data forwarding.
            router_traffic_engineering: router_traffic_engineering
            service_routing_configuration_bgp: service_routing_configuration_bgp
            service_routing_protocols_model: service_routing_protocols_model
            service_unsupported_transceiver: service_unsupported_transceiver
            sflow: sflow
            snmp_server: SNMP settings.
            spanning_tree: spanning_tree
            standard_access_lists: standard_access_lists
            static_routes: static_routes
            stun: STUN configuration.
            switchport_default: switchport_default
            switchport_port_security: switchport_port_security
            sync_e: sync_e
            system: system
            tacacs_servers: tacacs_servers
            tap_aggregation: tap_aggregation
            tcam_profile: tcam_profile
            terminal: terminal
            trackers: trackers
            traffic_policies: traffic_policies
            transceiver_qsfp_default_mode_4x10:
               On all front panel ports which support this feature, the following global configuration command
               changes the QSFP mode from 40G to 4x10G (default). When set to false the command reverts the default
               QSFP mode back to 40G.
            tunnel_interfaces: tunnel_interfaces
            virtual_source_nat_vrfs: virtual_source_nat_vrfs
            vlan_interfaces: vlan_interfaces
            vlan_internal_order: vlan_internal_order
            vlans: vlans
            vmtracer_sessions: vmtracer_sessions
            vrfs: These keys are ignored if the name of the vrf is 'default'.
            vxlan_interface: vxlan_interface

        """
        for arg, arg_value in locals().items():
            if arg in ("self", "kwargs"):
                continue
            setattr(self, arg, arg_value)
